Based on my deep analysis, I can see the bot is still making critical errors. The main issue in the latest game was:
1. Playing g3 allowing Bxg3
2. NOT recapturing on g3 (playing c4 instead of hxg3/fxg3)

The bot needs a stronger ABSOLUTE RECAPTURE system. Let me implement v40.17:
Action: file_editor view /app/Lichess Bot-AlphaZero-Pure.user.js
Observation: /app/Lichess Bot-AlphaZero-Pure.user.js:
1650|    v40AllKingsidePawnsMissingPenalty: -20000000,   // Catastrophic!
1651|    
1652|    // v40.16: FORCING LINE REJECTION — Reject moves that allow forcing sequences
1653|    v40ForcingLineRejectionEnabled: true,
1654|    v40ForcingLineLeadsToMatePenalty: -100000000,   // Reject if mate in line
1655|    v40ForcingLineLosesMaterialPenalty: -15000000,  // Reject if loses material
1656|    v40ForcingLineRuinsPositionPenalty: -8000000,   // Reject if ruins position
1657|    
1658|    // v40.16: 100% CATASTROPHIC KINGSIDE DEFENSE SUPREME DOMINANCE
1659|    v40CatastrophicKingsideDefenseDominance: 1.0,   // 100% v40.16 influence
1660|};
1661|
1662|// ═══════════════════════════════════════════════════════════════════════
1663|// v37.0.0: TRANSCENDENT MCTS TREE STRUCTURE
1664|// ═══════════════════════════════════════════════════════════════════════
1665|
1666|/**
1667| * v37: TRUE MCTS Node structure for proper tree search
1668| */
1669|class MCTSNode {
1670|    constructor(move, parent = null, prior = 1.0) {
1671|        this.move = move;
1672|        this.parent = parent;
1673|        this.children = new Map();
1674|        this.visits = 0;
1675|        this.totalValue = 0;
1676|        this.prior = prior;           // Policy prior (P)
1677|        this.virtualLoss = 0;
1678|        this.isExpanded = false;
1679|        this.isTerminal = false;
1680|        this.depth = parent ? parent.depth + 1 : 0;
1681|    }
1682|    
1683|    get value() {
1684|        return this.visits > 0 ? this.totalValue / this.visits : 0;
1685|    }
1686|    
1687|    get ucb1Score() {
1688|        if (!this.parent || this.parent.visits === 0) return Infinity;
1689|        
1690|        const exploitation = this.value;
1691|        const exploration = CONFIG.v37MCTSExplorationConstant * 
1692|            Math.sqrt(Math.log(this.parent.visits) / (this.visits + 1));
1693|        
1694|        return exploitation + exploration;
1695|    }
1696|    
1697|    get puctScore() {
1698|        if (!this.parent || this.parent.visits === 0) return Infinity;
1699|        
1700|        const Q = this.value;
1701|        const U = CONFIG.v37MCTSPUCTConstant * this.prior * 
1702|            Math.sqrt(this.parent.visits) / (1 + this.visits);
1703|        
1704|        // Apply virtual loss for diversity
1705|        const virtualLossAdjustment = this.virtualLoss * CONFIG.v37MCTSVirtualLoss / (this.visits + 1);
1706|        
1707|        return Q + U - virtualLossAdjustment;
1708|    }
1709|    
1710|    selectChild() {
1711|        if (this.children.size === 0) return null;
1712|        
1713|        let bestChild = null;
1714|        let bestScore = -Infinity;
1715|        
1716|        for (const [move, child] of this.children) {
1717|            const score = child.puctScore;
1718|            if (score > bestScore) {
1719|                bestScore = score;
1720|                bestChild = child;
