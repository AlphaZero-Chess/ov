
Action: file_editor str_replace /app/Lichess Bot-AlphaZero-Pure.user.js --old-str "    return String.fromCharCode(97 + newFile) + (newRank + 1);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function findAttackedPiecesV40_9(board, color) {" --new-str "    return String.fromCharCode(97 + newFile) + (newRank + 1);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// v40.36 QUEEN CAPTURE PROHIBITION & CASTLING DIRECTION SUPREME FUNCTIONS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/**
 * v40.36: QUEEN CAPTURE PROHIBITION â€” Never capture with queen early
 * Critical fix from Sicilian game: Qxd4 was TERRIBLE move
 */
function v40QueenCaptureProhibitionEval(fen, move, board, activeColor, moveNumber) {
    if (!CONFIG.v40QueenCaptureProhibitionEnabled) return 0;
    
    let score = 0;
    const maxMoves = CONFIG.v40QueenCaptureMoveLimit || 15;
    
    if (moveNumber > maxMoves) return 0;
    
    const fromSquare = move.substring(0, 2);
    const toSquare = move.substring(2, 4);
    const movingPiece = board.get(fromSquare);
    const capturedPiece = board.get(toSquare);
    
    // Check if queen is capturing
    if (movingPiece && movingPiece.toLowerCase() === 'q' && capturedPiece) {
        debugLog(\"[V40.36_QUEEN]\", `ðŸš«ðŸš«ðŸš« QUEEN CAPTURE PROHIBITION: Queen capturing ${capturedPiece} on ${toSquare}!`);
        score += CONFIG.v40QueenCapturePenalty || -20000000000000;
        
        // ABSOLUTE PROHIBITION for Qxd4 or Qxd5 (center pawn capture)
        if (toSquare === 'd4' || toSquare === 'd5' || toSquare === 'e4' || toSquare === 'e5') {
            debugLog(\"[V40.36_QUEEN]\", `ðŸš«ðŸš«ðŸš« CRITICAL: Qxd4/Qxd5/Qxe4/Qxe5 is CATASTROPHIC!`);
            score += CONFIG.v40QueenCaptureQxd4Penalty || -50000000000000;
        }
    }
    
    return score;
}

/**
 * v40.36: KNIGHT SACRIFICE PREVENTION â€” Don't sacrifice knight for pawn
 * Critical fix from Sicilian game: Nxe5 dxe5 was TERRIBLE
 */
function v40KnightSacrificePreventionEval(fen, move, board, activeColor, moveNumber) {
    if (!CONFIG.v40KnightSacrificePreventionEnabled) return 0;
    
    let score = 0;
    const fromSquare = move.substring(0, 2);
    const toSquare = move.substring(2, 4);
    const movingPiece = board.get(fromSquare);
    const capturedPiece = board.get(toSquare);
    
    // Check if knight is capturing a pawn
    if (movingPiece && movingPiece.toLowerCase() === 'n' && 
        capturedPiece && capturedPiece.toLowerCase() === 'p') {
        
        // Check if the knight would be recaptured
        const afterBoard = simulateMoveOnBoard(board, move);
        const isWhite = activeColor === 'w';
        const enemyColor = isWhite ? 'b' : 'w';
        
        if (isSquareAttackedByColor(afterBoard, toSquare, enemyColor)) {
            // Knight will be recaptured - check if it's defended enough
            const ourDefenders = countDefendersOfSquare(afterBoard, toSquare, activeColor);
            const theirAttackers = countAttackersOfSquare(afterBoard, toSquare, enemyColor);
            
            if (theirAttackers > ourDefenders) {
                debugLog(\"[V40.36_KNIGHT]\", `ðŸš«ðŸš«ðŸš« KNIGHT SACRIFICE PREVENTION: Nxp will lose knight!`);
                score += CONFIG.v40KnightForPawnPenalty || -30000000000000;
            }
        }
    }
    
    return score;
}

/**
 * v40.36: CASTLING DIRECTION ANALYSIS â€” Don't castle into danger
 * Critical fix from Sicilian game: O-O-O was TERRIBLE when queenside was under attack
 */
function v40CastlingDirectionEval(fen, move, board, activeColor, moveNumber) {
    if (!CONFIG.v40CastlingDirectionEnabled) return 0;
    
    let score = 0;
    const isWhite = activeColor === 'w';
    
    // Check if this is a castling move
    const isKingsideCastle = (move === 'e1g1' || move === 'e8g8');
    const isQueensideCastle = (move === 'e1c1' || move === 'e8c8');
    
    if (!isKingsideCastle && !isQueensideCastle) return 0;
    
    const enemyColor = isWhite ? 'b' : 'w';
    
    if (isQueensideCastle) {
        // Count enemy pieces that can attack queenside
        const queenSideAttackers = v40CountSideAttackers(board, enemyColor, 'queenside');
        const dangerThreshold = CONFIG.v40QueensideCastleDangerThreshold || 2;
        
        if (queenSideAttackers >= dangerThreshold) {
            debugLog(\"[V40.36_CASTLE]\", `ðŸš«ðŸš«ðŸš« CASTLING DANGER: O-O-O with ${queenSideAttackers} pieces attacking queenside!`);
            score += CONFIG.v40CastleIntoDangerPenalty || -40000000000000;
        }
        
        // Also check if enemy rooks/queen are on a/b/c files
        for (const [square, piece] of board) {
            if (!piece) continue;
            const pieceIsWhite = piece === piece.toUpperCase();
            if (pieceIsWhite === isWhite) continue;
            
            const pieceType = piece.toLowerCase();
            const file = square[0];
            
            if ((pieceType === 'r' || pieceType === 'q') && ['a', 'b', 'c'].includes(file)) {
                debugLog(\"[V40.36_CASTLE]\", `ðŸš«ðŸš«ðŸš« DANGER: Enemy ${pieceType} on ${square} attacks queenside!`);
                score += (CONFIG.v40CastleIntoDangerPenalty || -40000000000000) / 2;
            }
        }
    }
    
    if (isKingsideCastle) {
        // Count enemy pieces that can attack kingside
        const kingSideAttackers = v40CountSideAttackers(board, enemyColor, 'kingside');
        const dangerThreshold = CONFIG.v40KingsideCastleDangerThreshold || 2;
        
        if (kingSideAttackers >= dangerThreshold) {
            debugLog(\"[V40.36_CASTLE]\", `ðŸš«ðŸš«ðŸš« CASTLING DANGER: O-O with ${kingSideAttackers} pieces attacking kingside!`);
            score += CONFIG.v40CastleIntoDangerPenalty || -40000000000000;
        }
        
        // Also check if enemy rooks/queen are on f/g/h files
        for (const [square, piece] of board) {
            if (!piece) continue;
            const pieceIsWhite = piece === piece.toUpperCase();
            if (pieceIsWhite === isWhite) continue;
            
            const pieceType = piece.toLowerCase();
            const file = square[0];
            
            if ((pieceType === 'r' || pieceType === 'q') && ['f', 'g', 'h'].includes(file)) {
                debugLog(\"[V40.36_CASTLE]\", `ðŸš«ðŸš«ðŸš« DANGER: Enemy ${pieceType} on ${square} attacks kingside!`);
                score += (CONFIG.v40CastleIntoDangerPenalty || -40000000000000) / 2;
            }
        }
    }
    
    return score;
}

/**
 * v40.36 Helper: Count attackers on a side of the board
 */
function v40CountSideAttackers(board, color, side) {
    let count = 0;
    const isWhite = color === 'w';
    
    const queenSideSquares = ['a1', 'a2', 'a3', 'b1', 'b2', 'b3', 'c1', 'c2', 'c3', 'd1', 'd2', 'd3',
                              'a8', 'a7', 'a6', 'b8', 'b7', 'b6', 'c8', 'c7', 'c6', 'd8', 'd7', 'd6'];
    const kingSideSquares = ['e1', 'e2', 'e3', 'f1', 'f2', 'f3', 'g1', 'g2', 'g3', 'h1', 'h2', 'h3',
                             'e8', 'e7', 'e6', 'f8', 'f7', 'f6', 'g8', 'g7', 'g6', 'h8', 'h7', 'h6'];
    
    const targetSquares = side === 'queenside' ? queenSideSquares : kingSideSquares;
    
    for (const [square, piece] of board) {
        if (!piece) continue;
        const pieceIsWhite = piece === piece.toUpperCase();
        if (pieceIsWhite !== isWhite) continue;
        
        const pieceType = piece.toLowerCase();
        if (pieceType === 'p' || pieceType === 'k') continue;
        
        // Check if this piece attacks any square on the target side
        for (const targetSq of targetSquares) {
            if (v40DoesAttackSquare(board, square, targetSq, piece)) {
                count++;
                break; // Count each piece only once
            }
        }
    }
    
    return count;
}

/**
 * v40.36: EXCHANGE QUALITY VERIFICATION â€” Don't trade in bad positions
 */
function v40ExchangeQualityEval(fen, move, board, activeColor, moveNumber) {
    if (!CONFIG.v40ExchangeQualityEnabled) return 0;
    
    let score = 0;
    const fromSquare = move.substring(0, 2);
    const toSquare = move.substring(2, 4);
    const movingPiece = board.get(fromSquare);
    const capturedPiece = board.get(toSquare);
    
    // Only evaluate captures
    if (!capturedPiece) return 0;
    
    const isWhite = activeColor === 'w';
    const ourMaterial = v40CalculateMaterial(board, isWhite);
    const theirMaterial = v40CalculateMaterial(board, !isWhite);
    
    // Check if we're behind in material
    if (ourMaterial < theirMaterial - 100) {
        // When behind, avoid simplifying trades
        if (movingPiece && capturedPiece) {
            const movingValue = getPieceValueSimple(movingPiece.toLowerCase());
            const capturedValue = getPieceValueSimple(capturedPiece.toLowerCase());
            
            // Equal or losing trade when behind
            if (Math.abs(movingValue - capturedValue) <= 100) {
                debugLog(\"[V40.36_EXCHANGE]\", `âš ï¸ BAD EXCHANGE: Trading when behind! Material: ${ourMaterial} vs ${theirMaterial}`);
                score += CONFIG.v40ExchangeWhenLosingPenalty || -25000000000000;
            }
        }
    }
    
    // Check if this trade loses material
    const afterBoard = simulateMoveOnBoard(board, move);
    const enemyColor = isWhite ? 'b' : 'w';
    
    if (movingPiece && isSquareAttackedByColor(afterBoard, toSquare, enemyColor)) {
        const defenders = countDefendersOfSquare(afterBoard, toSquare, activeColor);
        const attackers = countAttackersOfSquare(afterBoard, toSquare, enemyColor);
        
        if (attackers > defenders) {
            const movingValue = getPieceValueSimple(movingPiece.toLowerCase());
            const capturedValue = getPieceValueSimple(capturedPiece.toLowerCase());
            
            if (movingValue > capturedValue) {
                debugLog(\"[V40.36_EXCHANGE]\", `ðŸš«ðŸš«ðŸš« BAD EXCHANGE: Losing ${movingPiece} for ${capturedPiece}!`);
                score += CONFIG.v40BadExchangePenalty || -15000000000000;
            }
        }
    }
    
    return score;
}

/**
 * v40.36: PIECE ACTIVITY REQUIREMENT â€” Must develop before passive moves
 */
function v40PieceActivityRequirementEval(fen, move, board, activeColor, moveNumber) {
    if (!CONFIG.v40PieceActivityEnabled) return 0;
    if (moveNumber > 20) return 0; // Only apply in opening
    
    let score = 0;
    const isWhite = activeColor === 'w';
    const developmentLevel = v40CountDevelopedPieces(board, isWhite);
    const requiredDevelopment = CONFIG.v40DevelopmentRequirement || 3;
    
    // Check if this is a passive move
    const fromSquare = move.substring(0, 2);
    const movingPiece = board.get(fromSquare);
    
    // Pawn moves to a3/h3/b3/g3 type squares
    const passivePawnMoves = ['a2a3', 'h2h3', 'a7a6', 'h7h6', 'b2b3', 'g2g3', 'a2a4', 'h2h4', 'a7a5', 'h7h5'];
    
    if (passivePawnMoves.includes(move) && developmentLevel < requiredDevelopment) {
        debugLog(\"[V40.36_ACTIVITY]\", `ðŸš«ðŸš«ðŸš« UNDEVELOPED: Playing ${move} with only ${developmentLevel} pieces developed!`);
        score += CONFIG.v40UndevelopedPiecePenalty || -5000000000000;
    }
    
    return score;
}

/**
 * v40.36 Helper: Count developed pieces
 */
function v40CountDevelopedPieces(board, isWhite) {
    let count = 0;
    
    // Starting squares for pieces
    const whiteStartingSquares = {
        'b1': 'n', 'g1': 'n', 'c1': 'b', 'f1': 'b'
    };
    const blackStartingSquares = {
        'b8': 'n', 'g8': 'n', 'c8': 'b', 'f8': 'b'
    };
    
    const startingSquares = isWhite ? whiteStartingSquares : blackStartingSquares;
    
    // Count pieces that have moved from starting squares
    for (const [startSq, pieceType] of Object.entries(startingSquares)) {
        const piece = board.get(startSq);
        const expectedPiece = isWhite ? pieceType.toUpperCase() : pieceType;
        
        // If the expected piece is NOT on its starting square, it's developed
        if (!piece || piece !== expectedPiece) {
            count++;
        }
    }
    
    // Also check if castled (king moved)
    const kingStartSq = isWhite ? 'e1' : 'e8';
    const kingPiece = board.get(kingStartSq);
    const expectedKing = isWhite ? 'K' : 'k';
    if (!kingPiece || kingPiece !== expectedKing) {
        count++; // Castled or king moved
    }
    
    return count;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function findAttackedPiecesV40_9(board, color) {"
Observation: Edit was successful.