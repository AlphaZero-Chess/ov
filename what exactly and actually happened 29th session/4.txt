Now let me add the v40.17 functions after v40ForcingLineRejectionEval:
Action: file_editor str_replace /app/Lichess Bot-AlphaZero-Pure.user.js --old-str "        debugLog(\"[V40.16_FORCE]\", `Error: ${e.message}`);
    }
    
    return score;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/**
 * v40.9 Helper: Find all attacked pieces for a color
 */
function findAttackedPiecesV40_9(board, color) {" --new-str "        debugLog(\"[V40.16_FORCE]\", `Error: ${e.message}`);
    }
    
    return score;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// v40.17 ABSOLUTE RECAPTURE SUPREME â€” NEVER LEAVE FREE PIECES ON THE BOARD
// From game analysis: Bot played c4 instead of recapturing bishop on g3!
// This is UNACCEPTABLE. Material is KING. AlphaZero NEVER misses free material.
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/**
 * v40.17 ABSOLUTE RECAPTURE: If enemy just captured, we MUST recapture
 * This function gives MASSIVE bonus to recapturing moves and MASSIVE penalty to others
 */
function v40AbsoluteRecaptureEval(fen, move, board, activeColor, moveNumber, lastMove) {
    if (!CONFIG.v40AbsoluteRecaptureEnabled) return 0;
    
    let score = 0;
    const isWhite = activeColor === 'w';
    const enemyColor = isWhite ? 'b' : 'w';
    
    try {
        // Find all enemy pieces that are on squares where we can capture them
        const freeCaptures = [];
        
        for (const [sq, piece] of board) {
            if (!piece) continue;
            const pieceIsWhite = piece === piece.toUpperCase();
            if (pieceIsWhite === isWhite) continue; // Skip our pieces
            
            const pieceType = piece.toLowerCase();
            if (pieceType === 'k') continue; // Can't capture king
            
            // Check if this enemy piece is hanging (can be captured for free)
            const isDefended = isSquareDefendedByColor(board, sq, enemyColor);
            const isAttackable = isSquareAttackedByColor(board, sq, activeColor);
            
            if (isAttackable) {
                const value = getPieceValueSimple(pieceType);
                
                if (!isDefended) {
                    // FREE CAPTURE! This is a MUST-TAKE
                    freeCaptures.push({ square: sq, piece, value, type: 'free' });
                    debugLog(\"[V40.17_RECAP]\", `ðŸŽ¯ FREE ENEMY PIECE: ${pieceType.toUpperCase()} on ${sq} (value=${value})!`);
                } else {
                    // Defended but might still be good to capture
                    // Find our lowest value attacker
                    const ourAttackers = findAttackersOfSquare(board, sq, activeColor);
                    if (ourAttackers.length > 0) {
                        const lowestAttackerValue = Math.min(...ourAttackers.map(a => getPieceValueSimple(a.piece.toLowerCase())));
                        if (lowestAttackerValue < value) {
                            // We can win material!
                            freeCaptures.push({ square: sq, piece, value, type: 'winning', attackerValue: lowestAttackerValue });
                        }
                    }
                }
            }
        }
        
        // Now check if our move IS a recapture of a free piece
        const toSquare = move.substring(2, 4);
        const capturedPiece = board.get(toSquare);
        
        // Is our move capturing something?
        if (capturedPiece) {
            const capturedValue = getPieceValueSimple(capturedPiece.toLowerCase());
            
            // Check if this is capturing one of the free pieces
            const isFreeCapture = freeCaptures.find(fc => fc.square === toSquare);
            
            if (isFreeCapture) {
                // EXCELLENT! We're taking a free/winning piece
                score += CONFIG.v40RecaptureMustHappenBonus * (capturedValue / 9);
                debugLog(\"[V40.17_RECAP]\", `âœ…âœ…âœ… EXCELLENT: ${move} captures ${isFreeCapture.type} piece ${capturedPiece} (value=${capturedValue})!`);
                
                // Extra bonus for high-value captures
                if (capturedValue >= 9) {
                    score += CONFIG.v40RecaptureHighValuePieceBonus;
                    debugLog(\"[V40.17_RECAP]\", `ðŸ‘‘ QUEEN CAPTURED!`);
                } else if (capturedValue >= 5) {
                    score += CONFIG.v40RecaptureHighValuePieceBonus / 2;
                    debugLog(\"[V40.17_RECAP]\", `ðŸ° ROOK CAPTURED!`);
                }
            }
        } else {
            // Our move is NOT a capture
            // If there are free pieces on the board, PENALIZE this move heavily
            const highValueFreeCaptures = freeCaptures.filter(fc => fc.value >= 3 && fc.type === 'free');
            
            if (highValueFreeCaptures.length > 0) {
                for (const fc of highValueFreeCaptures) {
                    score += CONFIG.v40FailToRecapturePenalty * (fc.value / 9);
                    debugLog(\"[V40.17_RECAP]\", `â˜ ï¸â˜ ï¸â˜ ï¸ BLUNDER: ${move} ignores FREE ${fc.piece} on ${fc.square}! MUST CAPTURE!`);
                }
            }
            
            // Also penalize if there are winning captures available
            const winningCaptures = freeCaptures.filter(fc => fc.type === 'winning' && (fc.value - fc.attackerValue) >= 2);
            if (winningCaptures.length > 0) {
                for (const wc of winningCaptures) {
                    score += CONFIG.v40FreeEnemyPieceOnBoardPenalty * ((wc.value - wc.attackerValue) / 9);
                    debugLog(\"[V40.17_RECAP]\", `âš ï¸ ${move} ignores winning capture on ${wc.square}!`);
                }
            }
        }
        
    } catch (e) {
        debugLog(\"[V40.17_RECAP]\", `Error: ${e.message}`);
    }
    
    return score;
}

/**
 * v40.17 IMMEDIATE CAPTURE DETECTION: After our move, can opponent take something for free?
 * This catches blunders like playing g3 when bishop can take it
 */
function v40ImmediateCaptureDetectionEval(fen, move, board, activeColor, moveNumber) {
    if (!CONFIG.v40ImmediateCaptureEnabled) return 0;
    
    let score = 0;
    const isWhite = activeColor === 'w';
    const enemyColor = isWhite ? 'b' : 'w';
    
    try {
        const fromSquare = move.substring(0, 2);
        const toSquare = move.substring(2, 4);
        const movingPiece = board.get(fromSquare);
        
        if (!movingPiece) return 0;
        
        // Simulate our move
        const afterMove = new Map(board);
        afterMove.delete(fromSquare);
        const capturedByUs = afterMove.get(toSquare);
        afterMove.set(toSquare, movingPiece);
        
        // Now find all OUR pieces that opponent can capture
        for (const [sq, piece] of afterMove) {
            if (!piece) continue;
            const pieceIsWhite = piece === piece.toUpperCase();
            if (pieceIsWhite !== isWhite) continue; // Skip enemy pieces
            
            const pieceType = piece.toLowerCase();
            if (pieceType === 'k') continue; // King handled separately
            
            // Can enemy attack this square?
            if (isSquareAttackedByColor(afterMove, sq, enemyColor)) {
                // Is it defended?
                const isDefended = isSquareDefendedByColor(afterMove, sq, activeColor);
                const pieceValue = getPieceValueSimple(pieceType);
                
                if (!isDefended) {
                    // HANGING PIECE! This is a BLUNDER!
                    if (pieceType === 'q') {
                        score += CONFIG.v40OpponentCanTakeQueenPenalty;
                        debugLog(\"[V40.17_IMM]\", `â˜ ï¸â˜ ï¸â˜ ï¸ QUEEN HANGING on ${sq} after ${move}!`);
                    } else if (pieceType === 'r') {
                        score += CONFIG.v40OpponentCanTakeRookPenalty;
                        debugLog(\"[V40.17_IMM]\", `â˜ ï¸â˜ ï¸ ROOK HANGING on ${sq} after ${move}!`);
                    } else if (pieceType === 'b' || pieceType === 'n') {
                        score += CONFIG.v40OpponentCanTakeMinorPenalty;
                        debugLog(\"[V40.17_IMM]\", `â˜ ï¸ MINOR PIECE HANGING on ${sq} after ${move}!`);
                    } else if (pieceType === 'p') {
                        score += CONFIG.v40UndefendedPawnPenalty;
                        debugLog(\"[V40.17_IMM]\", `âš ï¸ Pawn hanging on ${sq} after ${move}`);
                    }
                } else {
                    // Defended but check if attacker is lower value
                    const attackers = findAttackersOfSquare(afterMove, sq, enemyColor);
                    if (attackers.length > 0) {
                        const lowestAttackerValue = Math.min(...attackers.map(a => getPieceValueSimple(a.piece.toLowerCase())));
                        if (lowestAttackerValue < pieceValue) {
                            // Enemy can win material even though it's defended
                            const materialLoss = pieceValue - lowestAttackerValue;
                            score += CONFIG.v40OpponentCanTakeFreeBonus * (materialLoss / 9);
                            debugLog(\"[V40.17_IMM]\", `âš ï¸ ${pieceType.toUpperCase()} on ${sq} can be won by lower-value attacker after ${move}`);
                        }
                    }
                }
            }
        }
        
        // Also check: does our moving piece become hanging?
        const movingPieceValue = getPieceValueSimple(movingPiece.toLowerCase());
        if (isSquareAttackedByColor(afterMove, toSquare, enemyColor)) {
            const isDefended = isSquareDefendedByColor(afterMove, toSquare, activeColor);
            
            if (!isDefended) {
                // We moved to a square where we're hanging!
                if (movingPiece.toLowerCase() === 'q') {
                    score += CONFIG.v40OpponentCanTakeQueenPenalty;
                    debugLog(\"[V40.17_IMM]\", `â˜ ï¸â˜ ï¸â˜ ï¸ ${move} leaves QUEEN HANGING!`);
                } else if (movingPiece.toLowerCase() === 'r') {
                    score += CONFIG.v40OpponentCanTakeRookPenalty;
                    debugLog(\"[V40.17_IMM]\", `â˜ ï¸â˜ ï¸ ${move} leaves ROOK HANGING!`);
                } else if (['b', 'n'].includes(movingPiece.toLowerCase())) {
                    score += CONFIG.v40OpponentCanTakeMinorPenalty;
                    debugLog(\"[V40.17_IMM]\", `â˜ ï¸ ${move} leaves MINOR PIECE HANGING!`);
                }
            }
        }
        
    } catch (e) {
        debugLog(\"[V40.17_IMM]\", `Error: ${e.message}`);
    }
    
    return score;
}

/**
 * v40.17 MATERIAL AWARENESS: Track material balance and reward material gains
 */
function v40MaterialAwarenessEval(fen, move, board, activeColor, moveNumber) {
    if (!CONFIG.v40MaterialAwarenessEnabled) return 0;
    
    let score = 0;
    const isWhite = activeColor === 'w';
    
    try {
        const fromSquare = move.substring(0, 2);
        const toSquare = move.substring(2, 4);
        const movingPiece = board.get(fromSquare);
        const capturedPiece = board.get(toSquare);
        
        if (!movingPiece) return 0;
        
        // If we're capturing, calculate the gain
        if (capturedPiece) {
            const capturedValue = getPieceValueSimple(capturedPiece.toLowerCase());
            const movingPieceValue = getPieceValueSimple(movingPiece.toLowerCase());
            
            // Simulate move
            const afterMove = new Map(board);
            afterMove.delete(fromSquare);
            afterMove.set(toSquare, movingPiece);
            
            // Check if our piece will be recaptured
            const willBeRecaptured = isSquareAttackedByColor(afterMove, toSquare, isWhite ? 'b' : 'w');
            
            if (willBeRecaptured) {
                // Net exchange
                const netGain = capturedValue - movingPieceValue;
                if (netGain > 0) {
                    score += CONFIG.v40MaterialPerPointBonus * netGain;
                    debugLog(\"[V40.17_MAT]\", `âœ… Winning exchange: ${move} gains net ${netGain} points`);
                } else if (netGain < 0) {
                    score += CONFIG.v40LosingMaterialPenalty * Math.abs(netGain);
                    debugLog(\"[V40.17_MAT]\", `âš ï¸ Losing exchange: ${move} loses net ${Math.abs(netGain)} points`);
                }
            } else {
                // Free capture!
                score += CONFIG.v40MaterialPerPointBonus * capturedValue * 2;
                debugLog(\"[V40.17_MAT]\", `âœ…âœ… FREE CAPTURE: ${move} gains ${capturedValue} points!`);
            }
        }
        
        // Calculate overall material balance
        let ourMaterial = 0;
        let enemyMaterial = 0;
        
        for (const [sq, piece] of board) {
            if (!piece) continue;
            const pieceIsWhite = piece === piece.toUpperCase();
            const value = getPieceValueSimple(piece.toLowerCase());
            
            if (pieceIsWhite === isWhite) {
                ourMaterial += value;
            } else {
                enemyMaterial += value;
            }
        }
        
        // Bonus for being ahead in material
        const materialAdvantage = ourMaterial - enemyMaterial;
        if (materialAdvantage > 0) {
            // When ahead, prefer simplifying
            if (capturedPiece) {
                score += CONFIG.v40MaterialPerPointBonus * materialAdvantage / 10;
            }
        } else if (materialAdvantage < 0) {
            // When behind, avoid exchanges unless winning
            if (capturedPiece && !isSquareAttackedByColor(board, toSquare, isWhite ? 'b' : 'w')) {
                // Free capture when behind - GREAT!
                score += CONFIG.v40MaterialPerPointBonus * 5;
            }
        }
        
    } catch (e) {
        debugLog(\"[V40.17_MAT]\", `Error: ${e.message}`);
    }
    
    return score;
}

/**
 * v40.17 ANTI-PAWN-GRAB DEFENSE: Detect moves that allow opponent to grab pawns
 * From game analysis: Bot played g3 allowing Bxg3
 */
function v40AntiPawnGrabDefenseEval(fen, move, board, activeColor, moveNumber) {
    if (!CONFIG.v40PawnProtectionEnabled) return 0;
    
    let score = 0;
    const isWhite = activeColor === 'w';
    const enemyColor = isWhite ? 'b' : 'w';
    
    try {
        const fromSquare = move.substring(0, 2);
        const toSquare = move.substring(2, 4);
        const movingPiece = board.get(fromSquare);
        
        if (!movingPiece) return 0;
        
        // Simulate our move
        const afterMove = new Map(board);
        afterMove.delete(fromSquare);
        afterMove.set(toSquare, movingPiece);
        
        // Find all our pawns after the move
        for (const [sq, piece] of afterMove) {
            if (!piece) continue;
            const pieceIsWhite = piece === piece.toUpperCase();
            if (pieceIsWhite !== isWhite) continue;
            if (piece.toLowerCase() !== 'p') continue;
            
            // Is this pawn now attacked?
            if (isSquareAttackedByColor(afterMove, sq, enemyColor)) {
                const isDefended = isSquareDefendedByColor(afterMove, sq, activeColor);
                
                if (!isDefended) {
                    // Pawn is hanging!
                    score += CONFIG.v40UndefendedPawnPenalty;
                    debugLog(\"[V40.17_PAWN]\", `âš ï¸ Pawn on ${sq} undefended after ${move}`);
                } else {
                    // Check if a piece can profitably take it
                    const attackers = findAttackersOfSquare(afterMove, sq, enemyColor);
                    for (const attacker of attackers) {
                        if (['b', 'n', 'r', 'q'].includes(attacker.piece.toLowerCase())) {
                            // Minor/major piece attacking pawn
                            // Even if pawn is defended, this might be bad
                            const attackerValue = getPieceValueSimple(attacker.piece.toLowerCase());
                            
                            // Check if attacker is also defended
                            const attackerDefended = isSquareDefendedByColor(afterMove, attacker.square, enemyColor);
                            
                            if (attackerDefended) {
                                // Piece can safely take pawn and then be recaptured
                                // This is only good for enemy if pawn is more valuable than piece would lose
                                // Usually bad for enemy... unless our recapture opens lines
                            } else {
                                // Undefended piece attacking pawn - enemy probably won't take
                            }
                        }
                    }
                }
            }
        }
        
        // Special check: Are we moving a pawn to a square where it can be captured?
        if (movingPiece.toLowerCase() === 'p') {
            if (isSquareAttackedByColor(afterMove, toSquare, enemyColor)) {
                const isDefended = isSquareDefendedByColor(afterMove, toSquare, activeColor);
                if (!isDefended) {
                    score += CONFIG.v40PawnCanBeTakenByPiecePenalty;
                    debugLog(\"[V40.17_PAWN]\", `â˜ ï¸ ${move} moves pawn to hanging square!`);
                }
            }
        }
        
    } catch (e) {
        debugLog(\"[V40.17_PAWN]\", `Error: ${e.message}`);
    }
    
    return score;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/**
 * v40.9 Helper: Find all attacked pieces for a color
 */
function findAttackedPiecesV40_9(board, color) {"
Observation: Edit was successful.