
Action: file_editor view /app/Lichess Bot-AlphaZero-Pure.user.js
Observation: /app/Lichess Bot-AlphaZero-Pure.user.js:
28340|        const pieceIsWhite = piece === piece.toUpperCase();
28341|        if (pieceIsWhite !== isWhite) continue;  // Only our pieces
28342|        
28343|        const pieceType = piece.toLowerCase();
28344|        if (pieceType === 'p' || pieceType === 'k') continue;  // Skip pawns and king
28345|        
28346|        const attackers = v40GetPawnAttackers(board, square, activeColor);
28347|        
28348|        if (attackers.length > 0) {
28349|            result.push({
28350|                square,
28351|                piece,
28352|                pieceType,
28353|                pieceValue: getPieceValueSimple(pieceType),
28354|                attackers
28355|            });
28356|        }
28357|    }
28358|    
28359|    // Sort by value (highest first)
28360|    result.sort((a, b) => b.pieceValue - a.pieceValue);
28361|    
28362|    return result;
28363|}
28364|
28365|/**
28366| * v40.41 Helper: Get list of enemy pawns attacking a square
28367| */
28368|function v40GetPawnAttackers(board, square, activeColor) {
28369|    const attackers = [];
28370|    const isWhite = activeColor === 'w';
28371|    
28372|    const file = square.charCodeAt(0) - 'a'.charCodeAt(0);
28373|    const rank = parseInt(square.charAt(1));
28374|    
28375|    // CRITICAL FIX v40.42: Enemy pawn attack positions
28376|    // Black pawns (attacking white pieces) are on HIGHER ranks and attack DOWN
28377|    // White pawns (attacking black pieces) are on LOWER ranks and attack UP
28378|    // So for WHITE pieces, enemy black pawns are on rank+1
28379|    // For BLACK pieces, enemy white pawns are on rank-1
28380|    const enemyPawnRank = isWhite ? rank + 1 : rank - 1;
28381|    
28382|    if (enemyPawnRank < 1 || enemyPawnRank > 8) return attackers;
28383|    
28384|    // Check left diagonal
28385|    if (file > 0) {
28386|        const leftSquare = String.fromCharCode('a'.charCodeAt(0) + file - 1) + enemyPawnRank;
28387|        const leftPiece = board.get(leftSquare);
28388|        if (leftPiece && leftPiece.toLowerCase() === 'p') {
28389|            const pieceIsWhite = leftPiece === leftPiece.toUpperCase();
28390|            if (pieceIsWhite !== isWhite) {
28391|                attackers.push(leftSquare);
28392|            }
28393|        }
28394|    }
28395|    
28396|    // Check right diagonal
28397|    if (file < 7) {
28398|        const rightSquare = String.fromCharCode('a'.charCodeAt(0) + file + 1) + enemyPawnRank;
28399|        const rightPiece = board.get(rightSquare);
28400|        if (rightPiece && rightPiece.toLowerCase() === 'p') {
28401|            const pieceIsWhite = rightPiece === rightPiece.toUpperCase();
28402|            if (pieceIsWhite !== isWhite) {
28403|                attackers.push(rightSquare);
28404|            }
28405|        }
28406|    }
28407|    
28408|    return attackers;
28409|}
28410|
28411|/**
28412| * v40.41 Helper: Check if a square is under pawn attack
28413| */
28414|function v40IsSquareUnderPawnAttack(board, square, activeColor) {
28415|    const attackers = v40GetPawnAttackers(board, square, activeColor);
28416|    return attackers.length > 0;
28417|}
28418|
28419|/**
28420| * v40.41: POST-CAPTURE PAWN POSITION EVALUATION
