Now I'll add the new v40.1 enhanced functions after the helper functions section:
Action: file_editor str_replace /app/Lichess Bot-AlphaZero-Pure.user.js --old-str "function countTotalMaterial(board) {
    const values = { 'p': 1, 'n': 3, 'b': 3, 'r': 5, 'q': 9, 'k': 0 };
    let total = 0;
    for (const [square, piece] of board) {
        if (piece) total += values[piece.toLowerCase()] || 0;
    }
    return total;
}

function evaluatePawnShield(board, color, kingSquare) {" --new-str "function countTotalMaterial(board) {
    const values = { 'p': 1, 'n': 3, 'b': 3, 'r': 5, 'q': 9, 'k': 0 };
    let total = 0;
    for (const [square, piece] of board) {
        if (piece) total += values[piece.toLowerCase()] || 0;
    }
    return total;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// v40.1.0: ENHANCED SUPERHUMAN EVALUATION FUNCTIONS
// Critical fixes for the game loss analysis:
// - Ra1# mating net blindness â†’ Deep mating net detection
// - c-file invasion blindness â†’ File control evaluation  
// - Qd1-Qd3-Qe4-Qd3 disaster â†’ Queen movement penalty
// - Initiative collapse â†’ Deep initiative tracking
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Track queen moves for penalty calculation
let v40QueenMoveHistory = [];
let v40LastQueenMoveNumber = 0;

/**
 * v40.1: DEEP MATING NET DETECTION
 * Prevents disasters like the Ra1# finish in the lost game
 * Scans for king cornering patterns and back rank vulnerabilities
 */
function v40DeepMatingNetDetection(fen, move, board, activeColor) {
    let penalty = 0;
    const enemyColor = activeColor === 'w' ? 'b' : 'w';
    
    try {
        // Simulate the move
        const simBoard = new Map(board);
        const fromSquare = move.substring(0, 2);
        const toSquare = move.substring(2, 4);
        const movingPiece = board.get(fromSquare);
        
        if (movingPiece) {
            simBoard.delete(fromSquare);
            simBoard.set(toSquare, movingPiece);
        }
        
        // Find our king position after move
        const ourKing = findKing(simBoard, activeColor);
        if (!ourKing) return 0;
        
        const kingFile = ourKing.charCodeAt(0) - 'a'.charCodeAt(0);
        const kingRank = parseInt(ourKing[1]) - 1;
        
        // CHECK 1: King cornered (a1, h1, a8, h8 areas)
        const isCornerArea = (kingFile <= 1 || kingFile >= 6) && (kingRank <= 1 || kingRank >= 6);
        if (isCornerArea) {
            penalty -= 500;  // King in corner area is dangerous
            debugLog(\"[V40_MATING_NET]\", `âš ï¸ King in corner area ${ourKing}`);
        }
        
        // CHECK 2: Back rank vulnerability (king on 1st/8th with blocked escape)
        const backRank = activeColor === 'w' ? 0 : 7;
        if (kingRank === backRank) {
            // Count escape squares
            let escapeSquares = 0;
            for (let f = Math.max(0, kingFile - 1); f <= Math.min(7, kingFile + 1); f++) {
                const escapeRank = activeColor === 'w' ? 1 : 6;
                const escapeSquare = String.fromCharCode(f + 97) + (escapeRank + 1);
                const pieceOnEscape = simBoard.get(escapeSquare);
                
                // Check if escape square is blocked by our own pieces
                if (!pieceOnEscape) {
                    escapeSquares++;
                } else {
                    const isOurPiece = (pieceOnEscape === pieceOnEscape.toUpperCase()) === (activeColor === 'w');
                    if (!isOurPiece) escapeSquares++; // Enemy piece can be captured
                }
            }
            
            if (escapeSquares === 0) {
                penalty -= 2000;  // SEVERE: No escape, back rank mate possible
                debugLog(\"[V40_MATING_NET]\", `ğŸš¨ BACK RANK VULNERABLE - no escape squares!`);
            } else if (escapeSquares === 1) {
                penalty -= 800;  // Limited escape
                debugLog(\"[V40_MATING_NET]\", `âš ï¸ Only 1 escape square from back rank`);
            }
        }
        
        // CHECK 3: Enemy rooks/queen on critical files near our king
        for (const [square, piece] of simBoard) {
            if (!piece) continue;
            const isEnemy = (piece === piece.toUpperCase()) === (enemyColor === 'w');
            if (!isEnemy) continue;
            
            const pieceType = piece.toLowerCase();
            if (pieceType === 'r' || pieceType === 'q') {
                const pieceFile = square.charCodeAt(0) - 'a'.charCodeAt(0);
                const pieceRank = parseInt(square[1]) - 1;
                
                // Enemy rook/queen on same file as our king
                if (pieceFile === kingFile) {
                    penalty -= 400;
                    debugLog(\"[V40_MATING_NET]\", `âš ï¸ Enemy ${pieceType} on king's file`);
                }
                
                // Enemy rook/queen on 2nd/7th rank (infiltration)
                const infiltrationRank = activeColor === 'w' ? 1 : 6;
                if (pieceRank === infiltrationRank) {
                    penalty -= 600;
                    debugLog(\"[V40_MATING_NET]\", `ğŸš¨ Enemy ${pieceType} infiltrated to ${infiltrationRank + 1} rank!`);
                }
                
                // Double rooks on a file = SEVERE danger
                if (pieceType === 'r') {
                    for (const [sq2, p2] of simBoard) {
                        if (sq2 === square) continue;
                        if (p2 && p2.toLowerCase() === 'r') {
                            const isEnemy2 = (p2 === p2.toUpperCase()) === (enemyColor === 'w');
                            if (isEnemy2) {
                                const file2 = sq2.charCodeAt(0) - 'a'.charCodeAt(0);
                                if (file2 === pieceFile) {
                                    penalty -= 1000;
                                    debugLog(\"[V40_MATING_NET]\", `ğŸš¨ğŸš¨ Enemy doubled rooks on file ${String.fromCharCode(pieceFile + 97)}!`);
                                }
                            }
                        }
                    }
                }
            }
        }
        
        // CHECK 4: SPECIFIC MATING PATTERN: Rook + King coordination
        // Looking for patterns like Ra2+, Ra1# that happened in the game
        const enemyRooks = [];
        const enemyQueen = [];
        for (const [square, piece] of simBoard) {
            if (!piece) continue;
            const isEnemy = (piece === piece.toUpperCase()) === (enemyColor === 'w');
            if (isEnemy && piece.toLowerCase() === 'r') {
                enemyRooks.push(square);
            }
            if (isEnemy && piece.toLowerCase() === 'q') {
                enemyQueen.push(square);
            }
        }
        
        // If enemy has rook(s) on files adjacent to our cornered king, SEVERE penalty
        if (isCornerArea && enemyRooks.length > 0) {
            for (const rookSq of enemyRooks) {
                const rookFile = rookSq.charCodeAt(0) - 'a'.charCodeAt(0);
                if (Math.abs(rookFile - kingFile) <= 1) {
                    penalty -= 1500;
                    debugLog(\"[V40_MATING_NET]\", `ğŸš¨ğŸš¨ğŸš¨ MATING NET FORMING: Rook ${rookSq} near cornered king!`);
                }
            }
        }
        
    } catch (e) {
        debugLog(\"[V40_MATING_NET]\", `Error: ${e.message}`);
    }
    
    return penalty;
}

/**
 * v40.1: FILE CONTROL EVALUATION
 * Prevents blindness to dangerous file invasions like the c-file in the lost game
 * Evaluates open file control and file invasion threats
 */
function v40FileControlEvaluation(fen, move, board, activeColor) {
    let score = 0;
    const enemyColor = activeColor === 'w' ? 'b' : 'w';
    
    try {
        // Simulate the move
        const simBoard = new Map(board);
        const fromSquare = move.substring(0, 2);
        const toSquare = move.substring(2, 4);
        const movingPiece = board.get(fromSquare);
        
        if (movingPiece) {
            simBoard.delete(fromSquare);
            simBoard.set(toSquare, movingPiece);
        }
        
        // Analyze each file (a-h)
        for (let fileIdx = 0; fileIdx < 8; fileIdx++) {
            const fileLetter = String.fromCharCode(97 + fileIdx);
            
            // Count pieces on this file
            let ourRooks = 0;
            let enemyRooks = 0;
            let ourPawns = 0;
            let enemyPawns = 0;
            let ourQueen = 0;
            let enemyQueen = 0;
            
            for (let rank = 1; rank <= 8; rank++) {
                const square = fileLetter + rank;
                const piece = simBoard.get(square);
                if (!piece) continue;
                
                const isOurs = (piece === piece.toUpperCase()) === (activeColor === 'w');
                const pieceType = piece.toLowerCase();
                
                if (isOurs) {
                    if (pieceType === 'r') ourRooks++;
                    if (pieceType === 'p') ourPawns++;
                    if (pieceType === 'q') ourQueen++;
                } else {
                    if (pieceType === 'r') enemyRooks++;
                    if (pieceType === 'p') enemyPawns++;
                    if (pieceType === 'q') enemyQueen++;
                }
            }
            
            // Open file (no pawns)
            const isOpenFile = ourPawns === 0 && enemyPawns === 0;
            // Semi-open for us (no enemy pawns, we have pawns)
            const isSemiOpenForUs = enemyPawns === 0 && ourPawns > 0;
            // Semi-open for enemy
            const isSemiOpenForEnemy = ourPawns === 0 && enemyPawns > 0;
            
            if (isOpenFile || isSemiOpenForEnemy) {
                // Enemy controls open file = DANGER
                if (enemyRooks >= 2) {
                    score -= 800;  // Doubled rooks on open file
                    debugLog(\"[V40_FILE]\", `ğŸš¨ Enemy doubled rooks on open ${fileLetter}-file!`);
                } else if (enemyRooks === 1 && ourRooks === 0) {
                    score -= 400;  // Enemy rook controls file we don't contest
                    debugLog(\"[V40_FILE]\", `âš ï¸ Enemy rook controls ${fileLetter}-file uncontested`);
                }
                
                // Enemy queen on open file
                if (enemyQueen > 0 && isOpenFile) {
                    score -= 300;
                }
                
                // We should contest open files
                if (ourRooks > 0 && enemyRooks > 0) {
                    score += 100;  // At least we're contesting
                }
                if (ourRooks >= 2 && enemyRooks === 0) {
                    score += 500;  // We control the file
                }
            }
            
            // Check if move puts our rook on open file
            if (movingPiece && movingPiece.toLowerCase() === 'r') {
                const targetFile = toSquare[0];
                if (targetFile === fileLetter && isOpenFile) {
                    score += 400;  // Good move - rook to open file
                    debugLog(\"[V40_FILE]\", `âœ… Rook to open ${fileLetter}-file`);
                }
            }
        }
        
        // Find our king and check for dangerous files nearby
        const ourKing = findKing(simBoard, activeColor);
        if (ourKing) {
            const kingFile = ourKing.charCodeAt(0) - 'a'.charCodeAt(0);
            
            // Check files adjacent to king
            for (let f = Math.max(0, kingFile - 1); f <= Math.min(7, kingFile + 1); f++) {
                const fileLetter = String.fromCharCode(97 + f);
                
                let enemyRooksOnFile = 0;
                for (let rank = 1; rank <= 8; rank++) {
                    const square = fileLetter + rank;
                    const piece = simBoard.get(square);
                    if (piece) {
                        const isEnemy = (piece === piece.toUpperCase()) === (enemyColor === 'w');
                        if (isEnemy && (piece.toLowerCase() === 'r' || piece.toLowerCase() === 'q')) {
                            enemyRooksOnFile++;
                        }
                    }
                }
                
                if (enemyRooksOnFile > 0) {
                    score -= 300 * enemyRooksOnFile;  // Danger near king
                    debugLog(\"[V40_FILE]\", `âš ï¸ Enemy heavy piece on ${fileLetter}-file near king`);
                }
            }
        }
        
    } catch (e) {
        debugLog(\"[V40_FILE]\", `Error: ${e.message}`);
    }
    
    return score;
}

/**
 * v40.1: DEEP INITIATIVE TRACKING
 * Prevents initiative collapse like Qd1-Qd3-Qe4-Qd3 sequence
 * Tracks tempo, development lead, and forcing move availability
 */
function v40DeepInitiativeTracking(fen, move, board, activeColor, moveNumber) {
    let score = 0;
    
    try {
        const fromSquare = move.substring(0, 2);
        const toSquare = move.substring(2, 4);
        const movingPiece = board.get(fromSquare);
        
        if (!movingPiece) return 0;
        
        // CHECK 1: Is this a forcing move? (captures, checks, threats)
        const isCapture = board.has(toSquare) && board.get(toSquare);
        const isCheck = move.includes('+') || move.includes('#');
        const createsThreat = detectsThreatsAfterMove(move, board, activeColor);
        
        if (isCapture || isCheck) {
            score += 300;  // Forcing moves maintain initiative
        } else if (createsThreat) {
            score += 200;  // Threat creation maintains initiative
        }
        
        // CHECK 2: Retreat penalty (piece moving backward without good reason)
        const fromRank = parseInt(fromSquare[1]);
        const toRank = parseInt(toSquare[1]);
        
        const isWhite = activeColor === 'w';
        const isRetreat = isWhite ? (toRank < fromRank) : (toRank > fromRank);
        
        if (isRetreat && !isCapture && !createsThreat) {
            score -= 400;  // Retreating without purpose loses tempo
            debugLog(\"[V40_INIT]\", `âš ï¸ Retreating ${movingPiece} from ${fromSquare} to ${toSquare}`);
        }
        
        // CHECK 3: Development lead evaluation
        if (moveNumber <= 15) {
            const devScore = evaluateDevelopmentLead(board, activeColor);
            score += devScore * 2;
        }
        
        // CHECK 4: Same piece moving multiple times early (tempo loss)
        if (moveNumber <= 12) {
            const pieceType = movingPiece.toLowerCase();
            
            // Track piece origin squares for repeated moves
            if (!v40StrategicState.pieceMoveCounts) {
                v40StrategicState.pieceMoveCounts = new Map();
            }
            
            const count = v40StrategicState.pieceMoveCounts.get(fromSquare) || 0;
            if (count > 0) {
                score -= 200 * count;  // Penalty for moving same piece again
                debugLog(\"[V40_INIT]\", `âš ï¸ Same piece moved ${count + 1} times in opening`);
            }
        }
        
        // CHECK 5: Passive vs Active - moves that don't improve position
        if (!isCapture && !isCheck && !createsThreat) {
            // Is this a passive defensive move?
            if (isDefensiveMove(move, board, activeColor)) {
                score -= 200;
            }
            
            // Does this improve piece activity?
            if (improvesPieceActivity(move, board, activeColor)) {
                score += 200;
            }
        }
        
    } catch (e) {
        debugLog(\"[V40_INIT]\", `Error: ${e.message}`);
    }
    
    return score;
}

/**
 * v40.1: QUEEN MOVEMENT PENALTY
 * Prevents disasters like Qd1-Qd3-Qe4-Qd3 sequence (4 queen moves in first 10 moves)
 * Heavy penalty for excessive queen movement in opening/early middlegame
 */
function v40QueenMovementPenalty(fen, move, board, activeColor, moveNumber) {
    let penalty = 0;
    
    try {
        const fromSquare = move.substring(0, 2);
        const movingPiece = board.get(fromSquare);
        
        if (!movingPiece) return 0;
        
        const isQueen = movingPiece.toLowerCase() === 'q';
        
        if (isQueen && moveNumber <= 20) {
            // Track queen moves
            if (moveNumber > v40LastQueenMoveNumber) {
                v40QueenMoveHistory.push(moveNumber);
                v40LastQueenMoveNumber = moveNumber;
            }
            
            // Count queen moves in the game so far
            const queenMoves = v40QueenMoveHistory.length;
            
            if (moveNumber <= 10) {
                // Opening: Heavy penalty for queen moves
                if (queenMoves >= 1) {
                    penalty -= 300;  // First queen move
                    debugLog(\"[V40_QUEEN]\", `âš ï¸ Queen move #${queenMoves} in opening`);
                }
                if (queenMoves >= 2) {
                    penalty -= 600;  // Second queen move
                    debugLog(\"[V40_QUEEN]\", `ğŸš¨ Second queen move in opening!`);
                }
                if (queenMoves >= 3) {
                    penalty -= 1500;  // Three queen moves = disaster
                    debugLog(\"[V40_QUEEN]\", `ğŸš¨ğŸš¨ THREE queen moves in opening - losing tempo!`);
                }
                if (queenMoves >= 4) {
                    penalty -= 3000;  // Four+ queen moves = catastrophic
                    debugLog(\"[V40_QUEEN]\", `ğŸš¨ğŸš¨ğŸš¨ FOUR+ queen moves - initiative destroyed!`);
                }
            } else if (moveNumber <= 20) {
                // Early middlegame: moderate penalty
                if (queenMoves >= 4) {
                    penalty -= 500;
                }
                if (queenMoves >= 6) {
                    penalty -= 1000;
                }
            }
            
            // Check if queen is being pushed around (retreating)
            const toSquare = move.substring(2, 4);
            const fromRank = parseInt(fromSquare[1]);
            const toRank = parseInt(toSquare[1]);
            const isWhite = activeColor === 'w';
            const isRetreat = isWhite ? (toRank < fromRank) : (toRank > fromRank);
            
            if (isRetreat) {
                penalty -= 400;  // Queen retreat is especially bad
                debugLog(\"[V40_QUEEN]\", `âš ï¸ Queen retreating from ${fromSquare} to ${toSquare}`);
            }
            
            // Queen early development penalty (before minor pieces)
            if (moveNumber <= 8) {
                const minorsDeveloped = countDevelopedMinorPieces(board, activeColor);
                if (minorsDeveloped < 3) {
                    penalty -= 500;
                    debugLog(\"[V40_QUEEN]\", `âš ï¸ Queen out before minor pieces developed`);
                }
            }
        }
        
    } catch (e) {
        debugLog(\"[V40_QUEEN]\", `Error: ${e.message}`);
    }
    
    return penalty;
}

/**
 * v40.1: Helper - Count developed minor pieces
 */
function countDevelopedMinorPieces(board, color) {
    let count = 0;
    const knightChar = color === 'w' ? 'N' : 'n';
    const bishopChar = color === 'w' ? 'B' : 'b';
    const startRank = color === 'w' ? '1' : '8';
    
    for (const [square, piece] of board) {
        if (piece === knightChar || piece === bishopChar) {
            // Check if NOT on starting rank
            if (square[1] !== startRank) {
                count++;
            }
        }
    }
    
    return count;
}

/**
 * v40.1: Helper - Detect threats after move
 */
function detectsThreatsAfterMove(move, board, activeColor) {
    // Simplified threat detection
    const toSquare = move.substring(2, 4);
    const toFile = toSquare.charCodeAt(0) - 'a'.charCodeAt(0);
    const toRank = parseInt(toSquare[1]) - 1;
    
    // Check if move attacks enemy pieces
    const enemyColor = activeColor === 'w' ? 'b' : 'w';
    
    for (const [square, piece] of board) {
        if (!piece) continue;
        const isEnemy = (piece === piece.toUpperCase()) === (enemyColor === 'w');
        if (!isEnemy) continue;
        
        const sqFile = square.charCodeAt(0) - 'a'.charCodeAt(0);
        const sqRank = parseInt(square[1]) - 1;
        
        // Simple proximity check (within 2 squares)
        if (Math.abs(sqFile - toFile) <= 2 && Math.abs(sqRank - toRank) <= 2) {
            return true;
        }
    }
    
    return false;
}

/**
 * v40.1: Helper - Evaluate development lead
 */
function evaluateDevelopmentLead(board, color) {
    let ourDev = countDevelopedMinorPieces(board, color);
    let enemyDev = countDevelopedMinorPieces(board, color === 'w' ? 'b' : 'w');
    return (ourDev - enemyDev) * 50;
}

/**
 * v40.1: Helper - Check if move is defensive
 */
function isDefensiveMove(move, board, activeColor) {
    const toSquare = move.substring(2, 4);
    const toRank = parseInt(toSquare[1]);
    const isWhite = activeColor === 'w';
    
    // Moves to 1st/2nd rank for white or 7th/8th rank for black are defensive
    if (isWhite && toRank <= 2) return true;
    if (!isWhite && toRank >= 7) return true;
    
    return false;
}

/**
 * v40.1: Helper - Check if move improves piece activity
 */
function improvesPieceActivity(move, board, activeColor) {
    const toSquare = move.substring(2, 4);
    const toFile = toSquare.charCodeAt(0) - 'a'.charCodeAt(0);
    const toRank = parseInt(toSquare[1]) - 1;
    
    // Central squares are active
    if (toFile >= 2 && toFile <= 5 && toRank >= 2 && toRank <= 5) {
        return true;
    }
    
    return false;
}

function evaluatePawnShield(board, color, kingSquare) {"
Observation: Edit was successful.