Now let me add the v40.45 functions after v40BishopB5HangingEval:
Action: file_editor str_replace /app/Lichess Bot-AlphaZero-Pure.user.js --old-str "        
        debugLog(\"[V40.44_BISHOP]\", `â˜ ï¸ BISHOP on ${sq} UNDER PAWN ATTACK! Move ${move} doesn't address it!`);
        score += CONFIG.v40BishopB5HangingPenalty || -900000000000000;
    }
    
    return score;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function findAttackedPiecesV40_9(board, color) {" --new-str "        
        debugLog(\"[V40.44_BISHOP]\", `â˜ ï¸ BISHOP on ${sq} UNDER PAWN ATTACK! Move ${move} doesn't address it!`);
        score += CONFIG.v40BishopB5HangingPenalty || -900000000000000;
    }
    
    return score;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// v40.45: ABSOLUTE MOVE FILTER SUPREME - THE ULTIMATE FIX!
// This is a HARD FILTER that REJECTS moves, not just penalizes them!
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/**
 * v40.45: ABSOLUTE MOVE FILTER - Returns true if move should be REJECTED
 * This is called BEFORE regular evaluation to filter out catastrophic moves!
 */
function v40AbsoluteMoveFilter(fen, move, board, activeColor, moveNumber) {
    if (!CONFIG.v40AbsoluteMoveFilterEnabled) return false;
    
    // RULE 1: If we have a piece under pawn attack, we MUST respond
    const piecesUnderPawnAttack = v40FindPiecesUnderPawnAttack(board, activeColor);
    
    if (piecesUnderPawnAttack.length > 0) {
        const fromSquare = move.substring(0, 2);
        const toSquare = move.substring(2, 4);
        let addressesThreat = false;
        
        for (const attacked of piecesUnderPawnAttack) {
            // Moving the attacked piece
            if (fromSquare === attacked.square) {
                addressesThreat = true;
                break;
            }
            
            // Capturing an attacker
            if (attacked.attackers.includes(toSquare)) {
                addressesThreat = true;
                break;
            }
        }
        
        if (!addressesThreat && piecesUnderPawnAttack[0].pieceValue >= 300) {
            debugLog(\"[V40.45_FILTER]\", `ğŸš« MOVE ${move} REJECTED! Piece ${piecesUnderPawnAttack[0].pieceType}@${piecesUnderPawnAttack[0].square} under pawn attack!`);
            return true;  // REJECT this move!
        }
    }
    
    // RULE 2: If enemy pawn just captured a central pawn, we MUST recapture
    const isWhite = activeColor === 'w';
    const centralSquares = isWhite ? ['d4', 'e4'] : ['d5', 'e5'];
    const toSquare = move.substring(2, 4);
    
    for (const centralSq of centralSquares) {
        const piece = board.get(centralSq);
        if (!piece || piece.toLowerCase() !== 'p') continue;
        
        const pieceIsWhite = piece === piece.toUpperCase();
        if (pieceIsWhite === isWhite) continue;  // Enemy pawn on our central square
        
        // Can we recapture?
        if (canPieceCapture(board, centralSq, activeColor)) {
            // We CAN recapture, so we MUST recapture!
            if (toSquare !== centralSq) {
                // This move doesn't recapture - but only reject if it's first 10 moves
                if (moveNumber <= 10 && CONFIG.v40MustRecaptureModeEnabled) {
                    debugLog(\"[V40.45_FILTER]\", `ğŸš« MOVE ${move} REJECTED! Enemy pawn on ${centralSq} - MUST recapture!`);
                    return true;  // REJECT this move!
                }
            }
        }
    }
    
    // RULE 3: Don't push pawns when pieces are hanging
    const fromSquare = move.substring(0, 2);
    const movingPiece = board.get(fromSquare);
    
    if (movingPiece && movingPiece.toLowerCase() === 'p') {
        const hangingPieces = findHangingPiecesV40_9(board, activeColor);
        if (hangingPieces.length > 0 && hangingPieces[0].value >= 300) {
            debugLog(\"[V40.45_FILTER]\", `ğŸš« PAWN PUSH ${move} REJECTED! ${hangingPieces[0].piece}@${hangingPieces[0].square} is hanging!`);
            return true;  // REJECT this move!
        }
    }
    
    // RULE 4: E5 push prohibition in Sicilian-type positions
    if (CONFIG.v40E5PushProhibitionEnabled && moveNumber <= 10) {
        if (isWhite && move === 'e4e5') {
            // Check if we have pieces that could be endangered
            const attackedPieces = findAttackedPiecesV40_9(board, activeColor);
            if (attackedPieces.length > 0) {
                debugLog(\"[V40.45_FILTER]\", `ğŸš« E5 PUSH ${move} REJECTED! Pieces under attack!`);
                return true;
            }
        }
    }
    
    return false;  // Move is OK, don't reject
}

/**
 * v40.45: SICILIAN RESPONSE EVALUATION
 * Special handling for Sicilian Defense positions
 */
function v40SicilianResponseEval(fen, move, board, activeColor, moveNumber) {
    if (!CONFIG.v40SicilianDefenseEnabled) return 0;
    if (moveNumber > 15) return 0;
    
    let score = 0;
    const isWhite = activeColor === 'w';
    const fromSquare = move.substring(0, 2);
    const toSquare = move.substring(2, 4);
    
    // Detect if this is a Sicilian position (Black played c5 early)
    // We can detect this by seeing if there's been a pawn exchange on d4
    
    // After d4 cxd4, white MUST play Nxd4 or Qxd4 (capture back!)
    if (isWhite) {
        const d4Piece = board.get('d4');
        
        if (d4Piece && d4Piece.toLowerCase() === 'p') {
            const d4IsWhite = d4Piece === d4Piece.toUpperCase();
            
            if (!d4IsWhite) {
                // There's a BLACK pawn on d4 - this means cxd4 happened!
                // We MUST recapture!
                
                if (toSquare === 'd4') {
                    // We ARE recapturing - good!
                    debugLog(\"[V40.45_SICILIAN]\", `âœ… Recapturing d4 pawn with ${move} - GOOD!`);
                    score += 5000000000000000;  // MASSIVE bonus for recapturing
                } else {
                    // We're NOT recapturing - BAD!
                    debugLog(\"[V40.45_SICILIAN]\", `â˜ ï¸â˜ ï¸ NOT recapturing d4 pawn! Move ${move} - CATASTROPHIC!`);
                    score += CONFIG.v40E5PushPenalty || -5000000000000000;
                }
            }
        }
    }
    
    return score;
}

/**
 * v40.45: OPENING BOOK EVALUATION
 * Reward known good moves, penalize known bad moves
 */
function v40OpeningBookEval(fen, move, board, activeColor, moveNumber) {
    if (!CONFIG.v40CriticalOpeningBookEnabled) return 0;
    if (moveNumber > CONFIG.v40OpeningBookDepth) return 0;
    
    let score = 0;
    const isWhite = activeColor === 'w';
    
    // KNOWN BAD MOVES IN OPENINGS:
    const badMoves = {
        // Sicilian: After d4 cxd4, playing e5 instead of recapturing
        // We detect this by checking if there's a black pawn on d4
        'e4e5': {
            condition: () => {
                const d4 = board.get('d4');
                return d4 && d4.toLowerCase() === 'p' && d4 !== d4.toUpperCase();
            },
            penalty: -5000000000000000,
            reason: 'e5 when d4 pawn needs recapture'
        },
        // Moving knight away when it should recapture
        'c3e2': {
            condition: () => {
                const d4 = board.get('d4');
                return d4 && d4.toLowerCase() === 'p' && d4 !== d4.toUpperCase();
            },
            penalty: -3000000000000000,
            reason: 'Ne2 retreat when Nxd4 needed'
        },
        'f3e5': {
            condition: () => {
                const d4 = board.get('d4');
                return d4 && d4.toLowerCase() === 'p' && d4 !== d4.toUpperCase();
            },
            penalty: -2000000000000000,
            reason: 'Ne5 when Nxd4 needed'
        }
    };
    
    if (badMoves[move] && badMoves[move].condition()) {
        debugLog(\"[V40.45_BOOK]\", `â˜ ï¸ BAD OPENING MOVE: ${move} - ${badMoves[move].reason}`);
        score += badMoves[move].penalty;
    }
    
    // GOOD RECAPTURE MOVES:
    if (move === 'c3d4' || move === 'd1d4' || move === 'f3d4') {
        const d4 = board.get('d4');
        if (d4 && d4.toLowerCase() === 'p' && d4 !== d4.toUpperCase()) {
            debugLog(\"[V40.45_BOOK]\", `âœ… GOOD RECAPTURE: ${move}`);
            score += 3000000000000000;  // Bonus for recapturing
        }
    }
    
    return score;
}

/**
 * v40.45: ABSOLUTE PIECE SAFETY CHECK
 * This runs AFTER all other evaluations as a final safety check
 */
function v40AbsolutePieceSafetyCheck(fen, move, board, activeColor, moveNumber) {
    let score = 0;
    const isWhite = activeColor === 'w';
    
    // Simulate the move
    const testBoard = simulateMove(board, move);
    if (!testBoard) return 0;
    
    // After our move, check if ANY of our valuable pieces are under attack
    for (const [square, piece] of testBoard) {
        if (!piece) continue;
        const pieceIsWhite = piece === piece.toUpperCase();
        if (pieceIsWhite !== isWhite) continue;  // Only our pieces
        
        const pieceType = piece.toLowerCase();
        if (pieceType === 'p' || pieceType === 'k') continue;
        
        const pieceValue = getPieceValueSimple(pieceType);
        
        // Is this piece under attack after our move?
        const enemyColor = isWhite ? 'b' : 'w';
        
        if (isSquareAttackedByColor(testBoard, square, enemyColor)) {
            // Check if it's defended
            const isDefended = isSquareDefendedByColor(testBoard, square, activeColor);
            
            if (!isDefended) {
                // Piece is HANGING after our move!
                debugLog(\"[V40.45_SAFETY]\", `â˜ ï¸â˜ ï¸ AFTER ${move}, ${pieceType}@${square} is HANGING!`);
                score += -(pieceValue * 1000000000000);  // Massive penalty
            }
        }
    }
    
    return score;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function findAttackedPiecesV40_9(board, color) {"
Observation: Edit was successful.