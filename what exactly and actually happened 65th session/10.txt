
Action: file_editor view /app/Lichess Bot-AlphaZero-Pure.user.js
Observation: /app/Lichess Bot-AlphaZero-Pure.user.js:
29010|        
29011|        debugLog("[V40.44_BISHOP]", `☠️ BISHOP on ${sq} UNDER PAWN ATTACK! Move ${move} doesn't address it!`);
29012|        score += CONFIG.v40BishopB5HangingPenalty || -900000000000000;
29013|    }
29014|    
29015|    return score;
29016|}
29017|
29018|// ═══════════════════════════════════════════════════════════════════════════════
29019|function findAttackedPiecesV40_9(board, color) {
29020|    const attacked = [];
29021|    const isWhite = color === 'w';
29022|    const enemyColor = isWhite ? 'b' : 'w';
29023|    
29024|    for (const [square, piece] of board) {
29025|        if (!piece) continue;
29026|        const pieceIsWhite = piece === piece.toUpperCase();
29027|        if (pieceIsWhite !== isWhite) continue;
29028|        
29029|        const pieceType = piece.toLowerCase();
29030|        if (pieceType === 'k') continue;  // King attacks handled separately
29031|        
29032|        // Check if this square is attacked by enemy
29033|        if (isSquareAttackedByColor(board, square, enemyColor)) {
29034|            // Check if it's adequately defended
29035|            const isDefended = isSquareDefendedByColor(board, square, color);
29036|            
29037|            // If attacked by something of lower value, still need to consider
29038|            const attackers = findAttackersOfSquare(board, square, enemyColor);
29039|            const lowestAttackerValue = Math.min(...attackers.map(a => getPieceValueSimple(a.piece.toLowerCase())));
29040|            const ourPieceValue = getPieceValueSimple(pieceType);
29041|            
29042|            // Consider it under attack if:
29043|            // 1. Not defended at all, or
29044|            // 2. Attacker is of lower value than our piece
29045|            if (!isDefended || lowestAttackerValue < ourPieceValue) {
29046|                attacked.push({
29047|                    square,
29048|                    piece,
29049|                    value: ourPieceValue,
29050|                    lowestAttackerValue
29051|                });
29052|            }
29053|        }
29054|    }
29055|    
29056|    // Sort by piece value (highest first - queen, then rook, etc.)
29057|    attacked.sort((a, b) => b.value - a.value);
29058|    
29059|    return attacked;
29060|}
29061|
29062|/**
29063| * v40.9 Helper: Find all hanging pieces (attacked and not defended)
29064| */
29065|function findHangingPiecesV40_9(board, color) {
29066|    const hanging = [];
29067|    const isWhite = color === 'w';
29068|    const enemyColor = isWhite ? 'b' : 'w';
29069|    
29070|    for (const [square, piece] of board) {
29071|        if (!piece) continue;
29072|        const pieceIsWhite = piece === piece.toUpperCase();
29073|        if (pieceIsWhite !== isWhite) continue;
29074|        
29075|        const pieceType = piece.toLowerCase();
29076|        if (pieceType === 'k') continue;
29077|        
29078|        const isAttacked = isSquareAttackedByColor(board, square, enemyColor);
29079|        const isDefended = isSquareDefendedByColor(board, square, color);
29080|        
