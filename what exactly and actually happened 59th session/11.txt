Now let me add the v40.39 functions after canBishopReach:
Action: file_editor str_replace /app/Lichess Bot-AlphaZero-Pure.user.js --old-str "        const square = String.fromCharCode('a'.charCodeAt(0) + file) + rank;
        if (board.get(square)) return false;  // Blocked
        file += fileDir;
        rank += rankDir;
    }
    
    return true;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function findAttackedPiecesV40_9(board, color) {" --new-str "        const square = String.fromCharCode('a'.charCodeAt(0) + file) + rank;
        if (board.get(square)) return false;  // Blocked
        file += fileDir;
        rank += rankDir;
    }
    
    return true;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// v40.39: PAWN CAPTURE CHAIN SUPREME - THE ULTIMATE TACTICAL FIX
// From game: After cxd4, White played e5 instead of recapturing!
// Then dxc3 attacked Bb5 AND threatened cxb2 promotion!
// THE BOT MUST SEE PAWN ATTACK CHAINS AND RESPOND TO PIECE ATTACKS!
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/**
 * v40.39: PAWN CAPTURE CHAIN DETECTION
 * Detects when enemy pawn captures can lead to devastating capture chains
 * Example: cxd4, then dxc3 attacks knight AND threatens b2
 */
function v40PawnCaptureChainEval(fen, move, board, activeColor, moveNumber) {
    if (!CONFIG.v40PawnCaptureChainEnabled) return 0;
    
    let score = 0;
    const isWhite = activeColor === 'w';
    const enemyColor = isWhite ? 'b' : 'w';
    
    // After we make our move, simulate the position
    const testBoard = simulateMove(board, move);
    if (!testBoard) return 0;
    
    // Find all enemy pawns
    for (const [square, piece] of testBoard) {
        if (!piece) continue;
        const isPawn = piece.toLowerCase() === 'p';
        const pieceIsWhite = piece === piece.toUpperCase();
        
        // Check enemy pawns
        if (isPawn && pieceIsWhite === isWhite) continue;  // Skip our pawns
        if (!isPawn) continue;
        
        // Check if this enemy pawn can capture something
        const file = square.charCodeAt(0) - 'a'.charCodeAt(0);
        const rank = parseInt(square.charAt(1));
        
        // Enemy pawn capture directions
        const pawnDir = pieceIsWhite ? 1 : -1;  // White pawns go up, black pawns go down
        const captureSquares = [];
        
        // Left capture
        if (file > 0) {
            captureSquares.push(String.fromCharCode('a'.charCodeAt(0) + file - 1) + (rank + pawnDir));
        }
        // Right capture
        if (file < 7) {
            captureSquares.push(String.fromCharCode('a'.charCodeAt(0) + file + 1) + (rank + pawnDir));
        }
        
        for (const captureSquare of captureSquares) {
            const targetPiece = testBoard.get(captureSquare);
            if (!targetPiece) continue;
            
            const targetIsWhite = targetPiece === targetPiece.toUpperCase();
            if (targetIsWhite !== isWhite) continue;  // Enemy's own piece
            
            // Our piece can be captured by enemy pawn!
            const pieceValue = getPieceValueSimple(targetPiece.toLowerCase());
            
            if (pieceValue >= 300) {  // Knight or higher
                // Check if after this capture, the pawn creates MORE threats
                const newPawnSquare = captureSquare;
                const newPawnFile = newPawnSquare.charCodeAt(0) - 'a'.charCodeAt(0);
                const newPawnRank = parseInt(newPawnSquare.charAt(1));
                
                // Check next capture squares for the pawn after it captures
                const nextCaptures = [];
                if (newPawnFile > 0) {
                    nextCaptures.push(String.fromCharCode('a'.charCodeAt(0) + newPawnFile - 1) + (newPawnRank + pawnDir));
                }
                if (newPawnFile < 7) {
                    nextCaptures.push(String.fromCharCode('a'.charCodeAt(0) + newPawnFile + 1) + (newPawnRank + pawnDir));
                }
                
                let chainThreat = false;
                for (const nextSquare of nextCaptures) {
                    const nextTarget = testBoard.get(nextSquare);
                    if (nextTarget) {
                        const nextTargetIsWhite = nextTarget === nextTarget.toUpperCase();
                        if (nextTargetIsWhite === isWhite) {
                            // Another piece can be attacked after the first capture!
                            chainThreat = true;
                            debugLog(\"[V40.39_CHAIN]\", `â˜ ï¸ PAWN CAPTURE CHAIN: ${square}x${captureSquare} then threatens ${nextSquare}!`);
                        }
                    }
                }
                
                // Check for promotion threat
                const promotionRank = pieceIsWhite ? 8 : 1;
                if (newPawnRank === promotionRank - pawnDir) {
                    chainThreat = true;
                    debugLog(\"[V40.39_CHAIN]\", `â˜ ï¸ PAWN PROMOTION THREAT: ${square}x${captureSquare} threatens promotion!`);
                }
                
                if (chainThreat) {
                    debugLog(\"[V40.39_CHAIN]\", `ğŸ’€ğŸ’€ DEVASTATING PAWN CHAIN DETECTED after ${move}!`);
                    score += CONFIG.v40PawnCaptureChainPenalty || -250000000000000;
                }
            }
        }
    }
    
    return score;
}

/**
 * v40.39: PIECE UNDER PAWN ATTACK DETECTION
 * Must respond when a valuable piece is attacked by enemy pawn!
 * Example: If Nc3 is attacked by d4 pawn, MUST move knight or take pawn
 */
function v40PieceUnderPawnAttackEval(fen, move, board, activeColor, moveNumber) {
    if (!CONFIG.v40PieceUnderPawnAttackEnabled) return 0;
    
    let score = 0;
    const isWhite = activeColor === 'w';
    const enemyColor = isWhite ? 'b' : 'w';
    
    // Find our pieces that are currently attacked by enemy pawns
    const piecesUnderPawnAttack = [];
    
    for (const [square, piece] of board) {
        if (!piece) continue;
        const pieceIsWhite = piece === piece.toUpperCase();
        if (pieceIsWhite !== isWhite) continue;  // Only check our pieces
        
        const pieceType = piece.toLowerCase();
        if (pieceType === 'p' || pieceType === 'k') continue;  // Skip pawns and king
        
        // Check if attacked by enemy pawn
        const file = square.charCodeAt(0) - 'a'.charCodeAt(0);
        const rank = parseInt(square.charAt(1));
        
        // Enemy pawn attack squares (pawns attack diagonally)
        const enemyPawnRank = isWhite ? rank - 1 : rank + 1;
        const attackerSquares = [];
        if (file > 0) attackerSquares.push(String.fromCharCode('a'.charCodeAt(0) + file - 1) + enemyPawnRank);
        if (file < 7) attackerSquares.push(String.fromCharCode('a'.charCodeAt(0) + file + 1) + enemyPawnRank);
        
        for (const attackerSquare of attackerSquares) {
            const attacker = board.get(attackerSquare);
            if (attacker && attacker.toLowerCase() === 'p') {
                const attackerIsWhite = attacker === attacker.toUpperCase();
                if (attackerIsWhite !== isWhite) {
                    // Our piece is under pawn attack!
                    piecesUnderPawnAttack.push({
                        square,
                        piece,
                        pieceType,
                        attackerSquare,
                        value: getPieceValueSimple(pieceType)
                    });
                    break;
                }
            }
        }
    }
    
    if (piecesUnderPawnAttack.length === 0) return 0;
    
    // Check if our move addresses the pawn attack
    const fromSquare = move.substring(0, 2);
    const toSquare = move.substring(2, 4);
    
    for (const attacked of piecesUnderPawnAttack) {
        // Check if we're moving the attacked piece
        if (fromSquare === attacked.square) {
            debugLog(\"[V40.39_PAWN]\", `âœ… Moving attacked ${attacked.pieceType} from ${attacked.square}`);
            continue;  // Good - we're addressing the threat
        }
        
        // Check if we're capturing the attacking pawn
        if (toSquare === attacked.attackerSquare) {
            debugLog(\"[V40.39_PAWN]\", `âœ… Capturing attacking pawn on ${attacked.attackerSquare}`);
            continue;  // Good - we're addressing the threat
        }
        
        // Check if we're blocking the attack somehow (unlikely with pawns but check)
        
        // If we're NOT addressing the pawn attack on a valuable piece, HUGE penalty
        if (attacked.value >= 300) {  // Knight or higher
            debugLog(\"[V40.39_PAWN]\", `â˜ ï¸â˜ ï¸ IGNORING PAWN ATTACK on ${attacked.pieceType} at ${attacked.square}!`);
            debugLog(\"[V40.39_PAWN]\", `Move ${move} does NOT address the attack!`);
            score += CONFIG.v40PieceUnderPawnAttackPenalty || -200000000000000;
        }
    }
    
    return score;
}

/**
 * v40.39: PROMOTION THREAT DETECTION
 * Detect when enemy pawn is threatening to promote
 */
function v40PromotionThreatEval(fen, move, board, activeColor, moveNumber) {
    if (!CONFIG.v40PromotionThreatEnabled) return 0;
    
    let score = 0;
    const isWhite = activeColor === 'w';
    
    // After we make our move, check for promotion threats
    const testBoard = simulateMove(board, move);
    if (!testBoard) return 0;
    
    // Find enemy pawns close to promotion
    for (const [square, piece] of testBoard) {
        if (!piece || piece.toLowerCase() !== 'p') continue;
        
        const pieceIsWhite = piece === piece.toUpperCase();
        if (pieceIsWhite === isWhite) continue;  // Skip our pawns
        
        const rank = parseInt(square.charAt(1));
        const promotionRank = pieceIsWhite ? 8 : 1;
        const distanceToPromotion = pieceIsWhite ? (8 - rank) : (rank - 1);
        
        // Check if pawn is very close to promotion (2 or fewer squares away)
        if (distanceToPromotion <= 2) {
            // Check if the path is clear
            const file = square.charAt(0);
            let pathClear = true;
            const pawnDir = pieceIsWhite ? 1 : -1;
            
            for (let r = rank + pawnDir; pieceIsWhite ? r <= 8 : r >= 1; r += pawnDir) {
                const checkSquare = file + r;
                if (testBoard.get(checkSquare)) {
                    pathClear = false;
                    break;
                }
            }
            
            if (pathClear && distanceToPromotion <= 1) {
                // Pawn is about to promote!
                debugLog(\"[V40.39_PROMO]\", `â˜ ï¸â˜ ï¸ ENEMY PAWN ON ${square} IS 1 SQUARE FROM PROMOTION!`);
                score += CONFIG.v40PromotionThreatPenalty || -300000000000000;
            } else if (pathClear && distanceToPromotion === 2) {
                // Pawn is close to promotion
                debugLog(\"[V40.39_PROMO]\", `âš ï¸ Enemy pawn on ${square} is close to promotion!`);
                score += (CONFIG.v40PromotionThreatPenalty || -300000000000000) / 3;
            }
        }
    }
    
    return score;
}

/**
 * v40.39: RECAPTURE CHAIN AWARENESS
 * When we capture, see if opponent's recapture creates threats
 */
function v40RecaptureChainEval(fen, move, board, activeColor, moveNumber) {
    if (!CONFIG.v40RecaptureChainEnabled) return 0;
    
    let score = 0;
    const isWhite = activeColor === 'w';
    const fromSquare = move.substring(0, 2);
    const toSquare = move.substring(2, 4);
    
    // Check if this is a capture
    const capturedPiece = board.get(toSquare);
    if (!capturedPiece) return 0;  // Not a capture
    
    const movingPiece = board.get(fromSquare);
    if (!movingPiece) return 0;
    
    // Simulate after our capture
    const testBoard = simulateMove(board, move);
    if (!testBoard) return 0;
    
    // Check what can recapture on toSquare
    const recapturers = [];
    
    // Check for pawn recaptures (most dangerous for chains)
    const file = toSquare.charCodeAt(0) - 'a'.charCodeAt(0);
    const rank = parseInt(toSquare.charAt(1));
    const enemyPawnDir = isWhite ? -1 : 1;
    
    const pawnSquares = [];
    if (file > 0) pawnSquares.push(String.fromCharCode('a'.charCodeAt(0) + file - 1) + (rank + enemyPawnDir));
    if (file < 7) pawnSquares.push(String.fromCharCode('a'.charCodeAt(0) + file + 1) + (rank + enemyPawnDir));
    
    for (const pawnSquare of pawnSquares) {
        const pawn = testBoard.get(pawnSquare);
        if (pawn && pawn.toLowerCase() === 'p') {
            const pawnIsWhite = pawn === pawn.toUpperCase();
            if (pawnIsWhite !== isWhite) {
                // Enemy pawn can recapture!
                recapturers.push({ square: pawnSquare, piece: pawn, isPawn: true });
            }
        }
    }
    
    // If enemy pawn can recapture, check what happens after
    for (const recapturer of recapturers) {
        if (recapturer.isPawn) {
            // After pawn recaptures on toSquare, what can it attack next?
            const newPawnSquare = toSquare;
            const newFile = newPawnSquare.charCodeAt(0) - 'a'.charCodeAt(0);
            const newRank = parseInt(newPawnSquare.charAt(1));
            
            // Check pawn's next attack squares
            const pawnDir = isWhite ? -1 : 1;  // Enemy pawn direction
            const nextAttackSquares = [];
            if (newFile > 0) nextAttackSquares.push(String.fromCharCode('a'.charCodeAt(0) + newFile - 1) + (newRank + pawnDir));
            if (newFile < 7) nextAttackSquares.push(String.fromCharCode('a'.charCodeAt(0) + newFile + 1) + (newRank + pawnDir));
            
            for (const attackSquare of nextAttackSquares) {
                const target = testBoard.get(attackSquare);
                if (target) {
                    const targetIsWhite = target === target.toUpperCase();
                    if (targetIsWhite === isWhite) {
                        // After recapture, our piece is attacked!
                        const targetValue = getPieceValueSimple(target.toLowerCase());
                        if (targetValue >= 300) {
                            debugLog(\"[V40.39_RECAP]\", `â˜ ï¸ RECAPTURE CHAIN: After ${move}, pawn from ${recapturer.square} recaptures and attacks ${target} on ${attackSquare}!`);
                            score += CONFIG.v40RecaptureChainPenalty || -180000000000000;
                        }
                    }
                }
            }
            
            // Check for promotion after recapture
            const promotionRank = isWhite ? 1 : 8;
            if (newRank === (isWhite ? 2 : 7)) {
                debugLog(\"[V40.39_RECAP]\", `â˜ ï¸ RECAPTURE leads to pawn on 7th/2nd rank - promotion threat!`);
                score += (CONFIG.v40RecaptureChainPenalty || -180000000000000) / 2;
            }
        }
    }
    
    return score;
}

/**
 * v40.39: KNIGHT/BISHOP UNDER PAWN DANGER
 * Must move piece when it's under attack by enemy pawn
 */
function v40PieceUnderPawnDangerEval(fen, move, board, activeColor, moveNumber) {
    if (!CONFIG.v40PieceUnderPawnDangerEnabled) return 0;
    
    let score = 0;
    const isWhite = activeColor === 'w';
    const fromSquare = move.substring(0, 2);
    const toSquare = move.substring(2, 4);
    
    // First, find pieces that will be under pawn attack AFTER our move
    const testBoard = simulateMove(board, move);
    if (!testBoard) return 0;
    
    // Check each of our pieces
    for (const [square, piece] of testBoard) {
        if (!piece) continue;
        const pieceIsWhite = piece === piece.toUpperCase();
        if (pieceIsWhite !== isWhite) continue;
        
        const pieceType = piece.toLowerCase();
        if (pieceType === 'p' || pieceType === 'k') continue;
        
        // Check if this piece is under pawn attack after our move
        const file = square.charCodeAt(0) - 'a'.charCodeAt(0);
        const rank = parseInt(square.charAt(1));
        
        const enemyPawnRank = isWhite ? rank - 1 : rank + 1;
        const attackerSquares = [];
        if (file > 0) attackerSquares.push(String.fromCharCode('a'.charCodeAt(0) + file - 1) + enemyPawnRank);
        if (file < 7) attackerSquares.push(String.fromCharCode('a'.charCodeAt(0) + file + 1) + enemyPawnRank);
        
        for (const attackerSquare of attackerSquares) {
            const attacker = testBoard.get(attackerSquare);
            if (attacker && attacker.toLowerCase() === 'p') {
                const attackerIsWhite = attacker === attacker.toUpperCase();
                if (attackerIsWhite !== isWhite) {
                    // This piece is under pawn attack after our move!
                    const pieceValue = getPieceValueSimple(pieceType);
                    
                    // Was this piece already under attack before?
                    const wasUnderAttack = checkPawnAttackOnSquare(board, square, isWhite);
                    
                    if (!wasUnderAttack && pieceValue >= 300) {
                        // Our move PUT a piece under pawn attack!
                        debugLog(\"[V40.39_DANGER]\", `â˜ ï¸ MOVE ${move} PUTS ${pieceType} on ${square} UNDER PAWN ATTACK!`);
                        score += CONFIG.v40PieceUnderPawnDangerPenalty || -220000000000000;
                    }
                }
            }
        }
    }
    
    return score;
}

/**
 * v40.39 Helper: Check if square is under pawn attack
 */
function checkPawnAttackOnSquare(board, square, isWhite) {
    const file = square.charCodeAt(0) - 'a'.charCodeAt(0);
    const rank = parseInt(square.charAt(1));
    
    const enemyPawnRank = isWhite ? rank - 1 : rank + 1;
    if (enemyPawnRank < 1 || enemyPawnRank > 8) return false;
    
    const attackerSquares = [];
    if (file > 0) attackerSquares.push(String.fromCharCode('a'.charCodeAt(0) + file - 1) + enemyPawnRank);
    if (file < 7) attackerSquares.push(String.fromCharCode('a'.charCodeAt(0) + file + 1) + enemyPawnRank);
    
    for (const attackerSquare of attackerSquares) {
        const attacker = board.get(attackerSquare);
        if (attacker && attacker.toLowerCase() === 'p') {
            const attackerIsWhite = attacker === attacker.toUpperCase();
            if (attackerIsWhite !== isWhite) {
                return true;
            }
        }
    }
    return false;
}

/**
 * v40.39: PAWN FORK DETECTION
 * Detect when enemy pawn can fork two of our pieces
 */
function v40PawnForkDetectionEval(fen, move, board, activeColor, moveNumber) {
    if (!CONFIG.v40PawnForkDetectionEnabled) return 0;
    
    let score = 0;
    const isWhite = activeColor === 'w';
    
    // After our move, check for pawn fork threats
    const testBoard = simulateMove(board, move);
    if (!testBoard) return 0;
    
    // Find enemy pawns and check if they can advance to fork our pieces
    for (const [square, piece] of testBoard) {
        if (!piece || piece.toLowerCase() !== 'p') continue;
        
        const pieceIsWhite = piece === piece.toUpperCase();
        if (pieceIsWhite === isWhite) continue;  // Skip our pawns
        
        const file = square.charCodeAt(0) - 'a'.charCodeAt(0);
        const rank = parseInt(square.charAt(1));
        const pawnDir = pieceIsWhite ? 1 : -1;
        
        // Check one-square advance
        const advanceSquare = square.charAt(0) + (rank + pawnDir);
        if (!testBoard.get(advanceSquare)) {
            // Pawn can advance - check if the new position creates a fork
            const newFile = file;
            const newRank = rank + pawnDir;
            
            // Check attack squares from new position
            const forkTargets = [];
            const leftTarget = newFile > 0 ? String.fromCharCode('a'.charCodeAt(0) + newFile - 1) + (newRank + pawnDir) : null;
            const rightTarget = newFile < 7 ? String.fromCharCode('a'.charCodeAt(0) + newFile + 1) + (newRank + pawnDir) : null;
            
            if (leftTarget) {
                const leftPiece = testBoard.get(leftTarget);
                if (leftPiece) {
                    const leftIsWhite = leftPiece === leftPiece.toUpperCase();
                    if (leftIsWhite === isWhite && leftPiece.toLowerCase() !== 'p') {
                        forkTargets.push({ square: leftTarget, piece: leftPiece, value: getPieceValueSimple(leftPiece.toLowerCase()) });
                    }
                }
            }
            
            if (rightTarget) {
                const rightPiece = testBoard.get(rightTarget);
                if (rightPiece) {
                    const rightIsWhite = rightPiece === rightPiece.toUpperCase();
                    if (rightIsWhite === isWhite && rightPiece.toLowerCase() !== 'p') {
                        forkTargets.push({ square: rightTarget, piece: rightPiece, value: getPieceValueSimple(rightPiece.toLowerCase()) });
                    }
                }
            }
            
            // If pawn advance creates a fork of two pieces
            if (forkTargets.length >= 2) {
                const totalValue = forkTargets.reduce((sum, t) => sum + t.value, 0);
                if (totalValue >= 600) {  // At least two knights or equivalent
                    debugLog(\"[V40.39_FORK]\", `â˜ ï¸ PAWN FORK THREAT: ${square} can advance to ${advanceSquare} forking ${forkTargets.map(t => t.piece + '@' + t.square).join(' and ')}!`);
                    score += CONFIG.v40PawnForkDetectionPenalty || -240000000000000;
                }
            }
        }
    }
    
    return score;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
Observation: Edit was successful.