
Action: file_editor view /app/Lichess Bot-AlphaZero-Pure.user.js
Observation: /app/Lichess Bot-AlphaZero-Pure.user.js:
27026|function v40BishopUselessSquareEval(fen, move, board, activeColor, moveNumber) {
27027|    if (!CONFIG.v40BishopUselessSquareEnabled) return 0;
27028|    
27029|    let score = 0;
27030|    const fromSquare = move.substring(0, 2);
27031|    const toSquare = move.substring(2, 4);
27032|    const movingPiece = board.get(fromSquare);
27033|    const capturedPiece = board.get(toSquare);
27034|    
27035|    // Only check bishop moves that don't capture
27036|    if (!movingPiece || movingPiece.toLowerCase() !== 'b') return 0;
27037|    if (capturedPiece) return 0;  // Bishop captures are fine
27038|    
27039|    const uselessSquares = CONFIG.v40BishopUselessSquares || ['h6', 'a6', 'h3', 'a3', 'h7', 'a7', 'h2', 'a2'];
27040|    
27041|    if (uselessSquares.includes(toSquare)) {
27042|        debugLog("[V40.38_BISHOP]", `âš ï¸ BISHOP USELESS SQUARE: B${toSquare} is passive/useless!`);
27043|        score += CONFIG.v40BishopUselessSquarePenalty || -50000000000000;
27044|        
27045|        // Extra penalty if there are better options (like capturing)
27046|        // Check if bishop could capture something valuable instead
27047|        const isWhite = activeColor === 'w';
27048|        for (const [square, piece] of board) {
27049|            if (!piece) continue;
27050|            const pieceIsWhite = piece === piece.toUpperCase();
27051|            if (pieceIsWhite === isWhite) continue;
27052|            
27053|            const pieceValue = getPieceValueSimple(piece.toLowerCase());
27054|            if (pieceValue >= 300) {  // Knight or higher
27055|                // Check if bishop can reach this square
27056|                if (canBishopReach(fromSquare, square, board)) {
27057|                    debugLog("[V40.38_BISHOP]", `ðŸ’€ MISSED CAPTURE: Could have taken ${piece} on ${square}!`);
27058|                    score += (CONFIG.v40BishopUselessSquarePenalty || -50000000000000) / 2;
27059|                }
27060|            }
27061|        }
27062|    }
27063|    
27064|    return score;
27065|}
27066|
27067|/**
27068| * v40.38 Helper: Check if bishop can reach a target square
27069| */
27070|function canBishopReach(fromSquare, toSquare, board) {
27071|    const fromFile = fromSquare.charCodeAt(0) - 'a'.charCodeAt(0);
27072|    const fromRank = parseInt(fromSquare.charAt(1));
27073|    const toFile = toSquare.charCodeAt(0) - 'a'.charCodeAt(0);
27074|    const toRank = parseInt(toSquare.charAt(1));
27075|    
27076|    // Bishop moves diagonally
27077|    if (Math.abs(fromFile - toFile) !== Math.abs(fromRank - toRank)) return false;
27078|    if (fromFile === toFile && fromRank === toRank) return false;
27079|    
27080|    // Check if path is clear
27081|    const fileDir = fromFile < toFile ? 1 : -1;
27082|    const rankDir = fromRank < toRank ? 1 : -1;
27083|    
27084|    let file = fromFile + fileDir;
27085|    let rank = fromRank + rankDir;
27086|    
27087|    while (file !== toFile && rank !== toRank) {
27088|        const square = String.fromCharCode('a'.charCodeAt(0) + file) + rank;
27089|        if (board.get(square)) return false;  // Blocked
27090|        file += fileDir;
27091|        rank += rankDir;
27092|    }
27093|    
27094|    return true;
27095|}
27096|
27097|// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
27098|function findAttackedPiecesV40_9(board, color) {
27099|    const attacked = [];
27100|    const isWhite = color === 'w';
27101|    const enemyColor = isWhite ? 'b' : 'w';
27102|    
27103|    for (const [square, piece] of board) {
27104|        if (!piece) continue;
27105|        const pieceIsWhite = piece === piece.toUpperCase();
27106|        if (pieceIsWhite !== isWhite) continue;
27107|        
27108|        const pieceType = piece.toLowerCase();
27109|        if (pieceType === 'k') continue;  // King attacks handled separately
27110|        
27111|        // Check if this square is attacked by enemy
27112|        if (isSquareAttackedByColor(board, square, enemyColor)) {
27113|            // Check if it's adequately defended
27114|            const isDefended = isSquareDefendedByColor(board, square, color);
27115|            
27116|            // If attacked by something of lower value, still need to consider
27117|            const attackers = findAttackersOfSquare(board, square, enemyColor);
27118|            const lowestAttackerValue = Math.min(...attackers.map(a => getPieceValueSimple(a.piece.toLowerCase())));
27119|            const ourPieceValue = getPieceValueSimple(pieceType);
27120|            
27121|            // Consider it under attack if:
27122|            // 1. Not defended at all, or
27123|            // 2. Attacker is of lower value than our piece
27124|            if (!isDefended || lowestAttackerValue < ourPieceValue) {
27125|                attacked.push({
27126|                    square,
27127|                    piece,
27128|                    value: ourPieceValue,
27129|                    lowestAttackerValue
27130|                });
27131|            }
27132|        }
27133|    }
27134|    
27135|    // Sort by piece value (highest first - queen, then rook, etc.)
27136|    attacked.sort((a, b) => b.value - a.value);
27137|    
27138|    return attacked;
27139|}
27140|
27141|/**
27142| * v40.9 Helper: Find all hanging pieces (attacked and not defended)
27143| */
27144|function findHangingPiecesV40_9(board, color) {
27145|    const hanging = [];
27146|    const isWhite = color === 'w';
27147|    const enemyColor = isWhite ? 'b' : 'w';
27148|    
27149|    for (const [square, piece] of board) {
27150|        if (!piece) continue;
