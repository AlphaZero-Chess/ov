Now let me add the v40.52 enhancement functions. I'll insert them after line 30038 (after the v40CountThreatsCreated function):
Action: file_editor insert_text /app/Lichess Bot-AlphaZero-Pure.user.js --new-str "
// ═══════════════════════════════════════════════════════════════════════════════
// v40.52 SUPREME TACTICAL VISION — TRUE ALPHAZERO GODLIKE ENHANCEMENT
// ═══════════════════════════════════════════════════════════════════════════════
// Addresses:
// 1. Passive opening play (d3 instead of d4) - ANTI-PASSIVE ENFORCEMENT
// 2. Deep mate threat prevention (Qxg2#, Qf1#, etc.) - MATING THREAT SCANNER
// 3. Better tactical awareness - IMMEDIATE DANGER RESPONSE
// 4. Stronger endgame technique - KING ACTIVITY MAXIMIZER
// 5. Initiative loss prevention - TEMPO CRITICAL EVALUATION
// ═══════════════════════════════════════════════════════════════════════════════

/**
 * v40.52: ANTI-PASSIVE OPENING ENFORCEMENT
 * Bot MUST play aggressively in the opening (d4/e4, NOT d3/e3)
 * Penalizes passive pawn moves and rewards central control
 */
function v40AntiPassiveOpeningEnforcement(fen, move, board, activeColor, moveNumber) {
    if (moveNumber > 12) return 0;  // Only in opening
    
    let score = 0;
    const isWhite = activeColor === 'w';
    const fromSquare = move.substring(0, 2);
    const toSquare = move.substring(2, 4);
    const movingPiece = board.get(fromSquare);
    
    if (!movingPiece) return 0;
    const pieceType = movingPiece.toLowerCase();
    
    // CRITICAL: Penalize passive pawn moves in the opening
    if (pieceType === 'p' && moveNumber <= 8) {
        const toFile = toSquare.charCodeAt(0) - 'a'.charCodeAt(0);
        const toRank = parseInt(toSquare[1]);
        
        // For White
        if (isWhite) {
            // MASSIVE PENALTY for d3 when d4 is possible
            if (toSquare === 'd3') {
                const d2 = board.get('d2');
                const d4Blocked = board.get('d4');
                if (d2 && d2.toLowerCase() === 'p' && !d4Blocked) {
                    score += -200000;  // MASSIVE penalty
                    debugLog(\"[V40.52_PASSIVE]\", `☠️ PASSIVE d3 in opening! MASSIVE PENALTY`);
                }
            }
            // MASSIVE PENALTY for e3 when e4 is possible
            if (toSquare === 'e3') {
                const e2 = board.get('e2');
                const e4Blocked = board.get('e4');
                if (e2 && e2.toLowerCase() === 'p' && !e4Blocked) {
                    score += -200000;  // MASSIVE penalty
                    debugLog(\"[V40.52_PASSIVE]\", `☠️ PASSIVE e3 in opening! MASSIVE PENALTY`);
                }
            }
            // MASSIVE BONUS for d4 and e4
            if (toSquare === 'd4' || toSquare === 'e4') {
                score += 50000;  // Big bonus for aggressive central play
                debugLog(\"[V40.52_PASSIVE]\", `✅ AGGRESSIVE central pawn ${toSquare}! BONUS`);
            }
        } else {
            // For Black - similar logic
            if (toSquare === 'd6' && moveNumber <= 4) {
                const d7 = board.get('d7');
                const d5Blocked = board.get('d5');
                if (d7 && d7.toLowerCase() === 'p' && !d5Blocked) {
                    score += -100000;  // Penalty for passive d6
                }
            }
            if (toSquare === 'd5' || toSquare === 'e5') {
                score += 40000;  // Bonus for aggressive central play
            }
        }
    }
    
    // CRITICAL: Development before pawn pushing
    if (pieceType === 'p' && moveNumber >= 3 && moveNumber <= 8) {
        const toFile = toSquare.charCodeAt(0) - 'a'.charCodeAt(0);
        const toRank = parseInt(toSquare[1]);
        
        // Count developed pieces
        let developedPieces = 0;
        const minorPieceSquares = isWhite 
            ? ['b1', 'c1', 'f1', 'g1']  // Knights and bishops starting squares
            : ['b8', 'c8', 'f8', 'g8'];
        
        for (const sq of minorPieceSquares) {
            const p = board.get(sq);
            if (!p || p.toLowerCase() === 'p') {
                developedPieces++;  // Piece moved from starting square
            }
        }
        
        // If we haven't developed our pieces, penalize excessive pawn moves
        if (developedPieces < 2 && toFile !== 3 && toFile !== 4) {  // Not d or e file
            score += -30000;
            debugLog(\"[V40.52_PASSIVE]\", `⚠️ Pawn move ${move} before development!`);
        }
    }
    
    return score;
}

/**
 * v40.52: DEEP MATING THREAT SCANNER
 * Detects and heavily penalizes moves that allow checkmate
 * Scans for common mating patterns: back rank, smothered, Q+R batteries, etc.
 */
function v40DeepMatingThreatScanner(fen, move, board, activeColor, moveNumber) {
    let score = 0;
    const isWhite = activeColor === 'w';
    const enemyColor = isWhite ? 'b' : 'w';
    
    // Simulate the move
    const testBoard = simulateMove(board, move);
    if (!testBoard) return 0;
    
    // Find our king
    const kingSquare = findKingSquare(testBoard, activeColor);
    if (!kingSquare) return 0;
    
    const kingFile = kingSquare.charCodeAt(0) - 'a'.charCodeAt(0);
    const kingRank = parseInt(kingSquare[1]);
    
    // Check for enemy queen and rooks near our king (mating threat)
    let enemyQueen = null;
    let enemyRooks = [];
    let enemyBishops = [];
    let enemyKnights = [];
    
    for (const [sq, piece] of testBoard) {
        if (!piece) continue;
        const pieceIsWhite = piece === piece.toUpperCase();
        if (pieceIsWhite === isWhite) continue;  // Enemy pieces only
        
        const pType = piece.toLowerCase();
        if (pType === 'q') enemyQueen = sq;
        if (pType === 'r') enemyRooks.push(sq);
        if (pType === 'b') enemyBishops.push(sq);
        if (pType === 'n') enemyKnights.push(sq);
    }
    
    // PATTERN 1: Back rank mate threat
    if ((isWhite && kingRank === 1) || (!isWhite && kingRank === 8)) {
        // King on back rank - check for rook/queen on same file
        for (const rook of enemyRooks) {
            const rookFile = rook.charCodeAt(0) - 'a'.charCodeAt(0);
            const rookRank = parseInt(rook[1]);
            if ((isWhite && rookRank === 1) || (!isWhite && rookRank === 8)) {
                // Rook on back rank! Check if it can deliver mate
                if (isBackRankMatePossible(testBoard, kingSquare, isWhite)) {
                    score += -500000;  // MASSIVE penalty
                    debugLog(\"[V40.52_MATE]\", `☠️ BACK RANK MATE THREAT detected after ${move}!`);
                }
            }
        }
        if (enemyQueen) {
            const qRank = parseInt(enemyQueen[1]);
            if ((isWhite && qRank === 1) || (!isWhite && qRank === 8)) {
                if (isBackRankMatePossible(testBoard, kingSquare, isWhite)) {
                    score += -600000;  // MASSIVE penalty - queen is stronger
                    debugLog(\"[V40.52_MATE]\", `☠️☠️ QUEEN BACK RANK MATE THREAT after ${move}!`);
                }
            }
        }
    }
    
    // PATTERN 2: King corner trap (Qxg2# style mates)
    if (isKingInCorner(kingSquare)) {
        if (enemyQueen) {
            const qFile = enemyQueen.charCodeAt(0) - 'a'.charCodeAt(0);
            const qRank = parseInt(enemyQueen[1]);
            const qDist = Math.max(Math.abs(qFile - kingFile), Math.abs(qRank - kingRank));
            
            if (qDist <= 2) {
                // Queen near cornered king - very dangerous!
                const kingEscapes = countKingEscapes(testBoard, kingSquare, isWhite);
                if (kingEscapes <= 1) {
                    score += -400000;
                    debugLog(\"[V40.52_MATE]\", `☠️ KING CORNER TRAP! Only ${kingEscapes} escapes after ${move}`);
                }
            }
        }
    }
    
    // PATTERN 3: Queen + Piece coordination near king
    if (enemyQueen) {
        const qFile = enemyQueen.charCodeAt(0) - 'a'.charCodeAt(0);
        const qRank = parseInt(enemyQueen[1]);
        const qDist = Math.max(Math.abs(qFile - kingFile), Math.abs(qRank - kingRank));
        
        if (qDist <= 3) {
            // Count enemy pieces within striking distance
            let nearbyEnemyPieces = 0;
            for (const [sq, piece] of testBoard) {
                if (!piece) continue;
                const pieceIsWhite = piece === piece.toUpperCase();
                if (pieceIsWhite === isWhite) continue;
                
                const pFile = sq.charCodeAt(0) - 'a'.charCodeAt(0);
                const pRank = parseInt(sq[1]);
                const dist = Math.max(Math.abs(pFile - kingFile), Math.abs(pRank - kingRank));
                
                if (dist <= 3 && piece.toLowerCase() !== 'k') {
                    nearbyEnemyPieces++;
                }
            }
            
            if (nearbyEnemyPieces >= 2) {
                const kingEscapes = countKingEscapes(testBoard, kingSquare, isWhite);
                if (kingEscapes <= 2) {
                    score += -300000 * (3 - kingEscapes);
                    debugLog(\"[V40.52_MATE]\", `☠️ MATING ATTACK! ${nearbyEnemyPieces} enemies near king, ${kingEscapes} escapes`);
                }
            }
        }
    }
    
    // PATTERN 4: Check if we're already in check and this move doesn't help
    if (isSquareAttackedByColor(testBoard, kingSquare, enemyColor)) {
        score += -1000000;  // CRITICAL - we're still in check!
        debugLog(\"[V40.52_MATE]\", `☠️☠️☠️ STILL IN CHECK after ${move}!!!`);
    }
    
    return score;
}

/**
 * v40.52 Helper: Check if back rank mate is possible
 */
function isBackRankMatePossible(board, kingSquare, isWhite) {
    const kingFile = kingSquare.charCodeAt(0) - 'a'.charCodeAt(0);
    const kingRank = parseInt(kingSquare[1]);
    const escapeRank = isWhite ? 2 : 7;
    
    // Check if king can escape forward
    for (let f = kingFile - 1; f <= kingFile + 1; f++) {
        if (f < 0 || f > 7) continue;
        const escapeSquare = String.fromCharCode('a'.charCodeAt(0) + f) + escapeRank;
        const pieceOnEscape = board.get(escapeSquare);
        
        // Check if escape square is blocked by our own piece
        if (pieceOnEscape) {
            const pieceIsWhite = pieceOnEscape === pieceOnEscape.toUpperCase();
            if (pieceIsWhite === isWhite) continue;  // Blocked by our piece
        }
        
        // Square is empty or has enemy piece - potential escape
        const enemyColor = isWhite ? 'b' : 'w';
        if (!isSquareAttackedByColor(board, escapeSquare, enemyColor)) {
            return false;  // King has escape
        }
    }
    
    return true;  // No escape = back rank mate possible
}

/**
 * v40.52 Helper: Check if king is in corner
 */
function isKingInCorner(kingSquare) {
    return kingSquare === 'a1' || kingSquare === 'h1' || 
           kingSquare === 'a8' || kingSquare === 'h8' ||
           kingSquare === 'g1' || kingSquare === 'h2' ||  // Common castled positions
           kingSquare === 'g8' || kingSquare === 'h7';
}

/**
 * v40.52 Helper: Count king escape squares
 */
function countKingEscapes(board, kingSquare, isWhite) {
    const kFile = kingSquare.charCodeAt(0) - 'a'.charCodeAt(0);
    const kRank = parseInt(kingSquare[1]) - 1;
    const enemyColor = isWhite ? 'b' : 'w';
    
    let escapes = 0;
    
    for (let df = -1; df <= 1; df++) {
        for (let dr = -1; dr <= 1; dr++) {
            if (df === 0 && dr === 0) continue;
            
            const f = kFile + df;
            const r = kRank + dr;
            
            if (f < 0 || f > 7 || r < 0 || r > 7) continue;
            
            const sq = String.fromCharCode('a'.charCodeAt(0) + f) + (r + 1);
            const pieceOnSq = board.get(sq);
            
            // Check if square is blocked by our own piece
            if (pieceOnSq) {
                const pieceIsWhite = pieceOnSq === pieceOnSq.toUpperCase();
                if (pieceIsWhite === isWhite) continue;  // Blocked
            }
            
            // Check if square is attacked
            if (!isSquareAttackedByColor(board, sq, enemyColor)) {
                escapes++;
            }
        }
    }
    
    return escapes;
}

/**
 * v40.52: IMMEDIATE DANGER RESPONSE
 * Bot MUST respond to immediate tactical threats
 * Detects hanging pieces, threats to queen, forced exchanges, etc.
 */
function v40ImmediateDangerResponse(fen, move, board, activeColor, moveNumber) {
    let score = 0;
    const isWhite = activeColor === 'w';
    const enemyColor = isWhite ? 'b' : 'w';
    const toSquare = move.substring(2, 4);
    const fromSquare = move.substring(0, 2);
    const movingPiece = board.get(fromSquare);
    
    if (!movingPiece) return 0;
    
    // Check if any of our pieces are currently attacked
    let criticalThreats = [];
    
    for (const [sq, piece] of board) {
        if (!piece) continue;
        const pieceIsWhite = piece === piece.toUpperCase();
        if (pieceIsWhite !== isWhite) continue;
        
        const pType = piece.toLowerCase();
        if (pType === 'k') continue;
        
        const pieceValue = getPieceValueSimple(pType);
        
        // Is this piece under attack?
        if (isSquareAttackedByColor(board, sq, enemyColor)) {
            // Is it defended?
            const defended = isSquareDefendedByColor(board, sq, activeColor);
            
            if (!defended) {
                criticalThreats.push({ square: sq, piece: pType, value: pieceValue });
            } else {
                // Even if defended, if attacker is lower value, it's a threat
                const attackers = findAttackersOfSquare(board, sq, enemyColor);
                for (const attacker of attackers) {
                    const attackerValue = getPieceValueSimple(attacker.piece.toLowerCase());
                    if (attackerValue < pieceValue) {
                        criticalThreats.push({ square: sq, piece: pType, value: pieceValue - attackerValue });
                    }
                }
            }
        }
    }
    
    // If we have critical threats, we MUST address them
    if (criticalThreats.length > 0) {
        // Sort by value (highest first)
        criticalThreats.sort((a, b) => b.value - a.value);
        
        const highestThreat = criticalThreats[0];
        
        // Check if this move addresses the threat
        const moveAddressesThreat = (
            toSquare === highestThreat.square ||  // Moving the threatened piece
            fromSquare === highestThreat.square || // Moving the threatened piece
            board.get(toSquare)  // Capturing something (might be the attacker)
        );
        
        if (!moveAddressesThreat) {
            // We're ignoring a critical threat!
            score += -(highestThreat.value * 100000);
            debugLog(\"[V40.52_DANGER]\", `☠️ IGNORING THREAT to ${highestThreat.piece}@${highestThreat.square}! Playing ${move} instead!`);
        } else {
            score += 10000;  // Good - addressing the threat
            debugLog(\"[V40.52_DANGER]\", `✅ Addressing threat to ${highestThreat.piece}@${highestThreat.square}`);
        }
    }
    
    return score;
}

/**
 * v40.52: KING ACTIVITY MAXIMIZER (Endgame)
 * In endgames, king must be ACTIVE - centralized and advancing
 */
function v40KingActivityMaximizer(fen, move, board, activeColor, moveNumber) {
    // Only in endgame
    if (!isEndgame(board)) return 0;
    
    let score = 0;
    const isWhite = activeColor === 'w';
    const fromSquare = move.substring(0, 2);
    const toSquare = move.substring(2, 4);
    const movingPiece = board.get(fromSquare);
    
    if (!movingPiece || movingPiece.toLowerCase() !== 'k') return 0;
    
    // King is moving - evaluate the destination
    const toFile = toSquare.charCodeAt(0) - 'a'.charCodeAt(0);
    const toRank = parseInt(toSquare[1]);
    const fromFile = fromSquare.charCodeAt(0) - 'a'.charCodeAt(0);
    const fromRank = parseInt(fromSquare[1]);
    
    // Centralization bonus - closer to center = better
    const centerDist = Math.max(Math.abs(toFile - 3.5), Math.abs(toRank - 4.5));
    const oldCenterDist = Math.max(Math.abs(fromFile - 3.5), Math.abs(fromRank - 4.5));
    
    if (centerDist < oldCenterDist) {
        score += 15000;  // King centralizing
        debugLog(\"[V40.52_ENDGAME]\", `✅ King centralizing: ${fromSquare} -> ${toSquare}`);
    }
    
    // Advancing bonus (for the winning side)
    if (isWhite && toRank > fromRank) {
        score += 10000;  // King advancing
    } else if (!isWhite && toRank < fromRank) {
        score += 10000;  // King advancing
    }
    
    // Activity near enemy pawns (to help promote our pawns or stop theirs)
    let nearEnemyPawns = 0;
    for (const [sq, piece] of board) {
        if (!piece || piece.toLowerCase() !== 'p') continue;
        const pieceIsWhite = piece === piece.toUpperCase();
        if (pieceIsWhite === isWhite) continue;  // Enemy pawns
        
        const pFile = sq.charCodeAt(0) - 'a'.charCodeAt(0);
        const pRank = parseInt(sq[1]);
        const dist = Math.max(Math.abs(toFile - pFile), Math.abs(toRank - pRank));
        
        if (dist <= 2) nearEnemyPawns++;
    }
    
    if (nearEnemyPawns > 0) {
        score += 8000 * nearEnemyPawns;  // King active near enemy pawns
    }
    
    return score;
}

/**
 * v40.52 Helper: Check if position is endgame
 */
function isEndgame(board) {
    let totalPieceValue = 0;
    let queenCount = 0;
    
    for (const [sq, piece] of board) {
        if (!piece) continue;
        const pType = piece.toLowerCase();
        if (pType === 'k' || pType === 'p') continue;
        
        totalPieceValue += getPieceValueSimple(pType);
        if (pType === 'q') queenCount++;
    }
    
    // Endgame if total piece value < 26 (roughly both sides have rook+minor each)
    // Or if no queens on board
    return totalPieceValue < 26 || queenCount === 0;
}

/**
 * v40.52: TEMPO CRITICAL EVALUATION
 * Evaluates if we're losing tempo with useless moves
 * Penalizes moving the same piece twice without purpose
 */
function v40TempoCriticalEval(fen, move, board, activeColor, moveNumber) {
    if (moveNumber < 4 || moveNumber > 20) return 0;  // Only in opening/middlegame
    
    let score = 0;
    const fromSquare = move.substring(0, 2);
    const toSquare = move.substring(2, 4);
    const movingPiece = board.get(fromSquare);
    
    if (!movingPiece) return 0;
    const pieceType = movingPiece.toLowerCase();
    
    // Check if this is a retreat (piece moving back)
    const fromRank = parseInt(fromSquare[1]);
    const toRank = parseInt(toSquare[1]);
    const isWhite = activeColor === 'w';
    
    const isRetreat = (isWhite && toRank < fromRank) || (!isWhite && toRank > fromRank);
    
    if (isRetreat && pieceType !== 'k') {
        // Retreating without capturing is usually bad tempo
        const capturing = board.get(toSquare);
        if (!capturing) {
            score += -15000;  // Tempo loss
            debugLog(\"[V40.52_TEMPO]\", `⚠️ Retreating ${pieceType} from ${fromSquare} to ${toSquare} - tempo loss!`);
        }
    }
    
    // CRITICAL: Penalize queen moves in the opening (before piece development)
    if (pieceType === 'q' && moveNumber <= 10) {
        // Count how many minor pieces are still on starting squares
        let undevelopedMinors = 0;
        const minorStartSquares = isWhite 
            ? ['b1', 'c1', 'f1', 'g1']
            : ['b8', 'c8', 'f8', 'g8'];
        
        for (const sq of minorStartSquares) {
            const p = board.get(sq);
            if (p && (p.toLowerCase() === 'n' || p.toLowerCase() === 'b')) {
                undevelopedMinors++;
            }
        }
        
        if (undevelopedMinors >= 2) {
            score += -40000;  // Early queen move with undeveloped pieces
            debugLog(\"[V40.52_TEMPO]\", `⚠️ Early queen move with ${undevelopedMinors} undeveloped minors!`);
        }
    }
    
    return score;
}

/**
 * v40.52: CRUSHING EXCHANGE EVALUATION
 * Evaluate exchanges - don't trade when ahead, simplify when winning
 */
function v40CrushingExchangeEval(fen, move, board, activeColor, moveNumber) {
    let score = 0;
    const toSquare = move.substring(2, 4);
    const capturedPiece = board.get(toSquare);
    
    if (!capturedPiece) return 0;  // Not a capture
    
    const fromSquare = move.substring(0, 2);
    const movingPiece = board.get(fromSquare);
    if (!movingPiece) return 0;
    
    const ourValue = getPieceValueSimple(movingPiece.toLowerCase());
    const theirValue = getPieceValueSimple(capturedPiece.toLowerCase());
    
    // Calculate material balance
    const materialBalance = calculateMaterialBalance(board, activeColor);
    
    // If we're winning on material
    if (materialBalance > 3) {
        // Encourage even exchanges to simplify
        if (Math.abs(ourValue - theirValue) <= 1) {
            score += 5000;  // Good exchange when ahead
            debugLog(\"[V40.52_EXCHANGE]\", `✅ Simplifying exchange when ahead: ${move}`);
        }
    }
    
    // If we're losing on material
    if (materialBalance < -3) {
        // Discourage exchanges, need complications
        if (Math.abs(ourValue - theirValue) <= 1) {
            score += -5000;  // Avoid equal exchanges when behind
            debugLog(\"[V40.52_EXCHANGE]\", `⚠️ Exchanging when behind! Avoid: ${move}`);
        }
    }
    
    // Always reward winning material
    if (theirValue > ourValue) {
        score += (theirValue - ourValue) * 10000;
    }
    
    return score;
}

/**
 * v40.52 Helper: Calculate material balance
 */
function calculateMaterialBalance(board, activeColor) {
    let balance = 0;
    const isWhite = activeColor === 'w';
    
    for (const [sq, piece] of board) {
        if (!piece) continue;
        const pType = piece.toLowerCase();
        if (pType === 'k') continue;
        
        const value = getPieceValueSimple(pType);
        const pieceIsWhite = piece === piece.toUpperCase();
        
        if (pieceIsWhite === isWhite) {
            balance += value;
        } else {
            balance -= value;
        }
    }
    
    return balance;
}
" --insert-line 30038
Observation: Insert was successful.