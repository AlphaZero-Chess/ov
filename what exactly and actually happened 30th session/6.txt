Now let me add the v40.20 functions after the v40.19 function:
Action: file_editor str_replace /app/Lichess Bot-AlphaZero-Pure.user.js --old-str "    } catch (e) {
        debugLog(\"[V40.19_WIN]\", `Error: ${e.message}`);
    }
    
    return score;
}

// ═══════════════════════════════════════════════════════════════════════════════

/**
 * v40.9 Helper: Find all attacked pieces for a color
 */
function findAttackedPiecesV40_9(board, color) {" --new-str "    } catch (e) {
        debugLog(\"[V40.19_WIN]\", `Error: ${e.message}`);
    }
    
    return score;
}

// ═══════════════════════════════════════════════════════════════════════════════
// v40.20 PAWN PROMOTION & FORCING SEQUENCE SUPREME
// From game analysis: Bot missed c4-cxd3-dxc2-cxb1=R promotion sequence!
// This is CRITICAL - must calculate all promotion lines
// ═══════════════════════════════════════════════════════════════════════════════

/**
 * v40.20 PROMOTION THREAT DETECTION: Calculate promotion threats 8+ moves ahead
 * CRITICAL: This catches sequences like c4-cxd3-dxc2-cxb1=R that the bot missed
 */
function v40PromotionThreatEval(fen, move, board, activeColor, moveNumber) {
    if (!CONFIG.v40PromotionThreatEnabled) return 0;
    
    let score = 0;
    const isWhite = activeColor === 'w';
    const enemyColor = isWhite ? 'b' : 'w';
    
    try {
        const fromSquare = move.substring(0, 2);
        const toSquare = move.substring(2, 4);
        const movingPiece = board.get(fromSquare);
        
        if (!movingPiece) return 0;
        
        // Simulate our move
        const afterMove = new Map(board);
        afterMove.delete(fromSquare);
        afterMove.set(toSquare, movingPiece);
        
        // CRITICAL CHECK 1: Find all enemy passed pawns and their distance to promotion
        let enemyPassedPawns = [];
        let ourPassedPawns = [];
        
        const enemyPawnChar = enemyColor === 'w' ? 'P' : 'p';
        const ourPawnChar = isWhite ? 'P' : 'p';
        
        for (const [sq, piece] of afterMove) {
            if (!piece) continue;
            
            // Enemy pawns
            if (piece === enemyPawnChar) {
                if (isPassedPawnV40_20(sq, afterMove, enemyColor)) {
                    const rank = parseInt(sq[1]);
                    const promotionRank = enemyColor === 'w' ? 8 : 1;
                    const distanceToPromotion = Math.abs(rank - promotionRank);
                    
                    enemyPassedPawns.push({
                        square: sq,
                        distance: distanceToPromotion,
                        file: sq[0]
                    });
                    
                    debugLog(\"[V40.20_PROMO]\", `⚠️ Enemy passed pawn on ${sq}, ${distanceToPromotion} squares from promotion!`);
                }
            }
            
            // Our pawns
            if (piece === ourPawnChar) {
                if (isPassedPawnV40_20(sq, afterMove, activeColor)) {
                    const rank = parseInt(sq[1]);
                    const promotionRank = isWhite ? 8 : 1;
                    const distanceToPromotion = Math.abs(rank - promotionRank);
                    
                    ourPassedPawns.push({
                        square: sq,
                        distance: distanceToPromotion,
                        file: sq[0]
                    });
                }
            }
        }
        
        // CRITICAL: Score enemy passed pawns based on proximity to promotion
        for (const pp of enemyPassedPawns) {
            if (pp.distance <= 2) {
                score += CONFIG.v40EnemyPromotionIn2Penalty;
                debugLog(\"[V40.20_PROMO]\", `☠️☠️☠️ CRITICAL: Enemy pawn on ${pp.square} promotes in 2 moves!`);
            } else if (pp.distance <= 4) {
                score += CONFIG.v40EnemyPromotionIn4Penalty;
                debugLog(\"[V40.20_PROMO]\", `☠️☠️ DANGER: Enemy pawn on ${pp.square} promotes in ${pp.distance} moves!`);
            } else {
                score += CONFIG.v40EnemyPassedPawnAdvancingPenalty * (8 - pp.distance) / 8;
            }
        }
        
        // Score our passed pawns
        for (const pp of ourPassedPawns) {
            if (pp.distance <= 4) {
                score += CONFIG.v40OurPromotionIn4Bonus;
            } else {
                score += CONFIG.v40OurPassedPawnBonus * (8 - pp.distance) / 8;
            }
        }
        
        // CRITICAL CHECK 2: Detect pawn break sequences that create passed pawns
        // Like c4 creating a passed pawn after cxd3, dxc2
        if (movingPiece.toLowerCase() === 'p') {
            // We're moving a pawn - does this block or enable a passed pawn?
            const wasBlocking = wasBlockingPassedPawnV40_20(fromSquare, board, enemyColor);
            if (wasBlocking) {
                score += CONFIG.v40EnemyPassedPawnAdvancingPenalty;
                debugLog(\"[V40.20_PROMO]\", `⚠️ ${move} UNBLOCKS an enemy passed pawn path!`);
            }
        }
        
        // CRITICAL CHECK 3: Does our move allow opponent to CREATE a passed pawn?
        const canCreatePassedPawn = canOpponentCreatePassedPawnV40_20(afterMove, enemyColor);
        if (canCreatePassedPawn.possible) {
            score += CONFIG.v40EnemyPassedPawnPenalty;
            debugLog(\"[V40.20_PROMO]\", `⚠️ After ${move}, opponent can create passed pawn via ${canCreatePassedPawn.sequence}`);
        }
        
    } catch (e) {
        debugLog(\"[V40.20_PROMO]\", `Error: ${e.message}`);
    }
    
    return score;
}

/**
 * v40.20 Helper: Check if a pawn is passed
 */
function isPassedPawnV40_20(square, board, color) {
    const file = square.charCodeAt(0) - 'a'.charCodeAt(0);
    const rank = parseInt(square[1]);
    const isWhite = color === 'w';
    const enemyPawnChar = isWhite ? 'p' : 'P';
    
    // For a pawn to be passed, there must be no enemy pawns on the same file
    // or adjacent files ahead of it
    const adjacentFiles = [file - 1, file, file + 1].filter(f => f >= 0 && f <= 7);
    
    for (let r = isWhite ? rank + 1 : rank - 1; isWhite ? r <= 8 : r >= 1; isWhite ? r++ : r--) {
        for (const f of adjacentFiles) {
            const checkSquare = String.fromCharCode(f + 'a'.charCodeAt(0)) + r;
            const piece = board.get(checkSquare);
            if (piece === enemyPawnChar) {
                return false; // Blocked by enemy pawn
            }
        }
    }
    
    return true;
}

/**
 * v40.20 Helper: Was a pawn blocking an enemy passed pawn?
 */
function wasBlockingPassedPawnV40_20(square, board, enemyColor) {
    const file = square.charCodeAt(0) - 'a'.charCodeAt(0);
    const rank = parseInt(square[1]);
    const enemyPawnChar = enemyColor === 'w' ? 'P' : 'p';
    const enemyDirection = enemyColor === 'w' ? -1 : 1;
    
    // Check if there was an enemy pawn behind this square that we were blocking
    for (let r = rank + enemyDirection; enemyColor === 'w' ? r >= 1 : r <= 8; r += enemyDirection) {
        const checkSquare = String.fromCharCode(file + 'a'.charCodeAt(0)) + r;
        const piece = board.get(checkSquare);
        if (piece === enemyPawnChar) {
            return true; // We were blocking this pawn
        }
    }
    
    return false;
}

/**
 * v40.20 Helper: Can opponent create a passed pawn with a sequence?
 */
function canOpponentCreatePassedPawnV40_20(board, enemyColor) {
    // Check for pawn capture sequences that could create passed pawns
    const enemyPawnChar = enemyColor === 'w' ? 'P' : 'p';
    const direction = enemyColor === 'w' ? 1 : -1;
    
    for (const [sq, piece] of board) {
        if (piece !== enemyPawnChar) continue;
        
        const file = sq.charCodeAt(0) - 'a'.charCodeAt(0);
        const rank = parseInt(sq[1]);
        
        // Check diagonal captures that could create passed pawn
        for (const df of [-1, 1]) {
            const captureFile = file + df;
            if (captureFile < 0 || captureFile > 7) continue;
            
            const captureSquare = String.fromCharCode(captureFile + 'a'.charCodeAt(0)) + (rank + direction);
            const targetPiece = board.get(captureSquare);
            
            if (targetPiece && targetPiece.toLowerCase() !== 'k') {
                // Simulate capture and check if pawn becomes passed
                const afterCapture = new Map(board);
                afterCapture.delete(sq);
                afterCapture.set(captureSquare, piece);
                
                if (isPassedPawnV40_20(captureSquare, afterCapture, enemyColor)) {
                    return { possible: true, sequence: `${sq}x${captureSquare}` };
                }
            }
        }
    }
    
    return { possible: false, sequence: '' };
}

/**
 * v40.20 FORCING SEQUENCE CALCULATOR: Calculate all forcing sequences
 * Must see sequences like c4-cxd3-dxc2-cxb1=R
 */
function v40ForcingSequenceEval(fen, move, board, activeColor, moveNumber) {
    if (!CONFIG.v40ForcingSequenceEnabled) return 0;
    
    let score = 0;
    const isWhite = activeColor === 'w';
    const enemyColor = isWhite ? 'b' : 'w';
    
    try {
        const fromSquare = move.substring(0, 2);
        const toSquare = move.substring(2, 4);
        const movingPiece = board.get(fromSquare);
        
        if (!movingPiece) return 0;
        
        // Simulate our move
        const afterMove = new Map(board);
        afterMove.delete(fromSquare);
        const capturedByUs = afterMove.get(toSquare);
        afterMove.set(toSquare, movingPiece);
        
        // CHECK 1: Does our move give check? (forcing)
        const enemyKing = findKing(afterMove, enemyColor);
        if (enemyKing && isSquareAttackedByColor(afterMove, enemyKing, activeColor)) {
            score += CONFIG.v40CheckSequenceBonus;
            debugLog(\"[V40.20_FORCE]\", `✅ ${move} gives CHECK!`);
        }
        
        // CHECK 2: Does our move BLOCK a promotion threat?
        // This is HUGE if there's an enemy passed pawn
        const wasBlockingPromotion = doesMoveBlockPromotionV40_20(move, board, afterMove, activeColor);
        if (wasBlockingPromotion) {
            score += CONFIG.v40MustBlockPromotionBonus;
            debugLog(\"[V40.20_FORCE]\", `✅✅ ${move} BLOCKS promotion threat!`);
        }
        
        // CHECK 3: Look at opponent's forcing responses
        // After our move, what forcing moves does opponent have?
        const opponentForcingMoves = getOpponentForcingMovesV40_20(afterMove, enemyColor);
        
        for (const forcingMove of opponentForcingMoves) {
            if (forcingMove.type === 'check') {
                score -= 50000000;
                debugLog(\"[V40.20_FORCE]\", `⚠️ After ${move}, opponent has check: ${forcingMove.move}`);
            }
            if (forcingMove.type === 'promotion_threat') {
                score -= 200000000;
                debugLog(\"[V40.20_FORCE]\", `☠️ After ${move}, opponent threatens promotion: ${forcingMove.move}`);
            }
            if (forcingMove.type === 'piece_capture') {
                score -= 100000000;
                debugLog(\"[V40.20_FORCE]\", `⚠️ After ${move}, opponent can capture: ${forcingMove.move}`);
            }
        }
        
    } catch (e) {
        debugLog(\"[V40.20_FORCE]\", `Error: ${e.message}`);
    }
    
    return score;
}

/**
 * v40.20 Helper: Does move block a promotion?
 */
function doesMoveBlockPromotionV40_20(move, beforeBoard, afterBoard, activeColor) {
    const enemyColor = activeColor === 'w' ? 'b' : 'w';
    const toSquare = move.substring(2, 4);
    
    // Check if we moved to a square that blocks an enemy passed pawn's path
    const toFile = toSquare.charCodeAt(0) - 'a'.charCodeAt(0);
    const toRank = parseInt(toSquare[1]);
    
    const enemyPawnChar = enemyColor === 'w' ? 'P' : 'p';
    const enemyDirection = enemyColor === 'w' ? 1 : -1;
    
    // Check if there's an enemy pawn behind us on the same file
    for (let r = enemyColor === 'w' ? toRank - 1 : toRank + 1; 
         enemyColor === 'w' ? r >= 1 : r <= 8; 
         r -= enemyDirection) {
        const checkSquare = String.fromCharCode(toFile + 'a'.charCodeAt(0)) + r;
        if (beforeBoard.get(checkSquare) === enemyPawnChar) {
            // We're now blocking this pawn!
            return true;
        }
    }
    
    return false;
}

/**
 * v40.20 Helper: Get opponent's forcing moves
 */
function getOpponentForcingMovesV40_20(board, color) {
    const forcingMoves = [];
    const isWhite = color === 'w';
    const ourKing = findKing(board, isWhite ? 'b' : 'w');
    
    // Find all pawns close to promotion
    const pawnChar = isWhite ? 'P' : 'p';
    const promotionRank = isWhite ? 7 : 2; // One before promotion
    
    for (const [sq, piece] of board) {
        if (piece !== pawnChar) continue;
        
        const rank = parseInt(sq[1]);
        if (rank === promotionRank) {
            // This pawn can promote next move!
            const promotionSquare = sq[0] + (isWhite ? '8' : '1');
            if (!board.get(promotionSquare)) {
                forcingMoves.push({
                    move: sq + promotionSquare,
                    type: 'promotion_threat'
                });
            }
        }
    }
    
    // Find checks
    // (Simplified: just look for immediate piece attacks on enemy king)
    if (ourKing) {
        for (const [sq, piece] of board) {
            if (!piece) continue;
            const pieceIsWhite = piece === piece.toUpperCase();
            if (pieceIsWhite !== isWhite) continue;
            
            // Can this piece attack the enemy king?
            // Simplified check - just queens and rooks
            if (['q', 'r'].includes(piece.toLowerCase())) {
                // Would need proper move generation here
                // For now, flag if heavy piece is near king
                const pieceFile = sq.charCodeAt(0) - 'a'.charCodeAt(0);
                const pieceRank = parseInt(sq[1]);
                const kingFile = ourKing.charCodeAt(0) - 'a'.charCodeAt(0);
                const kingRank = parseInt(ourKing[1]);
                
                if (pieceFile === kingFile || pieceRank === kingRank) {
                    forcingMoves.push({
                        move: sq + ourKing,
                        type: 'check'
                    });
                }
            }
        }
    }
    
    return forcingMoves;
}

/**
 * v40.20 KING WEAKENING PENALTY: NEVER weaken king under attack
 * From game analysis: Bot played f3 and g3 weakening king catastrophically
 */
function v40KingWeakeningPenaltyEval(fen, move, board, activeColor, moveNumber) {
    if (!CONFIG.v40KingWeakeningEnabled) return 0;
    
    let score = 0;
    const isWhite = activeColor === 'w';
    
    try {
        const fromSquare = move.substring(0, 2);
        const toSquare = move.substring(2, 4);
        const movingPiece = board.get(fromSquare);
        
        if (!movingPiece) return 0;
        
        const ourKing = findKing(board, activeColor);
        if (!ourKing) return 0;
        
        const kingFile = ourKing.charCodeAt(0) - 'a'.charCodeAt(0);
        
        // Check if we're moving a kingside pawn when castled kingside
        if (movingPiece.toLowerCase() === 'p') {
            const fromFile = fromSquare.charCodeAt(0) - 'a'.charCodeAt(0);
            
            // Are we moving a pawn near our king?
            if (Math.abs(fromFile - kingFile) <= 2) {
                // Check if we're under pressure
                const underPressure = isKingsideUnderPressureV40_20(board, activeColor);
                
                if (underPressure) {
                    // CRITICAL: Moving kingside pawn when under pressure
                    if (fromFile === kingFile + 1 || fromFile === kingFile + 2) {
                        // f-pawn or g-pawn (assuming kingside castle)
                        score += CONFIG.v40F3G3WeakeningPenalty;
                        debugLog(\"[V40.20_WEAK]\", `☠️☠️☠️ ${move} WEAKENS KING while under attack! FORBIDDEN!`);
                    }
                    
                    // Any pawn move near king when attacked
                    score += CONFIG.v40KingPawnMoveUnderAttackPenalty;
                    debugLog(\"[V40.20_WEAK]\", `☠️☠️ ${move} moves kingside pawn while under pressure!`);
                }
            }
        }
        
        // Check if we're advancing kingside pawns in general when pressured
        if (movingPiece.toLowerCase() === 'p') {
            const toRank = parseInt(toSquare[1]);
            const fromRank = parseInt(fromSquare[1]);
            const isAdvancing = isWhite ? toRank > fromRank : toRank < fromRank;
            
            if (isAdvancing && Math.abs(fromSquare.charCodeAt(0) - 'a'.charCodeAt(0) - kingFile) <= 2) {
                const hasHeavyPiecesPressuring = hasEnemyHeavyPiecesPressuring(board, activeColor);
                if (hasHeavyPiecesPressuring) {
                    score += CONFIG.v40KingsidePawnAdvanceUnderPressurePenalty;
                    debugLog(\"[V40.20_WEAK]\", `⚠️ ${move} advances kingside pawn with heavy pieces pressuring!`);
                }
            }
        }
        
    } catch (e) {
        debugLog(\"[V40.20_WEAK]\", `Error: ${e.message}`);
    }
    
    return score;
}

/**
 * v40.20 Helper: Is kingside under pressure?
 */
function isKingsideUnderPressureV40_20(board, activeColor) {
    const isWhite = activeColor === 'w';
    const enemyColor = isWhite ? 'b' : 'w';
    const ourKing = findKing(board, activeColor);
    
    if (!ourKing) return false;
    
    const kingFile = ourKing.charCodeAt(0) - 'a'.charCodeAt(0);
    const kingRank = parseInt(ourKing[1]);
    
    // Count enemy pieces attacking squares near our king
    let attackingPieces = 0;
    
    for (let df = -2; df <= 2; df++) {
        for (let dr = -2; dr <= 2; dr++) {
            const checkFile = kingFile + df;
            const checkRank = kingRank + dr;
            
            if (checkFile < 0 || checkFile > 7) continue;
            if (checkRank < 1 || checkRank > 8) continue;
            
            const checkSquare = String.fromCharCode(checkFile + 'a'.charCodeAt(0)) + checkRank;
            
            if (isSquareAttackedByColor(board, checkSquare, enemyColor)) {
                attackingPieces++;
            }
        }
    }
    
    return attackingPieces >= 3; // Under pressure if 3+ squares attacked
}

/**
 * v40.20 Helper: Has enemy heavy pieces pressuring our king?
 */
function hasEnemyHeavyPiecesPressuring(board, activeColor) {
    const isWhite = activeColor === 'w';
    const enemyColor = isWhite ? 'b' : 'w';
    const ourKing = findKing(board, activeColor);
    
    if (!ourKing) return false;
    
    const kingFile = ourKing.charCodeAt(0) - 'a'.charCodeAt(0);
    const kingRank = parseInt(ourKing[1]);
    
    let heavyPiecesNearby = 0;
    
    for (const [sq, piece] of board) {
        if (!piece) continue;
        const pieceIsWhite = piece === piece.toUpperCase();
        if (pieceIsWhite === isWhite) continue; // Skip our pieces
        
        const pieceType = piece.toLowerCase();
        if (pieceType !== 'r' && pieceType !== 'q') continue; // Only heavy pieces
        
        const pieceFile = sq.charCodeAt(0) - 'a'.charCodeAt(0);
        const pieceRank = parseInt(sq[1]);
        
        // Is this heavy piece close to our king?
        if (Math.abs(pieceFile - kingFile) <= 3 && Math.abs(pieceRank - kingRank) <= 3) {
            heavyPiecesNearby++;
        }
    }
    
    return heavyPiecesNearby >= 1;
}

/**
 * v40.20 PIECE SAFETY ABSOLUTE: Never allow pieces to become hanging
 * From game analysis: Bot put bishop on d3 where c4 could attack it
 */
function v40PieceSafetyAbsoluteEval(fen, move, board, activeColor, moveNumber) {
    if (!CONFIG.v40PieceSafetyAbsoluteEnabled) return 0;
    
    let score = 0;
    const isWhite = activeColor === 'w';
    const enemyColor = isWhite ? 'b' : 'w';
    
    try {
        const fromSquare = move.substring(0, 2);
        const toSquare = move.substring(2, 4);
        const movingPiece = board.get(fromSquare);
        
        if (!movingPiece) return 0;
        
        const movingPieceType = movingPiece.toLowerCase();
        const movingPieceValue = getPieceValueSimple(movingPieceType);
        
        // Simulate our move
        const afterMove = new Map(board);
        afterMove.delete(fromSquare);
        afterMove.set(toSquare, movingPiece);
        
        // CHECK: Can a pawn attack our piece after we move?
        // This catches bishop on d3 being attacked by c4
        if (movingPieceType === 'b' || movingPieceType === 'n' || movingPieceType === 'r' || movingPieceType === 'q') {
            const toFile = toSquare.charCodeAt(0) - 'a'.charCodeAt(0);
            const toRank = parseInt(toSquare[1]);
            
            // Check for pawn attacks
            const pawnAttackRank = isWhite ? toRank + 1 : toRank - 1;
            for (const df of [-1, 1]) {
                const pawnFile = toFile + df;
                if (pawnFile < 0 || pawnFile > 7) continue;
                
                // Where could an enemy pawn come FROM to attack us?
                const pawnStartRank = isWhite ? toRank + 2 : toRank - 2;
                const pawnStartSquare = String.fromCharCode(pawnFile + 'a'.charCodeAt(0)) + pawnStartRank;
                
                // Can an enemy pawn advance to attack us?
                const enemyPawnChar = enemyColor === 'w' ? 'P' : 'p';
                if (afterMove.get(pawnStartSquare) === enemyPawnChar) {
                    const pawnMoveSquare = String.fromCharCode(pawnFile + 'a'.charCodeAt(0)) + (isWhite ? toRank + 1 : toRank - 1);
                    if (!afterMove.get(pawnMoveSquare)) {
                        // Enemy pawn can advance and attack us!
                        score += CONFIG.v40BishopHangingAfterMovePenalty;
                        debugLog(\"[V40.20_SAFE]\", `⚠️ ${move} allows enemy pawn to attack ${movingPiece} with ${pawnStartSquare}-${pawnMoveSquare}!`);
                    }
                }
                
                // Is there already a pawn that can capture us?
                const attackingPawnSquare = String.fromCharCode(pawnFile + 'a'.charCodeAt(0)) + pawnAttackRank;
                if (afterMove.get(attackingPawnSquare) === enemyPawnChar) {
                    // Pawn can immediately capture!
                    if (!isSquareDefendedByColor(afterMove, toSquare, activeColor)) {
                        score += CONFIG.v40PawnTakesBishopPenalty;
                        debugLog(\"[V40.20_SAFE]\", `☠️ ${move} puts ${movingPiece} where pawn can take it!`);
                    }
                }
            }
        }
        
    } catch (e) {
        debugLog(\"[V40.20_SAFE]\", `Error: ${e.message}`);
    }
    
    return score;
}

// ═══════════════════════════════════════════════════════════════════════════════

/**
 * v40.9 Helper: Find all attacked pieces for a color
 */
function findAttackedPiecesV40_9(board, color) {"
Observation: Edit was successful.