Syntax is correct. Now, based on the game analysis in the problem statement, the bot is still losing. Let me analyze the most recent game and implement further enhancements. The game shows:

```
[White "AlphaZero"]
[Black "lichess AI level 8"]
1. e4 e5 2. d3 Nc6 3. Nf3 Nf6 4. Nc3 d5 5. Be2 Be7 6. exd5 Nxd5 7. O-O O-O 
8. d4 exd4 9. Nxd4 Nxc3 10. bxc3 Ne5 11. Rb1 h6 12. Nf3 Ng6 
13. Be3 b6 14. Nd4 c5 15. Nc6 Qc7 16. Nxe7+ Qxe7 17. a3 Rd8 
18. Qc1 Nh4 19. Bd3 c4 20. f3 cxd3 21. g3 dxc2 22. gxh4 cxb1=R 
23. Bg5 Qc5+ 24. Qe3 hxg5 25. c4 Qxe3+ 26. Kh1 Rxf1+ 27. Kg2 Qxf3#
```

The critical issues are:
1. Move 19 (Bd3) - putting bishop where c4 attacks it
2. Move 20 (f3) and 21 (g3) - weakening kingside catastrophically
3. Missing the entire c4-cxd3-dxc2-cxb1=R promotion sequence

I need to add **even stronger** promotion detection and **DEEPER FORCING LINE CALCULATION**. Let me implement v40.21:
Action: file_editor view /app/Lichess Bot-AlphaZero-Pure.user.js
Observation: /app/Lichess Bot-AlphaZero-Pure.user.js:
1760|    v40KingsidePawnAdvanceUnderPressurePenalty: -400000000, // Advancing kingside pawns when pressured
1761|    
1762|    // v40.20: PIECE SAFETY ABSOLUTE — Never allow free takes
1763|    v40PieceSafetyAbsoluteEnabled: true,
1764|    v40BishopHangingAfterMovePenalty: -300000000,   // Bishop becomes hanging after our move
1765|    v40PawnTakesBishopPenalty: -500000000,          // Opponent pawn can take our bishop
1766|    v40TacticalSequenceMissedPenalty: -800000000,   // We missed a tactical sequence
1767|};
1768|
1769|// ═══════════════════════════════════════════════════════════════════════
1770|// v37.0.0: TRANSCENDENT MCTS TREE STRUCTURE
1771|// ═══════════════════════════════════════════════════════════════════════
1772|
1773|/**
1774| * v37: TRUE MCTS Node structure for proper tree search
1775| */
1776|class MCTSNode {
1777|    constructor(move, parent = null, prior = 1.0) {
1778|        this.move = move;
1779|        this.parent = parent;
1780|        this.children = new Map();
1781|        this.visits = 0;
1782|        this.totalValue = 0;
1783|        this.prior = prior;           // Policy prior (P)
1784|        this.virtualLoss = 0;
1785|        this.isExpanded = false;
1786|        this.isTerminal = false;
1787|        this.depth = parent ? parent.depth + 1 : 0;
1788|    }
1789|    
1790|    get value() {
1791|        return this.visits > 0 ? this.totalValue / this.visits : 0;
1792|    }
1793|    
1794|    get ucb1Score() {
1795|        if (!this.parent || this.parent.visits === 0) return Infinity;
1796|        
1797|        const exploitation = this.value;
1798|        const exploration = CONFIG.v37MCTSExplorationConstant * 
1799|            Math.sqrt(Math.log(this.parent.visits) / (this.visits + 1));
1800|        
1801|        return exploitation + exploration;
1802|    }
1803|    
1804|    get puctScore() {
1805|        if (!this.parent || this.parent.visits === 0) return Infinity;
1806|        
1807|        const Q = this.value;
1808|        const U = CONFIG.v37MCTSPUCTConstant * this.prior * 
1809|            Math.sqrt(this.parent.visits) / (1 + this.visits);
1810|        
1811|        // Apply virtual loss for diversity
1812|        const virtualLossAdjustment = this.virtualLoss * CONFIG.v37MCTSVirtualLoss / (this.visits + 1);
1813|        
1814|        return Q + U - virtualLossAdjustment;
1815|    }
1816|    
1817|    selectChild() {
1818|        if (this.children.size === 0) return null;
1819|        
1820|        let bestChild = null;
