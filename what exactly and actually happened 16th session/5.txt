Now I understand the current state. The game analysis shows that despite v40.5 having queen infiltration detection, hanging piece detection, etc., the bot still lost badly. The key issues from the analyzed game are:

1. **Move 4 (Ne5)** - This hung the d4 pawn. The bot didn't see that after dxe4, the d4 pawn was undefended.
2. **Move 5 (Bf4)** - Allowed Qxd4 taking the hanging pawn
3. **Then Qxb2** - Queen raid that wasn't prevented

The problem is likely that the **CENTER PAWN PROTECTION** and **PAWN TENSION RESOLUTION** mechanisms are weak or missing. Let me implement v40.6 enhancements:
Action: file_editor view /app/Lichess Bot-AlphaZero-Pure.user.js
Observation: /app/Lichess Bot-AlphaZero-Pure.user.js:
6956|// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
6957|// v40.5: CRITICAL TACTICAL BLINDSPOT FIXES
6958|// From analysis of Nimzowitsch Defense loss: Qxb2 infiltration, Bxb3 hanging rook,
6959|// Queen+Bishop coordination mate on h1/h2
6960|// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
6961|
6962|/**
6963| * v40.5: QUEEN INFILTRATION DETECTION
6964| * Prevents allowing enemy queen to infiltrate into our position like Qxb2
6965| */
6966|function v40QueenInfiltrationDetection(fen, move, board, activeColor) {
6967|    if (!CONFIG.v40QueenInfiltrationEnabled) return 0;
6968|    
6969|    let penalty = 0;
6970|    const enemyColor = activeColor === 'w' ? 'b' : 'w';
6971|    const isWhite = activeColor === 'w';
6972|    
6973|    try {
6974|        // Simulate the move
6975|        const simBoard = new Map(board);
6976|        const fromSquare = move.substring(0, 2);
6977|        const toSquare = move.substring(2, 4);
6978|        const movingPiece = board.get(fromSquare);
6979|        
6980|        if (movingPiece) {
6981|            simBoard.delete(fromSquare);
6982|            simBoard.set(toSquare, movingPiece);
6983|        }
6984|        
6985|        // Find enemy queen
6986|        let enemyQueen = null;
6987|        for (const [square, piece] of simBoard) {
6988|            if (!piece) continue;
6989|            const isEnemy = (piece === piece.toUpperCase()) === (enemyColor === 'w');
6990|            if (isEnemy && piece.toLowerCase() === 'q') {
6991|                enemyQueen = square;
6992|                break;
6993|            }
6994|        }
6995|        
6996|        if (!enemyQueen) return 0;
6997|        
6998|        const queenFile = enemyQueen.charCodeAt(0) - 'a'.charCodeAt(0);
6999|        const queenRank = parseInt(enemyQueen[1]) - 1;
7000|        
7001|        // CHECK 1: Queen in our half of the board (infiltration)
7002|        const inOurHalf = isWhite ? (queenRank <= 3) : (queenRank >= 4);
7003|        if (inOurHalf) {
7004|            penalty -= CONFIG.v40QueenInfiltrationPenalty || -18000;
7005|            debugLog("[V40_QINFIL]", `ğŸš¨ ENEMY QUEEN INFILTRATED to ${enemyQueen}!`);
7006|            
7007|            // Extra penalty if queen is on our back rank
7008|            const ourBackRank = isWhite ? 0 : 7;
7009|            if (queenRank === ourBackRank || queenRank === ourBackRank + (isWhite ? 1 : -1)) {
7010|                penalty -= 10000;
7011|                debugLog("[V40_QINFIL]", `ğŸš¨ğŸš¨ QUEEN ON BACK RANKS!`);
7012|            }
7013|        }
7014|        
7015|        // CHECK 2: Queen on b-file attacking b2/b7 (classic infiltration square)
7016|        if (queenFile === 1) {  // b-file
7017|            const infiltrationSquare = isWhite ? 'b2' : 'b7';
7018|            if (enemyQueen === infiltrationSquare) {
7019|                penalty -= CONFIG.v40AllowQueenInvasionPenalty || -25000;
7020|                debugLog("[V40_QINFIL]", `ğŸš¨ğŸš¨ğŸš¨ QUEEN ON ${infiltrationSquare} - DISASTER!`);
7021|            }
7022|        }
7023|        
7024|        // CHECK 3: Queen threatening our rook positions
7025|        const ourRooks = [];
7026|        for (const [square, piece] of simBoard) {
7027|            if (!piece) continue;
7028|            const isOurs = (piece === piece.toUpperCase()) === (activeColor === 'w');
7029|            if (isOurs && piece.toLowerCase() === 'r') {
7030|                ourRooks.push(square);
7031|            }
7032|        }
7033|        
7034|        for (const rookSq of ourRooks) {
7035|            if (canQueenAttackSquare(enemyQueen, rookSq, simBoard)) {
7036|                penalty -= 8000;
7037|                debugLog("[V40_QINFIL]", `âš ï¸ Queen can attack rook on ${rookSq}`);
7038|            }
7039|        }
7040|        
7041|        // CHECK 4: Queen near our king
7042|        const ourKing = findKing(simBoard, activeColor);
7043|        if (ourKing) {
7044|            const kingFile = ourKing.charCodeAt(0) - 'a'.charCodeAt(0);
7045|            const kingRank = parseInt(ourKing[1]) - 1;
7046|            
7047|            if (Math.abs(queenFile - kingFile) <= 2 && Math.abs(queenRank - kingRank) <= 2) {
7048|                penalty -= CONFIG.v40QueenNearKingPenalty || -12000;
7049|                debugLog("[V40_QINFIL]", `ğŸš¨ ENEMY QUEEN NEAR KING!`);
7050|            }
7051|        }
7052|        
7053|    } catch (e) {
7054|        debugLog("[V40_QINFIL]", `Error: ${e.message}`);
7055|    }
7056|    
7057|    return penalty;
7058|}
7059|
7060|/**
7061| * v40.5: Helper - Check if queen can attack a square
7062| */
7063|function canQueenAttackSquare(queenSq, targetSq, board) {
7064|    if (queenSq === targetSq) return false;
7065|    
7066|    const qFile = queenSq.charCodeAt(0) - 'a'.charCodeAt(0);
7067|    const qRank = parseInt(queenSq[1]) - 1;
7068|    const tFile = targetSq.charCodeAt(0) - 'a'.charCodeAt(0);
7069|    const tRank = parseInt(targetSq[1]) - 1;
7070|    
7071|    const fileDiff = tFile - qFile;
7072|    const rankDiff = tRank - qRank;
7073|    
7074|    // Queen moves like rook or bishop
7075|    const isRookMove = fileDiff === 0 || rankDiff === 0;
7076|    const isBishopMove = Math.abs(fileDiff) === Math.abs(rankDiff);
7077|    
7078|    if (!isRookMove && !isBishopMove) return false;
7079|    
7080|    // Check path is clear
7081|    const dx = fileDiff === 0 ? 0 : (fileDiff > 0 ? 1 : -1);
7082|    const dy = rankDiff === 0 ? 0 : (rankDiff > 0 ? 1 : -1);
7083|    
7084|    let x = qFile + dx;
7085|    let y = qRank + dy;
7086|    
7087|    while (x !== tFile || y !== tRank) {
7088|        const sq = String.fromCharCode(x + 97) + (y + 1);
7089|        if (board.get(sq)) return false;
7090|        x += dx;
7091|        y += dy;
7092|    }
7093|    
7094|    return true;
7095|}
7096|
7097|/**
7098| * v40.5: ENHANCED HANGING PIECE DETECTION
7099| * Prevents leaving pieces undefended like the rook on b3 taken by Bxb3
7100| */
