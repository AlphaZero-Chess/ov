I found a good location (around line 7621, after the v40.5 helper functions). Now let me implement v40.6 ULTIMATE enhancements that address the core issues from the game analysis:
Action: file_editor str_replace /app/Lichess Bot-AlphaZero-Pure.user.js --old-str "    return squares;
}

/**
 * v40: Evaluate goal alignment with strategic plan
 * True AlphaZero evaluates moves based on how well they fit the plan
 */
function evaluateGoalAlignment(move, plan) {" --new-str "    return squares;
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// v40.6 ULTIMATE: CRITICAL CENTER & TACTICAL BLINDSPOT FIXES
// From analysis of Nimzowitsch Defense: Ne5 hung d4, then Qxd4, Qxb2 queen raid
// ADDRESSES: Center pawn protection, pawn tension resolution, queen raid prevention
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

/**
 * v40.6 ULTIMATE: CENTER PAWN PROTECTION
 * CRITICAL: Prevents hanging center pawns (d4/d5/e4/e5 must be protected!)
 * In the Nimzowitsch Defense, Ne5 hung the d4 pawn - this must NEVER happen again
 */
function v40CenterPawnProtection(fen, move, board, activeColor) {
    if (!CONFIG.v40CenterPawnProtectionEnabled) return 0;
    
    let penalty = 0;
    const isWhite = activeColor === 'w';
    
    try {
        // Simulate the move
        const simBoard = new Map(board);
        const fromSquare = move.substring(0, 2);
        const toSquare = move.substring(2, 4);
        const movingPiece = board.get(fromSquare);
        
        if (movingPiece) {
            simBoard.delete(fromSquare);
            simBoard.set(toSquare, movingPiece);
        }
        
        // CHECK ALL CENTER PAWNS (d4, d5, e4, e5 are critical)
        const centerSquares = ['d4', 'd5', 'e4', 'e5'];
        const extendedCenter = ['c3', 'c4', 'c5', 'c6', 'd3', 'd6', 'e3', 'e6', 'f3', 'f4', 'f5', 'f6'];
        
        for (const sq of centerSquares) {
            const piece = simBoard.get(sq);
            if (!piece || piece.toLowerCase() !== 'p') continue;
            
            const pieceIsWhite = piece === 'P';
            if (pieceIsWhite !== isWhite) continue;  // Only check our pawns
            
            // Check if this pawn is defended
            const isDefended = isSquareDefended(simBoard, sq, activeColor);
            
            // Check if this pawn is attacked
            const isAttacked = isSquareAttacked(simBoard, sq, activeColor === 'w' ? 'b' : 'w');
            
            if (isAttacked && !isDefended) {
                // CRITICAL: Hanging center pawn!
                penalty -= CONFIG.v40HangingCenterPawnPenalty || -30000;
                debugLog(\"[V40_CENTER]\", `üö®üö®üö® HANGING CENTER PAWN ON ${sq}! CRITICAL TACTICAL BLUNDER!`);
            } else if (isAttacked && isDefended) {
                // Check if we're being traded down disadvantageously
                const attackerValue = getLowestAttackerValue(simBoard, sq, activeColor === 'w' ? 'b' : 'w');
                if (attackerValue < 100) {  // Pawn attacking pawn
                    penalty -= CONFIG.v40CenterPawnTensionPenalty || -5000;
                    debugLog(\"[V40_CENTER]\", `‚ö†Ô∏è Center pawn tension on ${sq} - should resolve!`);
                }
            }
        }
        
        // Also check extended center pawns with reduced penalty
        for (const sq of extendedCenter) {
            const piece = simBoard.get(sq);
            if (!piece || piece.toLowerCase() !== 'p') continue;
            
            const pieceIsWhite = piece === 'P';
            if (pieceIsWhite !== isWhite) continue;
            
            const isDefended = isSquareDefended(simBoard, sq, activeColor);
            const isAttacked = isSquareAttacked(simBoard, sq, activeColor === 'w' ? 'b' : 'w');
            
            if (isAttacked && !isDefended) {
                penalty -= CONFIG.v40HangingExtendedCenterPenalty || -15000;
                debugLog(\"[V40_CENTER]\", `üö® HANGING EXTENDED CENTER PAWN ON ${sq}!`);
            }
        }
        
    } catch (e) {
        debugLog(\"[V40_CENTER]\", `Error: ${e.message}`);
    }
    
    return penalty;
}

/**
 * v40.6 ULTIMATE: PAWN TENSION RESOLUTION
 * CRITICAL: When pawn is taken, we must recapture or defend IMMEDIATELY
 * After dxe4, the bot should have recaptured or defended d4!
 */
function v40PawnTensionResolution(fen, move, board, activeColor, lastMove) {
    if (!CONFIG.v40PawnTensionEnabled) return 0;
    
    let bonus = 0;
    let penalty = 0;
    const isWhite = activeColor === 'w';
    
    try {
        // If last move was a pawn capture, we MUST respond to the tension
        if (lastMove && lastMove.length >= 4) {
            const enemyFromSquare = lastMove.substring(0, 2);
            const enemyToSquare = lastMove.substring(2, 4);
            
            // Did enemy take one of our pawns?
            const pawnWasTaken = checkIfPawnWasTaken(board, enemyToSquare, activeColor);
            
            if (pawnWasTaken) {
                // Check if our move recaptures
                const ourToSquare = move.substring(2, 4);
                
                if (ourToSquare === enemyToSquare) {
                    // We are recapturing! GOOD!
                    bonus += CONFIG.v40RecapturePriorityBonus || 10000;
                    debugLog(\"[V40_TENSION]\", `‚úÖ RECAPTURING on ${enemyToSquare} - EXCELLENT!`);
                } else {
                    // Check if there's a pawn still hanging after this move
                    const simBoard = new Map(board);
                    const fromSquare = move.substring(0, 2);
                    const toSquare = move.substring(2, 4);
                    const movingPiece = board.get(fromSquare);
                    
                    if (movingPiece) {
                        simBoard.delete(fromSquare);
                        simBoard.set(toSquare, movingPiece);
                    }
                    
                    // Check center pawns for hanging after our move
                    const criticalPawns = ['d4', 'd5', 'e4', 'e5'];
                    for (const sq of criticalPawns) {
                        const piece = simBoard.get(sq);
                        if (!piece || piece.toLowerCase() !== 'p') continue;
                        
                        const pieceIsWhite = piece === 'P';
                        if (pieceIsWhite !== isWhite) continue;
                        
                        const isDefended = isSquareDefended(simBoard, sq, activeColor);
                        const isAttacked = isSquareAttacked(simBoard, sq, activeColor === 'w' ? 'b' : 'w');
                        
                        if (isAttacked && !isDefended) {
                            penalty -= CONFIG.v40UnresolvedTensionPenalty || -20000;
                            debugLog(\"[V40_TENSION]\", `üö® UNRESOLVED TENSION! ${sq} is still hanging!`);
                        }
                    }
                }
            }
        }
        
        // Also check if our move creates hanging pawns
        const simBoard = new Map(board);
        const fromSquare = move.substring(0, 2);
        const toSquare = move.substring(2, 4);
        const movingPiece = board.get(fromSquare);
        
        if (movingPiece) {
            simBoard.delete(fromSquare);
            simBoard.set(toSquare, movingPiece);
        }
        
        // If we moved a defender, check if any pawn is now hanging
        if (movingPiece && movingPiece.toLowerCase() !== 'p') {
            const criticalPawns = ['d4', 'd5', 'e4', 'e5', 'c3', 'c4', 'c5', 'c6'];
            for (const sq of criticalPawns) {
                const piece = simBoard.get(sq);
                if (!piece || piece.toLowerCase() !== 'p') continue;
                
                const pieceIsWhite = piece === 'P';
                if (pieceIsWhite !== isWhite) continue;
                
                // Was this pawn defended by the piece we moved?
                const wasDefendedByMover = wasSquareDefendedByPiece(board, sq, fromSquare, movingPiece);
                if (wasDefendedByMover) {
                    const stillDefended = isSquareDefended(simBoard, sq, activeColor);
                    const isAttacked = isSquareAttacked(simBoard, sq, activeColor === 'w' ? 'b' : 'w');
                    
                    if (!stillDefended && isAttacked) {
                        penalty -= CONFIG.v40AbandonedPawnPenalty || -25000;
                        debugLog(\"[V40_TENSION]\", `üö®üö® ABANDONED PAWN! Moving ${movingPiece} left ${sq} hanging!`);
                    }
                }
            }
        }
        
    } catch (e) {
        debugLog(\"[V40_TENSION]\", `Error: ${e.message}`);
    }
    
    return bonus + penalty;
}

/**
 * v40.6 ULTIMATE: QUEEN RAID PREVENTION
 * CRITICAL: Prevent enemy queen from invading to capture material
 * After Qxd4, the bot allowed Qxb2 - this queen raid must be prevented!
 */
function v40QueenRaidPrevention(fen, move, board, activeColor) {
    if (!CONFIG.v40QueenRaidPreventionEnabled) return 0;
    
    let penalty = 0;
    const isWhite = activeColor === 'w';
    const enemyColor = isWhite ? 'b' : 'w';
    
    try {
        // Simulate the move
        const simBoard = new Map(board);
        const fromSquare = move.substring(0, 2);
        const toSquare = move.substring(2, 4);
        const movingPiece = board.get(fromSquare);
        
        if (movingPiece) {
            simBoard.delete(fromSquare);
            simBoard.set(toSquare, movingPiece);
        }
        
        // Find enemy queen
        let enemyQueen = null;
        for (const [square, piece] of simBoard) {
            if (!piece) continue;
            const isEnemy = (piece === piece.toUpperCase()) === (enemyColor === 'w');
            if (isEnemy && piece.toLowerCase() === 'q') {
                enemyQueen = square;
                break;
            }
        }
        
        if (!enemyQueen) return 0;
        
        // KEY RAID TARGETS: b2, b7, d4, d5, f2, f7, g2, g7 (undefended pawns queen can raid)
        const raidTargets = isWhite 
            ? ['b2', 'd4', 'f2', 'g2', 'a2', 'c2', 'h2']  // Targets for white
            : ['b7', 'd5', 'f7', 'g7', 'a7', 'c7', 'h7']; // Targets for black
        
        for (const target of raidTargets) {
            const piece = simBoard.get(target);
            if (!piece) continue;  // No piece to raid
            
            const pieceIsWhite = piece === piece.toUpperCase();
            if (pieceIsWhite !== isWhite) continue;  // Only check our pieces
            
            // Can queen reach this target?
            if (canQueenAttackSquare(enemyQueen, target, simBoard)) {
                // Is target defended?
                const isDefended = isSquareDefended(simBoard, target, activeColor);
                
                if (!isDefended) {
                    // RAID POSSIBLE!
                    const pieceValue = getSimplePieceValue(piece);
                    if (piece.toLowerCase() === 'p') {
                        penalty -= CONFIG.v40QueenRaidPawnPenalty || -20000;
                        debugLog(\"[V40_RAID]\", `üö®üö® QUEEN CAN RAID PAWN ON ${target}!`);
                    } else if (piece.toLowerCase() === 'r') {
                        penalty -= CONFIG.v40QueenRaidRookPenalty || -35000;
                        debugLog(\"[V40_RAID]\", `üö®üö®üö® QUEEN CAN RAID ROOK ON ${target}!`);
                    } else {
                        penalty -= CONFIG.v40QueenRaidMinorPenalty || -25000;
                        debugLog(\"[V40_RAID]\", `üö®üö® QUEEN CAN RAID PIECE ON ${target}!`);
                    }
                } else if (piece.toLowerCase() === 'p') {
                    // Defended pawn, but queen raid still disruptive
                    penalty -= 3000;
                    debugLog(\"[V40_RAID]\", `‚ö†Ô∏è Queen can attack defended pawn on ${target}`);
                }
            }
        }
        
        // SPECIAL CHECK: Queen can take pawn with check or threat
        // Find our king
        const ourKing = findKing(simBoard, activeColor);
        if (ourKing) {
            // Check if queen raid would give check or attack near king
            for (const target of raidTargets) {
                const piece = simBoard.get(target);
                if (!piece || piece.toLowerCase() !== 'p') continue;
                
                const pieceIsWhite = piece === piece.toUpperCase();
                if (pieceIsWhite !== isWhite) continue;
                
                if (canQueenAttackSquare(enemyQueen, target, simBoard)) {
                    // Would queen on target threaten king?
                    if (canQueenAttackSquare(target, ourKing, simBoard)) {
                        penalty -= CONFIG.v40QueenRaidWithThreatPenalty || -40000;
                        debugLog(\"[V40_RAID]\", `üö®üö®üö® QUEEN RAID ON ${target} THREATENS KING!`);
                    }
                }
            }
        }
        
    } catch (e) {
        debugLog(\"[V40_RAID]\", `Error: ${e.message}`);
    }
    
    return penalty;
}

/**
 * v40.6 ULTIMATE: TACTICAL PRIORITY OVERRIDE
 * CRITICAL: When tactics demand attention, override positional considerations
 * Pure positional play when tactics are bad = disaster
 */
function v40TacticalPriorityOverride(fen, move, board, activeColor, moveNumber) {
    if (!CONFIG.v40TacticalPriorityEnabled) return 0;
    
    let bonus = 0;
    let penalty = 0;
    const isWhite = activeColor === 'w';
    
    try {
        // In the opening (first 15 moves), tactics are CRITICAL
        const isOpening = moveNumber <= 15;
        const multiplier = isOpening ? 1.5 : 1.0;
        
        // Simulate the move
        const simBoard = new Map(board);
        const fromSquare = move.substring(0, 2);
        const toSquare = move.substring(2, 4);
        const movingPiece = board.get(fromSquare);
        
        if (movingPiece) {
            simBoard.delete(fromSquare);
            simBoard.set(toSquare, movingPiece);
        }
        
        // CHECK 1: Does our move leave a piece hanging?
        const hangingPieces = findHangingPieces(simBoard, activeColor);
        if (hangingPieces.length > 0) {
            for (const hp of hangingPieces) {
                const val = getSimplePieceValue(hp.piece);
                penalty -= val * 20 * multiplier;
                debugLog(\"[V40_TACTICAL]\", `üö® HANGING ${hp.piece} ON ${hp.square}! Penalty: ${val * 20 * multiplier}`);
            }
        }
        
        // CHECK 2: Does our move protect hanging pieces?
        const beforeHanging = findHangingPieces(board, activeColor);
        const afterHanging = findHangingPieces(simBoard, activeColor);
        
        const piecesProtected = beforeHanging.length - afterHanging.length;
        if (piecesProtected > 0) {
            bonus += piecesProtected * 8000 * multiplier;
            debugLog(\"[V40_TACTICAL]\", `‚úÖ PROTECTED ${piecesProtected} hanging piece(s)!`);
        }
        
        // CHECK 3: Does our move threaten enemy pieces?
        const threatsCreated = countThreatsAfterMove(simBoard, activeColor);
        if (threatsCreated > 0) {
            bonus += threatsCreated * 3000 * multiplier;
            debugLog(\"[V40_TACTICAL]\", `‚úÖ Created ${threatsCreated} new threat(s)!`);
        }
        
        // CHECK 4: In opening, prioritize center control
        if (isOpening) {
            const centerControl = evaluateCenterControlAfterMove(simBoard, activeColor);
            bonus += centerControl * 2000;
            debugLog(\"[V40_TACTICAL]\", `Opening center control: ${centerControl}`);
        }
        
        // CHECK 5: Are we capturing material?
        const capturedPiece = board.get(toSquare);
        if (capturedPiece) {
            const captureValue = getSimplePieceValue(capturedPiece);
            
            // Make sure it's an enemy piece
            const capturedIsWhite = capturedPiece === capturedPiece.toUpperCase();
            if (capturedIsWhite !== isWhite) {
                bonus += captureValue * 15 * multiplier;
                debugLog(\"[V40_TACTICAL]\", `‚úÖ CAPTURING ${capturedPiece}! Value: ${captureValue}`);
            }
        }
        
    } catch (e) {
        debugLog(\"[V40_TACTICAL]\", `Error: ${e.message}`);
    }
    
    return bonus + penalty;
}

/**
 * v40.6 ULTIMATE: DEVELOPMENT SAFETY CHECK
 * CRITICAL: In opening, developing moves MUST NOT create tactics
 * Ne5 developed but created a tactical hole!
 */
function v40DevelopmentSafetyCheck(fen, move, board, activeColor, moveNumber) {
    if (!CONFIG.v40DevelopmentSafetyEnabled) return 0;
    if (moveNumber > 20) return 0;  // Only in opening
    
    let penalty = 0;
    const isWhite = activeColor === 'w';
    
    try {
        const fromSquare = move.substring(0, 2);
        const movingPiece = board.get(fromSquare);
        
        if (!movingPiece) return 0;
        
        // Is this a development move?
        const isKnight = movingPiece.toLowerCase() === 'n';
        const isBishop = movingPiece.toLowerCase() === 'b';
        const isQueen = movingPiece.toLowerCase() === 'q';
        
        if (!isKnight && !isBishop && !isQueen) return 0;
        
        // Simulate the move
        const simBoard = new Map(board);
        const toSquare = move.substring(2, 4);
        simBoard.delete(fromSquare);
        simBoard.set(toSquare, movingPiece);
        
        // CHECK: Did we abandon defense of a pawn?
        const criticalPawns = ['d4', 'd5', 'e4', 'e5', 'c4', 'c5'];
        for (const sq of criticalPawns) {
            const piece = simBoard.get(sq);
            if (!piece || piece.toLowerCase() !== 'p') continue;
            
            const pieceIsWhite = piece === 'P';
            if (pieceIsWhite !== isWhite) continue;
            
            // Was this pawn defended before?
            const wasDefended = isSquareDefended(board, sq, activeColor);
            const isNowDefended = isSquareDefended(simBoard, sq, activeColor);
            const isAttacked = isSquareAttacked(simBoard, sq, activeColor === 'w' ? 'b' : 'w');
            
            if (wasDefended && !isNowDefended && isAttacked) {
                penalty -= CONFIG.v40DevelopmentAbandonPawnPenalty || -30000;
                debugLog(\"[V40_DEVSAFE]\", `üö®üö®üö® DEVELOPMENT ${movingPiece} ABANDONS PAWN ON ${sq}!`);
            }
        }
        
        // CHECK: Queen development too early
        if (isQueen && moveNumber <= 8) {
            penalty -= CONFIG.v40EarlyQueenPenalty || -8000;
            debugLog(\"[V40_DEVSAFE]\", `‚ö†Ô∏è Early queen development in move ${moveNumber}`);
        }
        
    } catch (e) {
        debugLog(\"[V40_DEVSAFE]\", `Error: ${e.message}`);
    }
    
    return penalty;
}

/**
 * v40.6 ULTIMATE: IMMEDIATE THREAT RESPONSE
 * CRITICAL: When opponent makes a threat, we MUST respond
 * After dxe4, the threat to d4 was immediate and ignored!
 */
function v40ImmediateThreatResponse(fen, move, board, activeColor, lastMove) {
    if (!CONFIG.v40ImmediateThreatEnabled) return 0;
    
    let bonus = 0;
    let penalty = 0;
    const isWhite = activeColor === 'w';
    
    try {
        if (!lastMove) return 0;
        
        // What did opponent threaten with their move?
        const enemyToSquare = lastMove.substring(2, 4);
        
        // Find pieces threatened by enemy's last move position
        const threatenedPieces = findThreatenedPiecesFrom(board, enemyToSquare, activeColor);
        
        if (threatenedPieces.length === 0) return 0;
        
        // Simulate our move
        const simBoard = new Map(board);
        const fromSquare = move.substring(0, 2);
        const toSquare = move.substring(2, 4);
        const movingPiece = board.get(fromSquare);
        
        if (movingPiece) {
            simBoard.delete(fromSquare);
            simBoard.set(toSquare, movingPiece);
        }
        
        // Check if we addressed the threats
        for (const threat of threatenedPieces) {
            // Option 1: We captured the threatening piece
            if (toSquare === enemyToSquare) {
                bonus += 10000;
                debugLog(\"[V40_THREAT]\", `‚úÖ CAPTURED threatening piece on ${enemyToSquare}!`);
                continue;
            }
            
            // Option 2: We moved the threatened piece
            if (fromSquare === threat.square) {
                bonus += 8000;
                debugLog(\"[V40_THREAT]\", `‚úÖ MOVED threatened ${threat.piece} from ${threat.square}!`);
                continue;
            }
            
            // Option 3: We blocked or defended
            const stillThreatened = isSquareThreatenedFrom(simBoard, threat.square, enemyToSquare, activeColor);
            const nowDefended = isSquareDefended(simBoard, threat.square, activeColor);
            
            if (!stillThreatened || nowDefended) {
                bonus += 6000;
                debugLog(\"[V40_THREAT]\", `‚úÖ DEFENDED ${threat.piece} on ${threat.square}!`);
                continue;
            }
            
            // THREAT NOT ADDRESSED!
            const pieceValue = getSimplePieceValue(threat.piece);
            penalty -= pieceValue * 25;
            debugLog(\"[V40_THREAT]\", `üö® THREAT TO ${threat.piece} ON ${threat.square} NOT ADDRESSED!`);
        }
        
    } catch (e) {
        debugLog(\"[V40_THREAT]\", `Error: ${e.message}`);
    }
    
    return bonus + penalty;
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// v40.6 ULTIMATE: HELPER FUNCTIONS
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

/**
 * v40.6 Helper: Check if a pawn was taken
 */
function checkIfPawnWasTaken(board, square, ourColor) {
    // We need to check if the square had our pawn before
    // This is a simplification - in real implementation, track move history
    return false;  // Placeholder - use move history in actual implementation
}

/**
 * v40.6 Helper: Check if square was defended by a specific piece
 */
function wasSquareDefendedByPiece(board, square, defenderSquare, defenderPiece) {
    if (!defenderPiece) return false;
    
    const defFile = defenderSquare.charCodeAt(0) - 'a'.charCodeAt(0);
    const defRank = parseInt(defenderSquare[1]) - 1;
    const sqFile = square.charCodeAt(0) - 'a'.charCodeAt(0);
    const sqRank = parseInt(square[1]) - 1;
    
    const fileDiff = sqFile - defFile;
    const rankDiff = sqRank - defRank;
    
    const pieceType = defenderPiece.toLowerCase();
    
    switch (pieceType) {
        case 'p':
            // Pawns defend diagonally forward
            const isWhite = defenderPiece === 'P';
            const forwardDir = isWhite ? 1 : -1;
            return Math.abs(fileDiff) === 1 && rankDiff === forwardDir;
        case 'n':
            return (Math.abs(fileDiff) === 2 && Math.abs(rankDiff) === 1) ||
                   (Math.abs(fileDiff) === 1 && Math.abs(rankDiff) === 2);
        case 'b':
            return Math.abs(fileDiff) === Math.abs(rankDiff) && fileDiff !== 0;
        case 'r':
            return (fileDiff === 0 || rankDiff === 0) && (fileDiff !== 0 || rankDiff !== 0);
        case 'q':
            return (fileDiff === 0 || rankDiff === 0 || Math.abs(fileDiff) === Math.abs(rankDiff)) &&
                   (fileDiff !== 0 || rankDiff !== 0);
        case 'k':
            return Math.abs(fileDiff) <= 1 && Math.abs(rankDiff) <= 1 && (fileDiff !== 0 || rankDiff !== 0);
        default:
            return false;
    }
}

/**
 * v40.6 Helper: Find all hanging pieces for a color
 */
function findHangingPieces(board, color) {
    const hanging = [];
    const isWhite = color === 'w';
    const enemyColor = isWhite ? 'b' : 'w';
    
    for (const [square, piece] of board) {
        if (!piece) continue;
        
        const pieceIsWhite = piece === piece.toUpperCase();
        if (pieceIsWhite !== isWhite) continue;
        if (piece.toLowerCase() === 'k') continue;  // King can't be \"hanging\"
        
        const isAttacked = isSquareAttacked(board, square, enemyColor);
        const isDefended = isSquareDefended(board, square, color);
        
        if (isAttacked && !isDefended) {
            hanging.push({ square, piece });
        }
    }
    
    return hanging;
}

/**
 * v40.6 Helper: Count threats after a move
 */
function countThreatsAfterMove(board, color) {
    let threats = 0;
    const enemyColor = color === 'w' ? 'b' : 'w';
    const isEnemyWhite = enemyColor === 'w';
    
    for (const [square, piece] of board) {
        if (!piece) continue;
        
        const pieceIsWhite = piece === piece.toUpperCase();
        if (pieceIsWhite !== isEnemyWhite) continue;
        if (piece.toLowerCase() === 'k') continue;
        
        // Is enemy piece attacked by us and undefended?
        const isAttacked = isSquareAttacked(board, square, color);
        if (isAttacked) {
            const isDefended = isSquareDefended(board, square, enemyColor);
            if (!isDefended) {
                threats++;
            } else {
                // Check if we're winning the exchange
                const ourAttackerValue = getLowestAttackerValue(board, square, color);
                const theirDefenderValue = getLowestAttackerValue(board, square, enemyColor);
                const pieceValue = getSimplePieceValue(piece);
                
                if (ourAttackerValue < pieceValue) {
                    threats += 0.5;  // Partial threat
                }
            }
        }
    }
    
    return Math.floor(threats);
}

/**
 * v40.6 Helper: Evaluate center control after a move
 */
function evaluateCenterControlAfterMove(board, color) {
    const centerSquares = ['d4', 'd5', 'e4', 'e5'];
    const extendedCenter = ['c3', 'c4', 'c5', 'c6', 'd3', 'd6', 'e3', 'e6', 'f3', 'f4', 'f5', 'f6'];
    
    let control = 0;
    const isWhite = color === 'w';
    
    // Full center
    for (const sq of centerSquares) {
        const piece = board.get(sq);
        if (piece) {
            const pieceIsWhite = piece === piece.toUpperCase();
            if (pieceIsWhite === isWhite) {
                control += 2;  // Our piece in center
            } else {
                control -= 1;  // Enemy piece in center
            }
        } else {
            // Empty square - who controls it?
            const weAttack = isSquareAttacked(board, sq, color);
            const theyAttack = isSquareAttacked(board, sq, isWhite ? 'b' : 'w');
            
            if (weAttack && !theyAttack) control += 1;
            else if (!weAttack && theyAttack) control -= 0.5;
        }
    }
    
    // Extended center (less important)
    for (const sq of extendedCenter) {
        const piece = board.get(sq);
        if (piece) {
            const pieceIsWhite = piece === piece.toUpperCase();
            if (pieceIsWhite === isWhite) control += 0.5;
        }
    }
    
    return control;
}

/**
 * v40.6 Helper: Find pieces threatened from a specific square
 */
function findThreatenedPiecesFrom(board, fromSquare, defendingColor) {
    const threatened = [];
    const isWhite = defendingColor === 'w';
    const attackingPiece = board.get(fromSquare);
    
    if (!attackingPiece) return threatened;
    
    for (const [square, piece] of board) {
        if (!piece) continue;
        
        const pieceIsWhite = piece === piece.toUpperCase();
        if (pieceIsWhite !== isWhite) continue;  // Only our pieces
        if (piece.toLowerCase() === 'k') continue;  // King handled separately
        
        // Can the attacker reach this piece?
        if (canPieceAttackSquare(fromSquare, square, attackingPiece, board)) {
            threatened.push({ square, piece });
        }
    }
    
    return threatened;
}

/**
 * v40.6 Helper: Check if square is threatened from specific square
 */
function isSquareThreatenedFrom(board, targetSquare, fromSquare, defendingColor) {
    const attackingPiece = board.get(fromSquare);
    if (!attackingPiece) return false;
    
    return canPieceAttackSquare(fromSquare, targetSquare, attackingPiece, board);
}

/**
 * v40.6 Helper: Check if a square is defended
 */
function isSquareDefended(board, square, color) {
    const isWhite = color === 'w';
    
    for (const [sq, piece] of board) {
        if (!piece || sq === square) continue;
        
        const pieceIsWhite = piece === piece.toUpperCase();
        if (pieceIsWhite !== isWhite) continue;
        
        if (canPieceAttackSquare(sq, square, piece, board)) {
            return true;
        }
    }
    
    return false;
}

/**
 * v40.6 Helper: Check if square is attacked by color
 */
function isSquareAttacked(board, square, attackingColor) {
    const isWhite = attackingColor === 'w';
    
    for (const [sq, piece] of board) {
        if (!piece || sq === square) continue;
        
        const pieceIsWhite = piece === piece.toUpperCase();
        if (pieceIsWhite !== isWhite) continue;
        
        if (canPieceAttackSquare(sq, square, piece, board)) {
            return true;
        }
    }
    
    return false;
}

/**
 * v40.6 Helper: Can piece attack a square
 */
function canPieceAttackSquare(fromSq, toSq, piece, board) {
    if (fromSq === toSq) return false;
    
    const fromFile = fromSq.charCodeAt(0) - 'a'.charCodeAt(0);
    const fromRank = parseInt(fromSq[1]) - 1;
    const toFile = toSq.charCodeAt(0) - 'a'.charCodeAt(0);
    const toRank = parseInt(toSq[1]) - 1;
    
    const fileDiff = toFile - fromFile;
    const rankDiff = toRank - fromRank;
    
    const pieceType = piece.toLowerCase();
    const isWhite = piece === piece.toUpperCase();
    
    switch (pieceType) {
        case 'p':
            // Pawns attack diagonally forward
            const dir = isWhite ? 1 : -1;
            return Math.abs(fileDiff) === 1 && rankDiff === dir;
            
        case 'n':
            return (Math.abs(fileDiff) === 2 && Math.abs(rankDiff) === 1) ||
                   (Math.abs(fileDiff) === 1 && Math.abs(rankDiff) === 2);
            
        case 'b':
            if (Math.abs(fileDiff) !== Math.abs(rankDiff) || fileDiff === 0) return false;
            return isPathClear(fromFile, fromRank, toFile, toRank, board);
            
        case 'r':
            if (fileDiff !== 0 && rankDiff !== 0) return false;
            return isPathClear(fromFile, fromRank, toFile, toRank, board);
            
        case 'q':
            if (fileDiff !== 0 && rankDiff !== 0 && Math.abs(fileDiff) !== Math.abs(rankDiff)) return false;
            return isPathClear(fromFile, fromRank, toFile, toRank, board);
            
        case 'k':
            return Math.abs(fileDiff) <= 1 && Math.abs(rankDiff) <= 1;
            
        default:
            return false;
    }
}

/**
 * v40.6 Helper: Check if path is clear for sliding pieces
 */
function isPathClear(fromFile, fromRank, toFile, toRank, board) {
    const dx = toFile === fromFile ? 0 : (toFile > fromFile ? 1 : -1);
    const dy = toRank === fromRank ? 0 : (toRank > fromRank ? 1 : -1);
    
    let x = fromFile + dx;
    let y = fromRank + dy;
    
    while (x !== toFile || y !== toRank) {
        const sq = String.fromCharCode(x + 97) + (y + 1);
        if (board.get(sq)) return false;
        x += dx;
        y += dy;
    }
    
    return true;
}

/**
 * v40.6 Helper: Get lowest value attacker
 */
function getLowestAttackerValue(board, square, attackingColor) {
    let lowestValue = Infinity;
    const isWhite = attackingColor === 'w';
    
    for (const [sq, piece] of board) {
        if (!piece) continue;
        
        const pieceIsWhite = piece === piece.toUpperCase();
        if (pieceIsWhite !== isWhite) continue;
        
        if (canPieceAttackSquare(sq, square, piece, board)) {
            const value = getSimplePieceValue(piece);
            if (value < lowestValue) lowestValue = value;
        }
    }
    
    return lowestValue === Infinity ? 0 : lowestValue;
}

/**
 * v40.6 Helper: Get simple piece value
 */
function getSimplePieceValue(piece) {
    switch (piece.toLowerCase()) {
        case 'p': return 100;
        case 'n': return 320;
        case 'b': return 330;
        case 'r': return 500;
        case 'q': return 900;
        case 'k': return 20000;
        default: return 0;
    }
}

/**
 * v40: Evaluate goal alignment with strategic plan
 * True AlphaZero evaluates moves based on how well they fit the plan
 */
function evaluateGoalAlignment(move, plan) {"
Observation: Edit was successful.