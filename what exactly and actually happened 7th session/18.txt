
Action: file_editor str_replace /app/Lichess Bot-AlphaZero-Pure.user.js --old-str "    return score;
}

/**
 * v40: Evaluate goal alignment with strategic plan
 * True AlphaZero evaluates moves based on how well they fit the plan
 */
function evaluateGoalAlignment(move, plan) {" --new-str "    return score;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// v40.3.0: ULTIMATE SUPERHUMAN BEAST â€” NEW EVALUATION FUNCTIONS
// These functions implement the critical enhancements for true AlphaZero strength
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/**
 * v40.3: ANTI-PASSIVITY EVALUATION
 * AlphaZero NEVER plays passively. This function severely penalizes passive moves
 * and rewards active, improving moves. Addresses the Qd1-Qd3-Qe4-Qd3 issue.
 */
function v40AntiPassivityEvaluation(fen, move, board, activeColor, moveNumber) {
    if (!CONFIG.v40AntiPassivityEnabled) return 0;
    
    let score = 0;
    const enemyColor = activeColor === 'w' ? 'b' : 'w';
    
    try {
        const fromSquare = move.substring(0, 2);
        const toSquare = move.substring(2, 4);
        const movingPiece = board.get(fromSquare);
        
        if (!movingPiece) return 0;
        
        const pieceType = movingPiece.toLowerCase();
        const fromFile = fromSquare.charCodeAt(0) - 'a'.charCodeAt(0);
        const fromRank = parseInt(fromSquare[1]) - 1;
        const toFile = toSquare.charCodeAt(0) - 'a'.charCodeAt(0);
        const toRank = parseInt(toSquare[1]) - 1;
        
        // Simulate the move
        const simBoard = new Map(board);
        simBoard.delete(fromSquare);
        simBoard.set(toSquare, movingPiece);
        
        // CHECK 1: Is this a backward move? (retreating without threat)
        const isWhite = activeColor === 'w';
        const isBackward = isWhite ? (toRank < fromRank) : (toRank > fromRank);
        
        if (isBackward && pieceType !== 'k') {
            // Check if the backward move creates a threat
            const createsNewThreat = v40MoveCreaetesThreat(move, simBoard, activeColor);
            if (!createsNewThreat) {
                score += CONFIG.v40PassivityPenalty || -8000;
                debugLog(\"[V40_ANTIPASSIVE]\", `ğŸš¨ PASSIVE BACKWARD MOVE: ${move} - no threat created`);
            }
        }
        
        // CHECK 2: Queen passivity check
        if (pieceType === 'q') {
            // Queen should be active in middlegame
            if (moveNumber > 10) {
                const queenActivity = v40CalculatePieceActivity(toSquare, simBoard, activeColor);
                if (queenActivity < 3) {
                    score += CONFIG.v40PassiveQueenPenalty || -5000;
                    debugLog(\"[V40_ANTIPASSIVE]\", `âš ï¸ PASSIVE QUEEN on ${toSquare}`);
                }
            }
            
            // Queen shuffling detection (same squares repeatedly)
            if (v40IsQueenShuffling(move, board, activeColor)) {
                score += (CONFIG.v40PassiveQueenPenalty || -5000) * 1.5;
                debugLog(\"[V40_ANTIPASSIVE]\", `ğŸš¨ğŸš¨ QUEEN SHUFFLING DETECTED`);
            }
        }
        
        // CHECK 3: Rook passivity check
        if (pieceType === 'r') {
            const rookActivity = v40CalculatePieceActivity(toSquare, simBoard, activeColor);
            if (rookActivity < 2) {
                score += CONFIG.v40PassiveRookPenalty || -3000;
                debugLog(\"[V40_ANTIPASSIVE]\", `âš ï¸ PASSIVE ROOK on ${toSquare}`);
            }
            
            // Rook should be on open files or attacking
            const isOnOpenFile = isOpenFile(toSquare[0], simBoard);
            if (!isOnOpenFile && !v40MoveCreaetesThreat(move, simBoard, activeColor)) {
                score += (CONFIG.v40PassiveRookPenalty || -3000) * 0.5;
            }
        }
        
        // CHECK 4: Does the move improve the position?
        const positionImprovement = v40CalculatePositionImprovement(move, board, simBoard, activeColor);
        if (positionImprovement <= 0 && moveNumber > 8) {
            score += CONFIG.v40NoThreatPenalty || -2500;
            debugLog(\"[V40_ANTIPASSIVE]\", `âš ï¸ Move ${move} doesn't improve position`);
        } else if (positionImprovement > 0) {
            score += positionImprovement * 500;  // Bonus for improvement
        }
        
        // CHECK 5: Active piece count
        const activePieces = v40CountActivePieces(simBoard, activeColor);
        if (activePieces < (CONFIG.v40ActivePiecesRequired || 4)) {
            score += CONFIG.v40IdlePiecePenalty || -4000;
            debugLog(\"[V40_ANTIPASSIVE]\", `âš ï¸ Only ${activePieces} active pieces`);
        }
        
        // BONUS: Reward ACTIVE moves
        if (v40MoveCreaetesThreat(move, simBoard, activeColor)) {
            score += CONFIG.v40ActivePieceBonus || 3000;
        }
        
    } catch (e) {
        debugLog(\"[V40_ANTIPASSIVE]\", `Error: ${e.message}`);
    }
    
    return score;
}

/**
 * v40.3: Check if move creates a threat
 */
function v40MoveCreaetesThreat(move, board, activeColor) {
    const toSquare = move.substring(2, 4);
    const toFile = toSquare.charCodeAt(0) - 'a'.charCodeAt(0);
    const toRank = parseInt(toSquare[1]) - 1;
    const enemyColor = activeColor === 'w' ? 'b' : 'w';
    
    // Check if any enemy piece is attacked
    for (const [square, piece] of board) {
        if (!piece) continue;
        const isEnemy = (piece === piece.toUpperCase()) === (enemyColor === 'w');
        if (!isEnemy) continue;
        
        const sqFile = square.charCodeAt(0) - 'a'.charCodeAt(0);
        const sqRank = parseInt(square[1]) - 1;
        
        // Simple proximity attack check
        if (Math.abs(sqFile - toFile) <= 2 && Math.abs(sqRank - toRank) <= 2) {
            // Check if the moved piece can actually attack this square
            const movingPiece = board.get(move.substring(0, 2));
            if (movingPiece && v40CanPieceAttackSquare(movingPiece, toFile, toRank, sqFile, sqRank)) {
                return true;
            }
        }
    }
    
    return false;
}

/**
 * v40.3: Check if piece can attack a square
 */
function v40CanPieceAttackSquare(piece, fromFile, fromRank, toFile, toRank) {
    const pieceType = piece.toLowerCase();
    const fileDiff = Math.abs(toFile - fromFile);
    const rankDiff = Math.abs(toRank - fromRank);
    
    switch (pieceType) {
        case 'q':
            return fileDiff === rankDiff || fileDiff === 0 || rankDiff === 0;
        case 'r':
            return fileDiff === 0 || rankDiff === 0;
        case 'b':
            return fileDiff === rankDiff;
        case 'n':
            return (fileDiff === 2 && rankDiff === 1) || (fileDiff === 1 && rankDiff === 2);
        case 'p':
            return fileDiff === 1 && rankDiff === 1;
        case 'k':
            return fileDiff <= 1 && rankDiff <= 1;
        default:
            return false;
    }
}

/**
 * v40.3: Calculate piece activity score
 */
function v40CalculatePieceActivity(square, board, activeColor) {
    let activity = 0;
    const file = square.charCodeAt(0) - 'a'.charCodeAt(0);
    const rank = parseInt(square[1]) - 1;
    const enemyColor = activeColor === 'w' ? 'b' : 'w';
    
    // Central squares are active
    if (file >= 2 && file <= 5) activity++;
    if (rank >= 2 && rank <= 5) activity++;
    
    // Check how many enemy pieces are in attack range
    for (const [sq, piece] of board) {
        if (!piece) continue;
        const isEnemy = (piece === piece.toUpperCase()) === (enemyColor === 'w');
        if (!isEnemy) continue;
        
        const sqFile = sq.charCodeAt(0) - 'a'.charCodeAt(0);
        const sqRank = parseInt(sq[1]) - 1;
        
        if (Math.abs(sqFile - file) <= 2 && Math.abs(sqRank - rank) <= 2) {
            activity++;
        }
    }
    
    return activity;
}

/**
 * v40.3: Check for queen shuffling pattern
 */
function v40IsQueenShuffling(move, board, activeColor) {
    // Track queen moves in recent history (simplified check)
    const fromSquare = move.substring(0, 2);
    const toSquare = move.substring(2, 4);
    const piece = board.get(fromSquare);
    
    if (!piece || piece.toLowerCase() !== 'q') return false;
    
    // If queen is moving to a square close to where it came from, it's shuffling
    // This is a simplified heuristic
    const fromFile = fromSquare.charCodeAt(0) - 'a'.charCodeAt(0);
    const fromRank = parseInt(fromSquare[1]) - 1;
    const toFile = toSquare.charCodeAt(0) - 'a'.charCodeAt(0);
    const toRank = parseInt(toSquare[1]) - 1;
    
    // Queen moving just 1-2 squares without clear purpose
    if (Math.abs(fromFile - toFile) <= 2 && Math.abs(fromRank - toRank) <= 2) {
        // Check if the move creates any threat
        return !v40MoveCreaetesThreat(move, board, activeColor);
    }
    
    return false;
}

/**
 * v40.3: Calculate position improvement from move
 */
function v40CalculatePositionImprovement(move, oldBoard, newBoard, activeColor) {
    let improvement = 0;
    
    // Count controlled squares before and after
    const oldControl = v40CountControlledSquares(oldBoard, activeColor);
    const newControl = v40CountControlledSquares(newBoard, activeColor);
    improvement += (newControl - oldControl);
    
    // Check piece centralization improvement
    const oldCentralization = v40CalculateCentralization(oldBoard, activeColor);
    const newCentralization = v40CalculateCentralization(newBoard, activeColor);
    improvement += (newCentralization - oldCentralization) * 2;
    
    return improvement;
}

/**
 * v40.3: Count controlled squares
 */
function v40CountControlledSquares(board, activeColor) {
    let count = 0;
    // Simplified: count pieces in center and advanced positions
    for (const [square, piece] of board) {
        if (!piece) continue;
        const isOurs = (piece === piece.toUpperCase()) === (activeColor === 'w');
        if (!isOurs) continue;
        
        const file = square.charCodeAt(0) - 'a'.charCodeAt(0);
        const rank = parseInt(square[1]) - 1;
        
        // Central squares count more
        if (file >= 2 && file <= 5 && rank >= 2 && rank <= 5) {
            count += 2;
        } else {
            count += 1;
        }
    }
    return count;
}

/**
 * v40.3: Calculate piece centralization score
 */
function v40CalculateCentralization(board, activeColor) {
    let score = 0;
    for (const [square, piece] of board) {
        if (!piece) continue;
        const isOurs = (piece === piece.toUpperCase()) === (activeColor === 'w');
        if (!isOurs) continue;
        
        const file = square.charCodeAt(0) - 'a'.charCodeAt(0);
        const rank = parseInt(square[1]) - 1;
        
        // Distance from center
        const centerDist = Math.abs(file - 3.5) + Math.abs(rank - 3.5);
        score += (7 - centerDist);  // Max 7 for center squares
    }
    return score;
}

/**
 * v40.3: Count active pieces
 */
function v40CountActivePieces(board, activeColor) {
    let count = 0;
    for (const [square, piece] of board) {
        if (!piece) continue;
        const isOurs = (piece === piece.toUpperCase()) === (activeColor === 'w');
        if (!isOurs) continue;
        
        const pieceType = piece.toLowerCase();
        if (pieceType === 'p' || pieceType === 'k') continue;
        
        const file = square.charCodeAt(0) - 'a'.charCodeAt(0);
        const rank = parseInt(square[1]) - 1;
        
        // Piece is active if developed (not on back rank) and somewhat central
        const backRank = activeColor === 'w' ? 0 : 7;
        if (rank !== backRank && (file >= 1 && file <= 6)) {
            count++;
        }
    }
    return count;
}

/**
 * v40.3: DEEP HORIZON EVALUATION
 * True 30+ move strategic planning with horizon effect prevention
 */
function v40DeepHorizonEvaluation(fen, move, board, activeColor, moveNumber) {
    if (!CONFIG.v40DeepHorizonEnabled) return 0;
    
    let score = 0;
    
    try {
        // Simulate the move
        const simBoard = new Map(board);
        const fromSquare = move.substring(0, 2);
        const toSquare = move.substring(2, 4);
        const movingPiece = board.get(fromSquare);
        
        if (movingPiece) {
            simBoard.delete(fromSquare);
            simBoard.set(toSquare, movingPiece);
        }
        
        // PHASE 1: Evaluate long-term positional trajectory
        const trajectory = v40EvaluatePositionalTrajectory(simBoard, activeColor, moveNumber);
        score += trajectory * 1000;
        
        // PHASE 2: Check for horizon effect blindspots
        const horizonCheck = v40CheckHorizonEffect(fen, move, simBoard, activeColor);
        if (horizonCheck.dangerous) {
            score += horizonCheck.penalty;
            debugLog(\"[V40_HORIZON]\", `âš ï¸ Horizon effect danger: ${horizonCheck.reason}`);
        }
        
        // PHASE 3: Strategic projection (30+ moves)
        const projection = v40StrategicProjection(simBoard, activeColor, moveNumber);
        score += projection * 500;
        
        // PHASE 4: Endgame trajectory (if approaching endgame)
        const totalMaterial = countTotalMaterial(simBoard);
        if (totalMaterial < 50) {
            const endgameTrajectory = v40EndgameTrajectory(simBoard, activeColor);
            score += endgameTrajectory * 800;
        }
        
    } catch (e) {
        debugLog(\"[V40_HORIZON]\", `Error: ${e.message}`);
    }
    
    return score;
}

/**
 * v40.3: Evaluate positional trajectory
 */
function v40EvaluatePositionalTrajectory(board, activeColor, moveNumber) {
    let trajectory = 0;
    const enemyColor = activeColor === 'w' ? 'b' : 'w';
    
    // Material balance
    let ourMaterial = 0;
    let enemyMaterial = 0;
    const pieceValues = { 'p': 1, 'n': 3, 'b': 3, 'r': 5, 'q': 9 };
    
    for (const [square, piece] of board) {
        if (!piece) continue;
        const isOurs = (piece === piece.toUpperCase()) === (activeColor === 'w');
        const value = pieceValues[piece.toLowerCase()] || 0;
        
        if (isOurs) ourMaterial += value;
        else enemyMaterial += value;
    }
    
    trajectory += (ourMaterial - enemyMaterial) * 0.5;
    
    // Space advantage
    const ourSpace = v40CountControlledSquares(board, activeColor);
    const enemySpace = v40CountControlledSquares(board, enemyColor);
    trajectory += (ourSpace - enemySpace) * 0.3;
    
    // King safety differential
    const ourKingSafety = v40EvaluateKingSafetySimple(board, activeColor);
    const enemyKingSafety = v40EvaluateKingSafetySimple(board, enemyColor);
    trajectory += (ourKingSafety - enemyKingSafety) * 0.4;
    
    return trajectory;
}

/**
 * v40.3: Simple king safety evaluation
 */
function v40EvaluateKingSafetySimple(board, color) {
    let safety = 5;  // Base safety
    const king = findKing(board, color);
    if (!king) return 0;
    
    const kingFile = king.charCodeAt(0) - 'a'.charCodeAt(0);
    const kingRank = parseInt(king[1]) - 1;
    
    // Castled kings are safer
    if ((color === 'w' && kingRank === 0 && (kingFile <= 2 || kingFile >= 5)) ||
        (color === 'b' && kingRank === 7 && (kingFile <= 2 || kingFile >= 5))) {
        safety += 3;
    }
    
    // Corner is dangerous in endgame
    if ((kingFile === 0 || kingFile === 7) && (kingRank === 0 || kingRank === 7)) {
        safety -= 2;
    }
    
    return safety;
}

/**
 * v40.3: Check for horizon effect blindspots
 */
function v40CheckHorizonEffect(fen, move, board, activeColor) {
    const result = { dangerous: false, penalty: 0, reason: '' };
    const enemyColor = activeColor === 'w' ? 'b' : 'w';
    
    // Check if move delays but doesn't prevent a threat
    // This is the classic horizon effect
    
    // Look for enemy passed pawns that are advancing
    for (const [square, piece] of board) {
        if (!piece) continue;
        const isEnemy = (piece === piece.toUpperCase()) === (enemyColor === 'w');
        if (isEnemy && piece.toLowerCase() === 'p') {
            const pawnRank = parseInt(square[1]);
            const promotionRank = enemyColor === 'w' ? 8 : 1;
            const distance = Math.abs(pawnRank - promotionRank);
            
            if (distance <= 3) {
                // Enemy pawn close to promotion
                result.dangerous = true;
                result.penalty = -3000 * (4 - distance);
                result.reason = `Enemy pawn on ${square} close to promotion`;
            }
        }
    }
    
    return result;
}

/**
 * v40.3: Strategic projection 30+ moves ahead
 */
function v40StrategicProjection(board, activeColor, moveNumber) {
    let projection = 0;
    
    // In opening/middlegame: development and control matter
    if (moveNumber < 30) {
        const development = v40CountActivePieces(board, activeColor);
        projection += development * 2;
        
        // Central control
        const centralPawns = v40CountCentralPawns(board, activeColor);
        projection += centralPawns * 3;
    }
    
    // In endgame: king activity and passed pawns matter
    if (moveNumber > 30) {
        const king = findKing(board, activeColor);
        if (king) {
            const kingFile = king.charCodeAt(0) - 'a'.charCodeAt(0);
            const kingRank = parseInt(king[1]) - 1;
            const centrality = 4 - Math.abs(kingFile - 3.5) - Math.abs(kingRank - 3.5);
            projection += centrality;
        }
    }
    
    return projection;
}

/**
 * v40.3: Count central pawns
 */
function v40CountCentralPawns(board, activeColor) {
    let count = 0;
    const centralFiles = ['c', 'd', 'e', 'f'];
    const pawnChar = activeColor === 'w' ? 'P' : 'p';
    
    for (const file of centralFiles) {
        for (let rank = 3; rank <= 6; rank++) {
            const square = file + rank;
            if (board.get(square) === pawnChar) {
                count++;
            }
        }
    }
    return count;
}

/**
 * v40.3: Endgame trajectory evaluation
 */
function v40EndgameTrajectory(board, activeColor) {
    let trajectory = 0;
    const enemyColor = activeColor === 'w' ? 'b' : 'w';
    
    // Count passed pawns
    let ourPassedPawns = 0;
    let enemyPassedPawns = 0;
    const ourPawnChar = activeColor === 'w' ? 'P' : 'p';
    const enemyPawnChar = activeColor === 'w' ? 'p' : 'P';
    
    for (const [square, piece] of board) {
        if (piece === ourPawnChar) {
            if (v40IsPassedPawn(square, board, activeColor)) {
                ourPassedPawns++;
            }
        } else if (piece === enemyPawnChar) {
            if (v40IsPassedPawn(square, board, enemyColor)) {
                enemyPassedPawns++;
            }
        }
    }
    
    trajectory += (ourPassedPawns - enemyPassedPawns) * 5;
    
    // King activity in endgame
    const ourKing = findKing(board, activeColor);
    const enemyKing = findKing(board, enemyColor);
    
    if (ourKing && enemyKing) {
        const ourKingActivity = v40KingEndgameActivity(ourKing);
        const enemyKingActivity = v40KingEndgameActivity(enemyKing);
        trajectory += (ourKingActivity - enemyKingActivity);
    }
    
    return trajectory;
}

/**
 * v40.3: Check if pawn is passed
 */
function v40IsPassedPawn(square, board, color) {
    const file = square.charCodeAt(0) - 'a'.charCodeAt(0);
    const rank = parseInt(square[1]);
    const enemyPawnChar = color === 'w' ? 'p' : 'P';
    const direction = color === 'w' ? 1 : -1;
    
    // Check files around the pawn for enemy pawns
    for (let f = Math.max(0, file - 1); f <= Math.min(7, file + 1); f++) {
        const checkFile = String.fromCharCode(f + 97);
        
        for (let r = rank + direction; (color === 'w' ? r <= 8 : r >= 1); r += direction) {
            const checkSquare = checkFile + r;
            if (board.get(checkSquare) === enemyPawnChar) {
                return false;  // Not passed
            }
        }
    }
    
    return true;  // Is passed
}

/**
 * v40.3: King endgame activity score
 */
function v40KingEndgameActivity(kingSquare) {
    const file = kingSquare.charCodeAt(0) - 'a'.charCodeAt(0);
    const rank = parseInt(kingSquare[1]) - 1;
    
    // Centrality bonus
    const centrality = 4 - Math.abs(file - 3.5) - Math.abs(rank - 3.5);
    return centrality;
}

/**
 * v40.3: ENHANCED MATING PATTERN DETECTION
 * Specifically catches patterns like Ra1# that occurred in the lost game
 */
function v40EnhancedMatingPatternDetection(fen, move, board, activeColor) {
    if (!CONFIG.v40MatingPatternEnabled) return 0;
    
    let penalty = 0;
    const enemyColor = activeColor === 'w' ? 'b' : 'w';
    
    try {
        // Simulate move
        const simBoard = new Map(board);
        const fromSquare = move.substring(0, 2);
        const toSquare = move.substring(2, 4);
        const movingPiece = board.get(fromSquare);
        
        if (movingPiece) {
            simBoard.delete(fromSquare);
            simBoard.set(toSquare, movingPiece);
        }
        
        const ourKing = findKing(simBoard, activeColor);
        if (!ourKing) return 0;
        
        const kingFile = ourKing.charCodeAt(0) - 'a'.charCodeAt(0);
        const kingRank = parseInt(ourKing[1]) - 1;
        
        // PATTERN 1: Corner mate vulnerability (a1, h1, a8, h8)
        if (CONFIG.v40CornerMatePatterns) {
            const isCorner = (kingFile === 0 || kingFile === 7) && (kingRank === 0 || kingRank === 7);
            if (isCorner) {
                // Check for enemy rooks that could deliver checkmate
                const cornerCheck = v40CheckCornerMateVulnerability(simBoard, ourKing, activeColor);
                if (cornerCheck.vulnerable) {
                    penalty -= cornerCheck.severity;
                    debugLog(\"[V40_MATE_PATTERN]\", `ğŸš¨ CORNER MATE VULNERABILITY: ${cornerCheck.reason}`);
                }
            }
        }
        
        // PATTERN 2: Back rank mate patterns
        if (CONFIG.v40BackRankPatterns) {
            const backRankCheck = v40CheckBackRankMatePattern(simBoard, ourKing, activeColor);
            if (backRankCheck.vulnerable) {
                penalty -= backRankCheck.severity;
                debugLog(\"[V40_MATE_PATTERN]\", `ğŸš¨ BACK RANK MATE: ${backRankCheck.reason}`);
            }
        }
        
        // PATTERN 3: Staircase mate (rooks pushing king to edge)
        if (CONFIG.v40StaircaseMatePatterns) {
            const staircaseCheck = v40CheckStaircaseMatePattern(simBoard, ourKing, activeColor);
            if (staircaseCheck.vulnerable) {
                penalty -= staircaseCheck.severity;
                debugLog(\"[V40_MATE_PATTERN]\", `ğŸš¨ STAIRCASE MATE FORMING: ${staircaseCheck.reason}`);
            }
        }
        
        // PATTERN 4: Queen + Rook coordination mates
        if (CONFIG.v40QueenRookMatePatterns) {
            const qrMateCheck = v40CheckQRMatePattern(simBoard, ourKing, activeColor);
            if (qrMateCheck.vulnerable) {
                penalty -= qrMateCheck.severity;
                debugLog(\"[V40_MATE_PATTERN]\", `ğŸš¨ Q+R MATE PATTERN: ${qrMateCheck.reason}`);
            }
        }
        
        // EARLY WARNING SYSTEM
        const mateDistance = v40EstimateMateDistance(simBoard, activeColor);
        if (mateDistance <= (CONFIG.v40MatingNetEarlyWarning || 15)) {
            penalty -= (16 - mateDistance) * 1000;
            debugLog(\"[V40_MATE_PATTERN]\", `âš ï¸ MATE IN ${mateDistance} POSSIBLE`);
        }
        
    } catch (e) {
        debugLog(\"[V40_MATE_PATTERN]\", `Error: ${e.message}`);
    }
    
    return penalty;
}

/**
 * v40.3: Check corner mate vulnerability
 */
function v40CheckCornerMateVulnerability(board, kingSquare, activeColor) {
    const result = { vulnerable: false, severity: 0, reason: '' };
    const enemyColor = activeColor === 'w' ? 'b' : 'w';
    const kingFile = kingSquare.charCodeAt(0) - 'a'.charCodeAt(0);
    const kingRank = parseInt(kingSquare[1]) - 1;
    
    // Find enemy rooks and queens
    let enemyRooks = [];
    let enemyQueen = null;
    
    for (const [square, piece] of board) {
        if (!piece) continue;
        const isEnemy = (piece === piece.toUpperCase()) === (enemyColor === 'w');
        if (!isEnemy) continue;
        
        if (piece.toLowerCase() === 'r') {
            enemyRooks.push(square);
        } else if (piece.toLowerCase() === 'q') {
            enemyQueen = square;
        }
    }
    
    // Check if enemy rooks can deliver corner mate
    for (const rookSq of enemyRooks) {
        const rookFile = rookSq.charCodeAt(0) - 'a'.charCodeAt(0);
        const rookRank = parseInt(rookSq[1]) - 1;
        
        // Rook on adjacent file or rank to cornered king
        if (rookFile === kingFile || rookRank === kingRank || 
            Math.abs(rookFile - kingFile) === 1 || Math.abs(rookRank - kingRank) === 1) {
            
            // Check if king has escape squares
            let escapes = 0;
            for (let df = -1; df <= 1; df++) {
                for (let dr = -1; dr <= 1; dr++) {
                    if (df === 0 && dr === 0) continue;
                    const newFile = kingFile + df;
                    const newRank = kingRank + dr;
                    if (newFile < 0 || newFile > 7 || newRank < 0 || newRank > 7) continue;
                    
                    const escapeSquare = String.fromCharCode(newFile + 97) + (newRank + 1);
                    const pieceOnSquare = board.get(escapeSquare);
                    
                    if (!pieceOnSquare) {
                        escapes++;
                    } else {
                        const isOurs = (pieceOnSquare === pieceOnSquare.toUpperCase()) === (activeColor === 'w');
                        if (!isOurs) escapes++;  // Can capture
                    }
                }
            }
            
            if (escapes <= 1) {
                result.vulnerable = true;
                result.severity = 8000 - escapes * 2000;
                result.reason = `King cornered at ${kingSquare} with rook on ${rookSq}`;
            }
        }
    }
    
    return result;
}

/**
 * v40.3: Check back rank mate pattern
 */
function v40CheckBackRankMatePattern(board, kingSquare, activeColor) {
    const result = { vulnerable: false, severity: 0, reason: '' };
    const kingFile = kingSquare.charCodeAt(0) - 'a'.charCodeAt(0);
    const kingRank = parseInt(kingSquare[1]) - 1;
    const enemyColor = activeColor === 'w' ? 'b' : 'w';
    
    const backRank = activeColor === 'w' ? 0 : 7;
    const secondRank = activeColor === 'w' ? 1 : 6;
    
    if (kingRank !== backRank) return result;
    
    // Check escape squares on second rank
    let blocked = 0;
    for (let f = Math.max(0, kingFile - 1); f <= Math.min(7, kingFile + 1); f++) {
        const escapeSquare = String.fromCharCode(f + 97) + (secondRank + 1);
        const piece = board.get(escapeSquare);
        
        if (piece) {
            const isOurs = (piece === piece.toUpperCase()) === (activeColor === 'w');
            if (isOurs) blocked++;
        }
    }
    
    if (blocked >= 2) {
        // Check for enemy rooks/queens on back rank
        for (const [square, piece] of board) {
            if (!piece) continue;
            const isEnemy = (piece === piece.toUpperCase()) === (enemyColor === 'w');
            if (!isEnemy) continue;
            
            const pieceType = piece.toLowerCase();
            if (pieceType === 'r' || pieceType === 'q') {
                const pieceRank = parseInt(square[1]) - 1;
                if (pieceRank === backRank) {
                    result.vulnerable = true;
                    result.severity = 10000;
                    result.reason = `Back rank blocked, ${pieceType} on ${square}`;
                    return result;
                }
            }
        }
    }
    
    return result;
}

/**
 * v40.3: Check staircase mate pattern
 */
function v40CheckStaircaseMatePattern(board, kingSquare, activeColor) {
    const result = { vulnerable: false, severity: 0, reason: '' };
    const enemyColor = activeColor === 'w' ? 'b' : 'w';
    const kingFile = kingSquare.charCodeAt(0) - 'a'.charCodeAt(0);
    const kingRank = parseInt(kingSquare[1]) - 1;
    
    // King on edge is vulnerable to staircase
    const isOnEdge = kingFile === 0 || kingFile === 7 || kingRank === 0 || kingRank === 7;
    if (!isOnEdge) return result;
    
    // Count enemy rooks
    let enemyRooks = 0;
    for (const [square, piece] of board) {
        if (!piece) continue;
        const isEnemy = (piece === piece.toUpperCase()) === (enemyColor === 'w');
        if (isEnemy && piece.toLowerCase() === 'r') {
            enemyRooks++;
        }
    }
    
    if (enemyRooks >= 2) {
        result.vulnerable = true;
        result.severity = 5000;
        result.reason = `King on edge at ${kingSquare} with ${enemyRooks} enemy rooks`;
    }
    
    return result;
}

/**
 * v40.3: Check Q+R mate pattern
 */
function v40CheckQRMatePattern(board, kingSquare, activeColor) {
    const result = { vulnerable: false, severity: 0, reason: '' };
    const enemyColor = activeColor === 'w' ? 'b' : 'w';
    const kingFile = kingSquare.charCodeAt(0) - 'a'.charCodeAt(0);
    const kingRank = parseInt(kingSquare[1]) - 1;
    
    let hasEnemyQueen = false;
    let hasEnemyRook = false;
    
    for (const [square, piece] of board) {
        if (!piece) continue;
        const isEnemy = (piece === piece.toUpperCase()) === (enemyColor === 'w');
        if (!isEnemy) continue;
        
        if (piece.toLowerCase() === 'q') hasEnemyQueen = true;
        if (piece.toLowerCase() === 'r') hasEnemyRook = true;
    }
    
    // Q+R on same file as king is dangerous
    if (hasEnemyQueen && hasEnemyRook) {
        const isOnEdge = kingFile === 0 || kingFile === 7 || kingRank === 0 || kingRank === 7;
        if (isOnEdge) {
            result.vulnerable = true;
            result.severity = 4000;
            result.reason = `Q+R with king on edge at ${kingSquare}`;
        }
    }
    
    return result;
}

/**
 * v40.3: Estimate mate distance (simplified)
 */
function v40EstimateMateDistance(board, activeColor) {
    // Simplified: check material imbalance and king safety
    const enemyColor = activeColor === 'w' ? 'b' : 'w';
    let ourMaterial = 0;
    let enemyMaterial = 0;
    const pieceValues = { 'p': 1, 'n': 3, 'b': 3, 'r': 5, 'q': 9 };
    
    for (const [square, piece] of board) {
        if (!piece) continue;
        const isOurs = (piece === piece.toUpperCase()) === (activeColor === 'w');
        const value = pieceValues[piece.toLowerCase()] || 0;
        
        if (isOurs) ourMaterial += value;
        else enemyMaterial += value;
    }
    
    // More material disadvantage = closer to mate
    const materialDiff = ourMaterial - enemyMaterial;
    if (materialDiff < -10) return 5;  // Severe disadvantage
    if (materialDiff < -5) return 10;
    if (materialDiff < 0) return 20;
    
    return 50;  // Safe
}

/**
 * v40.3: COUNTERATTACK PRIORITY EVALUATION
 * AlphaZero prefers active defense with counterattack over passive defense
 */
function v40CounterattackEvaluation(fen, move, board, activeColor, moveNumber) {
    if (!CONFIG.v40CounterattackEnabled) return 0;
    
    let score = 0;
    
    try {
        // Simulate move
        const simBoard = new Map(board);
        const fromSquare = move.substring(0, 2);
        const toSquare = move.substring(2, 4);
        const movingPiece = board.get(fromSquare);
        
        if (movingPiece) {
            simBoard.delete(fromSquare);
            simBoard.set(toSquare, movingPiece);
        }
        
        // Check if we're under pressure
        const underPressure = v40IsUnderPressure(board, activeColor);
        
        if (underPressure) {
            // Does the move create a counter-threat?
            const createsCounterThreat = v40MoveCreaetesThreat(move, simBoard, activeColor);
            
            if (createsCounterThreat) {
                score += CONFIG.v40CounterattackBonus || 15000;
                debugLog(\"[V40_COUNTER]\", `âœ… COUNTERATTACK: ${move} creates threat while defending`);
                
                // Bonus for counter-threat against valuable pieces
                const threatValue = v40EvaluateThreatValue(move, simBoard, activeColor);
                score += threatValue * 2;
            } else {
                // Check if it's a passive defense
                const isPassiveDefense = v40IsPassiveDefenseMove(move, board, activeColor);
                if (isPassiveDefense) {
                    score += CONFIG.v40PassiveDefensePenalty || -6000;
                    debugLog(\"[V40_COUNTER]\", `âš ï¸ PASSIVE DEFENSE: ${move} without counterplay`);
                }
            }
        }
        
        // Active defense bonus even when not under direct pressure
        if (v40IsActiveDefense(move, board, simBoard, activeColor)) {
            score += CONFIG.v40ActiveDefensePreference || 12000;
        }
        
    } catch (e) {
        debugLog(\"[V40_COUNTER]\", `Error: ${e.message}`);
    }
    
    return score;
}

/**
 * v40.3: Check if under pressure
 */
function v40IsUnderPressure(board, activeColor) {
    const enemyColor = activeColor === 'w' ? 'b' : 'w';
    let pressureCount = 0;
    
    // Count enemy pieces attacking our position
    for (const [square, piece] of board) {
        if (!piece) continue;
        const isOurs = (piece === piece.toUpperCase()) === (activeColor === 'w');
        if (!isOurs) continue;
        
        const pieceValue = { 'p': 1, 'n': 3, 'b': 3, 'r': 5, 'q': 9, 'k': 0 }[piece.toLowerCase()] || 0;
        if (pieceValue >= 3) {
            // Check if this piece is attacked by lesser value enemy piece
            // Simplified: count as pressure
            pressureCount++;
        }
    }
    
    return pressureCount > 2;
}

/**
 * v40.3: Evaluate threat value
 */
function v40EvaluateThreatValue(move, board, activeColor) {
    const toSquare = move.substring(2, 4);
    const toFile = toSquare.charCodeAt(0) - 'a'.charCodeAt(0);
    const toRank = parseInt(toSquare[1]) - 1;
    const enemyColor = activeColor === 'w' ? 'b' : 'w';
    const pieceValues = { 'p': 100, 'n': 300, 'b': 300, 'r': 500, 'q': 900 };
    
    let maxThreatValue = 0;
    
    for (const [square, piece] of board) {
        if (!piece) continue;
        const isEnemy = (piece === piece.toUpperCase()) === (enemyColor === 'w');
        if (!isEnemy) continue;
        
        const sqFile = square.charCodeAt(0) - 'a'.charCodeAt(0);
        const sqRank = parseInt(square[1]) - 1;
        
        if (Math.abs(sqFile - toFile) <= 2 && Math.abs(sqRank - toRank) <= 2) {
            const value = pieceValues[piece.toLowerCase()] || 0;
            maxThreatValue = Math.max(maxThreatValue, value);
        }
    }
    
    return maxThreatValue;
}

/**
 * v40.3: Check if passive defense move
 */
function v40IsPassiveDefenseMove(move, board, activeColor) {
    const toSquare = move.substring(2, 4);
    const toRank = parseInt(toSquare[1]);
    const isWhite = activeColor === 'w';
    
    // Moving to back ranks without creating threats is passive
    if (isWhite && toRank <= 2) return true;
    if (!isWhite && toRank >= 7) return true;
    
    return false;
}

/**
 * v40.3: Check if active defense
 */
function v40IsActiveDefense(move, oldBoard, newBoard, activeColor) {
    // Active defense: defends but also improves position or creates threats
    const improvesPosition = v40CalculatePositionImprovement(move, oldBoard, newBoard, activeColor) > 0;
    const createsThreat = v40MoveCreaetesThreat(move, newBoard, activeColor);
    
    return improvesPosition || createsThreat;
}

/**
 * v40.3: SPACE DOMINATION EVALUATION
 */
function v40SpaceDominationEvaluation(fen, move, board, activeColor) {
    if (!CONFIG.v40SpaceDominationEnabled) return 0;
    
    let score = 0;
    const enemyColor = activeColor === 'w' ? 'b' : 'w';
    
    try {
        // Simulate move
        const simBoard = new Map(board);
        const fromSquare = move.substring(0, 2);
        const toSquare = move.substring(2, 4);
        const movingPiece = board.get(fromSquare);
        
        if (movingPiece) {
            simBoard.delete(fromSquare);
            simBoard.set(toSquare, movingPiece);
        }
        
        // Calculate space advantage
        const ourSpace = v40CalculateSpaceAdvantage(simBoard, activeColor);
        const enemySpace = v40CalculateSpaceAdvantage(simBoard, enemyColor);
        const spaceAdvantage = ourSpace - enemySpace;
        
        if (spaceAdvantage > 10) {
            score += CONFIG.v40SpaceAdvantageBonus || 10000;
            debugLog(\"[V40_SPACE]\", `âœ… SPACE DOMINATION: +${spaceAdvantage} squares`);
        } else if (spaceAdvantage > 5) {
            score += (CONFIG.v40SpaceAdvantageBonus || 10000) * 0.5;
        }
        
        // Central domination
        const centralControl = v40CalculateCentralControl(simBoard, activeColor);
        const enemyCentralControl = v40CalculateCentralControl(simBoard, enemyColor);
        
        if (centralControl > enemyCentralControl) {
            score += CONFIG.v40CentralDominationBonus || 8000;
        }
        
        // Positional squeeze
        if (spaceAdvantage > 15) {
            score += CONFIG.v40SqueezeBonus || 12000;
            debugLog(\"[V40_SPACE]\", `âœ… POSITIONAL SQUEEZE ACTIVE`);
        }
        
    } catch (e) {
        debugLog(\"[V40_SPACE]\", `Error: ${e.message}`);
    }
    
    return score;
}

/**
 * v40.3: Calculate space advantage
 */
function v40CalculateSpaceAdvantage(board, activeColor) {
    let space = 0;
    const isWhite = activeColor === 'w';
    
    // Count pawns in advanced positions
    const pawnChar = isWhite ? 'P' : 'p';
    const advancedRanks = isWhite ? [5, 6, 7] : [2, 3, 4];
    
    for (const [square, piece] of board) {
        if (piece === pawnChar) {
            const rank = parseInt(square[1]);
            if (advancedRanks.includes(rank)) {
                space += 3;  // Advanced pawn controls space
            }
        }
    }
    
    // Count pieces in opponent's half
    const opponentHalf = isWhite ? [5, 6, 7, 8] : [1, 2, 3, 4];
    for (const [square, piece] of board) {
        if (!piece) continue;
        const isOurs = (piece === piece.toUpperCase()) === isWhite;
        if (!isOurs) continue;
        
        const rank = parseInt(square[1]);
        if (opponentHalf.includes(rank)) {
            space += 2;
        }
    }
    
    return space;
}

/**
 * v40.3: Calculate central control
 */
function v40CalculateCentralControl(board, activeColor) {
    let control = 0;
    const centralSquares = ['d4', 'd5', 'e4', 'e5', 'c4', 'c5', 'f4', 'f5'];
    
    for (const sq of centralSquares) {
        const piece = board.get(sq);
        if (piece) {
            const isOurs = (piece === piece.toUpperCase()) === (activeColor === 'w');
            if (isOurs) control += 2;
        }
    }
    
    return control;
}

/**
 * v40.3: INITIATIVE PRESERVATION EVALUATION
 */
function v40InitiativePreservationEvaluation(fen, move, board, activeColor, moveNumber) {
    if (!CONFIG.v40InitiativePreservationEnabled) return 0;
    
    let score = 0;
    
    try {
        // Simulate move
        const simBoard = new Map(board);
        const fromSquare = move.substring(0, 2);
        const toSquare = move.substring(2, 4);
        const movingPiece = board.get(fromSquare);
        
        if (movingPiece) {
            simBoard.delete(fromSquare);
            simBoard.set(toSquare, movingPiece);
        }
        
        // Check if move maintains initiative
        const hadInitiative = v40HasInitiative(board, activeColor);
        const hasInitiativeAfter = v40HasInitiativeAfterMove(simBoard, activeColor, move);
        
        if (hadInitiative && !hasInitiativeAfter) {
            score += CONFIG.v40InitiativeLossPenalty || -10000;
            debugLog(\"[V40_INITIATIVE]\", `ğŸš¨ INITIATIVE LOST with ${move}`);
        } else if (!hadInitiative && hasInitiativeAfter) {
            score += CONFIG.v40InitiativeGainBonus || 8000;
            debugLog(\"[V40_INITIATIVE]\", `âœ… INITIATIVE GAINED with ${move}`);
        } else if (hadInitiative && hasInitiativeAfter) {
            score += CONFIG.v40MomentumBonus || 5000;
        }
        
        // Forcing sequence bonus
        if (v40IsForcingMove(move, simBoard, activeColor)) {
            score += CONFIG.v40ForcingSequenceBonus || 7000;
        }
        
    } catch (e) {
        debugLog(\"[V40_INITIATIVE]\", `Error: ${e.message}`);
    }
    
    return score;
}

/**
 * v40.3: Check if side has initiative
 */
function v40HasInitiative(board, activeColor) {
    let threats = 0;
    const enemyColor = activeColor === 'w' ? 'b' : 'w';
    
    // Count active threats
    for (const [square, piece] of board) {
        if (!piece) continue;
        const isOurs = (piece === piece.toUpperCase()) === (activeColor === 'w');
        if (!isOurs) continue;
        
        const pieceType = piece.toLowerCase();
        if (pieceType !== 'p' && pieceType !== 'k') {
            const file = square.charCodeAt(0) - 'a'.charCodeAt(0);
            const rank = parseInt(square[1]) - 1;
            
            // Piece in advanced/active position
            const isAdvanced = activeColor === 'w' ? rank >= 4 : rank <= 3;
            if (isAdvanced) threats++;
        }
    }
    
    return threats >= 3;
}

/**
 * v40.3: Check initiative after move
 */
function v40HasInitiativeAfterMove(board, activeColor, move) {
    const baseInitiative = v40HasInitiative(board, activeColor);
    const createsNewThreat = v40MoveCreaetesThreat(move, board, activeColor);
    
    return baseInitiative || createsNewThreat;
}

/**
 * v40.3: Check if move is forcing
 */
function v40IsForcingMove(move, board, activeColor) {
    // Check if move is a check, capture, or creates immediate threat
    const toSquare = move.substring(2, 4);
    const capturedPiece = board.get(toSquare);
    
    if (capturedPiece) return true;  // Capture
    if (v40MoveCreaetesThreat(move, board, activeColor)) return true;
    
    return false;
}

/**
 * v40: Evaluate goal alignment with strategic plan
 * True AlphaZero evaluates moves based on how well they fit the plan
 */
function evaluateGoalAlignment(move, plan) {"
Observation: Edit was successful.