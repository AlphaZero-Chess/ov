Now let me add the v40.35 functions after the v40.33 functions (around line 25471):
Action: file_editor str_replace /app/Lichess Bot-AlphaZero-Pure.user.js --old-str "    return initiative;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function findAttackedPiecesV40_9(board, color) {" --new-str "    return initiative;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// v40.35 MATERIAL SAFETY & PASSIVE MOVE SUPREME FUNCTIONS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/**
 * v40.35: PASSIVE PAWN PROHIBITION â€” a3/h3/a6/h6/b3/g3 are TOXIC moves
 * These moves waste time and give the opponent initiative
 */
function v40PassivePawnProhibitionEval(fen, move, board, activeColor, moveNumber) {
    if (!CONFIG.v40PassivePawnProhibitionEnabled) return 0;
    
    let score = 0;
    const maxMoves = CONFIG.v40PassivePawnMoveLimit || 30;
    
    if (moveNumber > maxMoves) return 0;
    
    const passiveMoves = CONFIG.v40PassivePawnMoves || ['a2a3', 'h2h3', 'a7a6', 'h7h6', 'b2b3', 'g2g3'];
    
    if (passiveMoves.includes(move)) {
        debugLog(\"[V40.35_PASSIVE]\", `ğŸš«ğŸš«ğŸš« PASSIVE PAWN PROHIBITION: ${move} is TOXIC!`);
        debugLog(\"[V40.35_PASSIVE]\", `ğŸš«ğŸš«ğŸš« Move ${moveNumber}: ${move} REJECTED with MASSIVE PENALTY!`);
        score += CONFIG.v40PassivePawnPenalty || -8000000000000;
        
        // Extra penalty if opponent has initiative
        const enemyInit = v40CalculateSimpleInitiative(board, activeColor !== 'w');
        if (enemyInit > 2) {
            debugLog(\"[V40.35_PASSIVE]\", `ğŸš«ğŸš«ğŸš« EXTRA PENALTY: Playing passive when opponent has initiative!`);
            score += (CONFIG.v40PassivePawnPenalty || -8000000000000) * 2;
        }
    }
    
    return score;
}

/**
 * v40.35: MATERIAL SAFETY VERIFICATION â€” Don't allow material loss
 */
function v40MaterialSafetyVerificationEval(fen, move, board, activeColor, moveNumber) {
    if (!CONFIG.v40MaterialSafetyEnabled) return 0;
    
    let score = 0;
    const isWhite = activeColor === 'w';
    
    // Calculate material before move
    const materialBefore = v40CalculateMaterial(board, isWhite);
    
    // Simulate the move
    const afterBoard = simulateMoveOnBoard(board, move);
    
    // Calculate material after move
    const materialAfter = v40CalculateMaterial(afterBoard, isWhite);
    
    // Check for material loss
    const materialLoss = materialBefore - materialAfter;
    
    if (materialLoss > (CONFIG.v40MaterialLossTolerance || 0)) {
        debugLog(\"[V40.35_MATERIAL]\", `âš ï¸ MATERIAL LOSS DETECTED: Lost ${materialLoss} centipawns!`);
        
        // Check if it's a central pawn (e4/d4/e5/d5)
        const fromSquare = move.substring(0, 2);
        const piece = board.get(fromSquare);
        if (piece && piece.toLowerCase() === 'p') {
            if (['d4', 'd5', 'e4', 'e5'].includes(fromSquare)) {
                debugLog(\"[V40.35_MATERIAL]\", `ğŸš«ğŸš«ğŸš« CENTRAL PAWN LOSS: Critical strategic damage!`);
                score += CONFIG.v40CentralPawnLossPenalty || -15000000000000;
            }
        }
        
        // General material loss penalty
        score += (CONFIG.v40FreePieceCapturePenalty || -25000000000000) * (materialLoss / 100);
    }
    
    // Check if we're allowing a free capture by opponent after our move
    const hangingAfter = findHangingPiecesV40_9(afterBoard, activeColor);
    if (hangingAfter.length > 0) {
        const mostValuableHanging = hangingAfter[0];
        debugLog(\"[V40.35_MATERIAL]\", `ğŸš« HANGING PIECE AFTER MOVE: ${mostValuableHanging.piece} on ${mostValuableHanging.square}!`);
        score += (CONFIG.v40FreePieceCapturePenalty || -25000000000000) * (mostValuableHanging.value / 9);
    }
    
    return score;
}

/**
 * v40.35 Helper: Calculate total material for a side
 */
function v40CalculateMaterial(board, isWhite) {
    let material = 0;
    const pieceValues = { 'p': 100, 'n': 320, 'b': 330, 'r': 500, 'q': 900, 'k': 0 };
    
    for (const [square, piece] of board) {
        if (!piece) continue;
        const pieceIsWhite = piece === piece.toUpperCase();
        if (pieceIsWhite !== isWhite) continue;
        
        const pieceType = piece.toLowerCase();
        material += pieceValues[pieceType] || 0;
    }
    
    return material;
}

/**
 * v40.35: TACTICAL VERIFICATION LAYERS â€” Multi-pass blunder prevention
 */
function v40TacticalVerificationLayersEval(fen, move, board, activeColor, moveNumber) {
    if (!CONFIG.v40TacticalVerificationEnabled) return 0;
    
    let score = 0;
    const passes = CONFIG.v40TacticalVerificationPasses || 5;
    const afterBoard = simulateMoveOnBoard(board, move);
    const isWhite = activeColor === 'w';
    
    // Pass 1: Check for immediate hanging pieces
    const hangingPieces = findHangingPiecesV40_9(afterBoard, activeColor);
    if (hangingPieces.length > 0) {
        debugLog(\"[V40.35_TACTICAL]\", `âš ï¸ Pass 1: Found ${hangingPieces.length} hanging pieces after move!`);
        for (const hp of hangingPieces) {
            score -= hp.value * 100000000000; // Massive penalty per hanging piece
        }
    }
    
    // Pass 2: Check for fork threats
    const forkThreats = v40DetectForkThreats(afterBoard, activeColor);
    if (forkThreats.length > 0) {
        debugLog(\"[V40.35_TACTICAL]\", `âš ï¸ Pass 2: Found ${forkThreats.length} fork threats!`);
        score -= forkThreats.length * 500000000000;
    }
    
    // Pass 3: Check for pin threats
    const pinThreats = v40DetectPinThreats(afterBoard, activeColor);
    if (pinThreats.length > 0) {
        debugLog(\"[V40.35_TACTICAL]\", `âš ï¸ Pass 3: Found ${pinThreats.length} pin threats!`);
        score -= pinThreats.length * 400000000000;
    }
    
    // Pass 4: Check for back rank weaknesses
    const backRankWeak = v40DetectBackRankWeakness(afterBoard, isWhite);
    if (backRankWeak) {
        debugLog(\"[V40.35_TACTICAL]\", `âš ï¸ Pass 4: Back rank weakness detected!`);
        score -= 800000000000;
    }
    
    // Pass 5: Check for mate threats
    const mateThreats = v40DetectMateThreats(afterBoard, activeColor, CONFIG.v40MateDetectionDepth || 10);
    if (mateThreats.length > 0) {
        debugLog(\"[V40.35_TACTICAL]\", `ğŸš«ğŸš«ğŸš« Pass 5: MATE THREATS DETECTED!`);
        score -= mateThreats.length * 10000000000000; // Huge penalty for mate threats
    }
    
    return score;
}

/**
 * v40.35 Helper: Detect fork threats
 */
function v40DetectForkThreats(board, color) {
    const threats = [];
    const isWhite = color === 'w';
    const enemyColor = isWhite ? 'b' : 'w';
    
    // Look for enemy knights that could fork our pieces
    for (const [square, piece] of board) {
        if (!piece) continue;
        const pieceIsWhite = piece === piece.toUpperCase();
        if (pieceIsWhite === isWhite) continue; // Skip our pieces
        
        const pieceType = piece.toLowerCase();
        if (pieceType === 'n') {
            // Check knight fork potential
            const knightMoves = getKnightAttacks(square);
            let attackedPieces = 0;
            let totalValue = 0;
            
            for (const targetSquare of knightMoves) {
                const targetPiece = board.get(targetSquare);
                if (targetPiece) {
                    const targetIsWhite = targetPiece === targetPiece.toUpperCase();
                    if (targetIsWhite === isWhite) {
                        attackedPieces++;
                        totalValue += getPieceValueSimple(targetPiece.toLowerCase());
                    }
                }
            }
            
            if (attackedPieces >= 2 && totalValue >= 6) {
                threats.push({ square, attackedPieces, totalValue });
            }
        }
    }
    
    return threats;
}

/**
 * v40.35 Helper: Detect pin threats
 */
function v40DetectPinThreats(board, color) {
    const threats = [];
    const isWhite = color === 'w';
    
    // Find our king position
    let kingSquare = null;
    for (const [square, piece] of board) {
        if (!piece) continue;
        const pieceType = piece.toLowerCase();
        const pieceIsWhite = piece === piece.toUpperCase();
        if (pieceType === 'k' && pieceIsWhite === isWhite) {
            kingSquare = square;
            break;
        }
    }
    
    if (!kingSquare) return threats;
    
    // Check for pieces that could be pinned to the king
    for (const [square, piece] of board) {
        if (!piece) continue;
        const pieceIsWhite = piece === piece.toUpperCase();
        if (pieceIsWhite !== isWhite) continue;
        if (square === kingSquare) continue;
        
        // Check if this piece is on a line with the king
        if (isOnSameLine(square, kingSquare)) {
            // Check if there's an enemy slider that could pin
            const direction = getLineDirection(square, kingSquare);
            const beyondSquare = getSquareBeyond(square, direction);
            
            if (beyondSquare) {
                const attackerPiece = board.get(beyondSquare);
                if (attackerPiece) {
                    const attackerIsWhite = attackerPiece === attackerPiece.toUpperCase();
                    const attackerType = attackerPiece.toLowerCase();
                    
                    if (attackerIsWhite !== isWhite) {
                        // Check if it's a slider that can pin
                        if ((direction.dx !== 0 && direction.dy !== 0 && (attackerType === 'b' || attackerType === 'q')) ||
                            ((direction.dx === 0 || direction.dy === 0) && (attackerType === 'r' || attackerType === 'q'))) {
                            threats.push({ pinnedSquare: square, attacker: beyondSquare });
                        }
                    }
                }
            }
        }
    }
    
    return threats;
}

/**
 * v40.35 Helper: Detect back rank weakness
 */
function v40DetectBackRankWeakness(board, isWhite) {
    const backRank = isWhite ? '1' : '8';
    
    // Find king position
    let kingSquare = null;
    for (const [square, piece] of board) {
        if (!piece) continue;
        const pieceType = piece.toLowerCase();
        const pieceIsWhite = piece === piece.toUpperCase();
        if (pieceType === 'k' && pieceIsWhite === isWhite) {
            kingSquare = square;
            break;
        }
    }
    
    if (!kingSquare || kingSquare[1] !== backRank) return false;
    
    // Check if king is trapped on back rank
    const kingFile = kingSquare[0].charCodeAt(0);
    let escapeSquares = 0;
    
    // Check f1/f8, g1/g8, h1/h8 for white, a1/a8, b1/b8, c1/c8 for black
    const checkSquares = isWhite ? ['f2', 'g2', 'h2'] : ['f7', 'g7', 'h7'];
    
    for (const sq of checkSquares) {
        const piece = board.get(sq);
        if (!piece) {
            escapeSquares++;
        } else {
            const pieceIsWhite = piece === piece.toUpperCase();
            if (pieceIsWhite !== isWhite) {
                escapeSquares++; // Can capture to escape
            }
        }
    }
    
    return escapeSquares === 0;
}

/**
 * v40.35 Helper: Detect mate threats
 */
function v40DetectMateThreats(board, color, depth) {
    const threats = [];
    const isWhite = color === 'w';
    const enemyColor = isWhite ? 'b' : 'w';
    
    // Simple mate threat detection: look for enemy pieces converging on king
    let kingSquare = null;
    for (const [square, piece] of board) {
        if (!piece) continue;
        const pieceType = piece.toLowerCase();
        const pieceIsWhite = piece === piece.toUpperCase();
        if (pieceType === 'k' && pieceIsWhite === isWhite) {
            kingSquare = square;
            break;
        }
    }
    
    if (!kingSquare) return threats;
    
    // Count attackers near king
    let attackersNearKing = 0;
    const kingFile = kingSquare[0].charCodeAt(0) - 97;
    const kingRank = parseInt(kingSquare[1]) - 1;
    
    for (const [square, piece] of board) {
        if (!piece) continue;
        const pieceIsWhite = piece === piece.toUpperCase();
        if (pieceIsWhite === isWhite) continue;
        
        const file = square[0].charCodeAt(0) - 97;
        const rank = parseInt(square[1]) - 1;
        
        // Check if within 2 squares of king
        if (Math.abs(file - kingFile) <= 2 && Math.abs(rank - kingRank) <= 2) {
            attackersNearKing++;
        }
    }
    
    // If 3+ attackers near king, it's a mate threat
    if (attackersNearKing >= 3) {
        threats.push({ kingSquare, attackersNearKing });
    }
    
    return threats;
}

/**
 * v40.35: CENTRAL CONTROL PRIORITY â€” e4/d4/e5/d5 are SACRED
 */
function v40CentralControlPriorityEval(fen, move, board, activeColor, moveNumber) {
    if (!CONFIG.v40CentralControlEnabled) return 0;
    
    let score = 0;
    const centralSquares = ['d4', 'd5', 'e4', 'e5'];
    const isWhite = activeColor === 'w';
    
    // Check central pawn control
    for (const sq of centralSquares) {
        const piece = board.get(sq);
        if (piece && piece.toLowerCase() === 'p') {
            const pieceIsWhite = piece === piece.toUpperCase();
            if (pieceIsWhite === isWhite) {
                score += CONFIG.v40CentralPawnBonus || 2000000000000;
                debugLog(\"[V40.35_CENTER]\", `âœ… Central pawn on ${sq} - EXCELLENT!`);
            }
        }
    }
    
    // Check if move defends a central pawn
    const toSquare = move.substring(2, 4);
    const fromSquare = move.substring(0, 2);
    const movingPiece = board.get(fromSquare);
    
    if (movingPiece) {
        // Check if move creates defense for central squares
        for (const sq of centralSquares) {
            if (v40DoesAttackSquare(board, toSquare, sq, movingPiece)) {
                const centralPiece = board.get(sq);
                if (centralPiece) {
                    const centralIsWhite = centralPiece === centralPiece.toUpperCase();
                    if (centralIsWhite === isWhite) {
                        score += CONFIG.v40CentralPawnDefenseBonus || 1500000000000;
                        debugLog(\"[V40.35_CENTER]\", `âœ… Move defends central pawn on ${sq}!`);
                    }
                }
            }
        }
    }
    
    // Penalty for giving up central pawn
    if (fromSquare && centralSquares.includes(fromSquare)) {
        const piece = board.get(fromSquare);
        if (piece && piece.toLowerCase() === 'p') {
            debugLog(\"[V40.35_CENTER]\", `âš ï¸ Moving central pawn from ${fromSquare} - be careful!`);
            // Small penalty unless it's advancing
            const fromRank = parseInt(fromSquare[1]);
            const toRank = parseInt(toSquare[1]);
            const isAdvancing = isWhite ? (toRank > fromRank) : (toRank < fromRank);
            if (!isAdvancing) {
                score += CONFIG.v40LoseCentralPawnPenalty || -10000000000000;
            }
        }
    }
    
    return score;
}

/**
 * v40.35: PIECE COORDINATION SUPREME â€” All pieces must work together
 */
function v40PieceCoordinationSupremeEval(fen, move, board, activeColor, moveNumber) {
    if (!CONFIG.v40PieceCoordinationEnabled) return 0;
    
    let score = 0;
    const afterBoard = simulateMoveOnBoard(board, move);
    const isWhite = activeColor === 'w';
    
    // Count how many of our pieces support each other
    let coordinationBefore = v40CountPieceCoordination(board, isWhite);
    let coordinationAfter = v40CountPieceCoordination(afterBoard, isWhite);
    
    if (coordinationAfter > coordinationBefore) {
        debugLog(\"[V40.35_COORD]\", `âœ… COORDINATION IMPROVED: ${coordinationBefore} â†’ ${coordinationAfter}`);
        score += CONFIG.v40PieceHarmonyBonus || 1000000000000;
    } else if (coordinationAfter < coordinationBefore - 2) {
        debugLog(\"[V40.35_COORD]\", `âš ï¸ COORDINATION DROPPED: ${coordinationBefore} â†’ ${coordinationAfter}`);
        score += CONFIG.v40UncoordinatedAttackPenalty || -3000000000000;
    }
    
    return score;
}

/**
 * v40.35 Helper: Count piece coordination
 */
function v40CountPieceCoordination(board, isWhite) {
    let coordination = 0;
    const ourPieces = [];
    
    // Collect our pieces
    for (const [square, piece] of board) {
        if (!piece) continue;
        const pieceIsWhite = piece === piece.toUpperCase();
        if (pieceIsWhite === isWhite) {
            ourPieces.push({ square, piece });
        }
    }
    
    // Count mutual defense/support
    for (let i = 0; i < ourPieces.length; i++) {
        for (let j = i + 1; j < ourPieces.length; j++) {
            if (v40DoesAttackSquare(board, ourPieces[i].square, ourPieces[j].square, ourPieces[i].piece)) {
                coordination++;
            }
            if (v40DoesAttackSquare(board, ourPieces[j].square, ourPieces[i].square, ourPieces[j].piece)) {
                coordination++;
            }
        }
    }
    
    return coordination;
}

/**
 * v40.35 Helper: Check if two squares are on same line
 */
function isOnSameLine(sq1, sq2) {
    const f1 = sq1[0].charCodeAt(0) - 97;
    const r1 = parseInt(sq1[1]) - 1;
    const f2 = sq2[0].charCodeAt(0) - 97;
    const r2 = parseInt(sq2[1]) - 1;
    
    // Same file, rank, or diagonal
    return f1 === f2 || r1 === r2 || Math.abs(f1 - f2) === Math.abs(r1 - r2);
}

/**
 * v40.35 Helper: Get direction between two squares
 */
function getLineDirection(sq1, sq2) {
    const f1 = sq1[0].charCodeAt(0) - 97;
    const r1 = parseInt(sq1[1]) - 1;
    const f2 = sq2[0].charCodeAt(0) - 97;
    const r2 = parseInt(sq2[1]) - 1;
    
    const dx = Math.sign(f2 - f1);
    const dy = Math.sign(r2 - r1);
    
    return { dx, dy };
}

/**
 * v40.35 Helper: Get square beyond in a direction
 */
function getSquareBeyond(square, direction) {
    const file = square[0].charCodeAt(0) - 97;
    const rank = parseInt(square[1]) - 1;
    
    const newFile = file - direction.dx;
    const newRank = rank - direction.dy;
    
    if (newFile < 0 || newFile > 7 || newRank < 0 || newRank > 7) return null;
    
    return String.fromCharCode(97 + newFile) + (newRank + 1);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
Observation: Edit was successful.