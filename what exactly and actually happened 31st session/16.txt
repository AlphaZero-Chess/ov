Now I'll add the v40.21 functions after the v40.20 function:
Action: file_editor str_replace /app/Lichess Bot-AlphaZero-Pure.user.js --old-str "    } catch (e) {
        debugLog(\"[V40.20_SAFE]\", `Error: ${e.message}`);
    }
    
    return score;
}

// ═══════════════════════════════════════════════════════════════════════════════

/**
 * v40.9 Helper: Find all attacked pieces for a color
 */" --new-str "    } catch (e) {
        debugLog(\"[V40.20_SAFE]\", `Error: ${e.message}`);
    }
    
    return score;
}

// ═══════════════════════════════════════════════════════════════════════════════
// v40.21 DEEP PAWN CHAIN CALCULATION & FORCING LINE DETECTION SUPREME
// From game analysis: Bot missed c4-cxd3-dxc2-cxb1=R promotion sequence!
// This is the MOST CRITICAL missing feature - MUST see pawn promotion sequences
// ═══════════════════════════════════════════════════════════════════════════════

/**
 * v40.21 DEEP PAWN CHAIN EVALUATION: Calculate FULL pawn promotion sequences
 * CRITICAL: This catches sequences like c4-cxd3-dxc2-cxb1=R
 */
function v40DeepPawnChainEval(fen, move, board, activeColor, moveNumber) {
    if (!CONFIG.v40DeepPawnChainEnabled) return 0;
    
    let score = 0;
    const isWhite = activeColor === 'w';
    const enemyColor = isWhite ? 'b' : 'w';
    
    try {
        const fromSquare = move.substring(0, 2);
        const toSquare = move.substring(2, 4);
        const movingPiece = board.get(fromSquare);
        
        if (!movingPiece) return 0;
        
        // Simulate our move
        const afterMove = new Map(board);
        afterMove.delete(fromSquare);
        const capturedPiece = afterMove.get(toSquare);
        afterMove.set(toSquare, movingPiece);
        
        // CRITICAL: Find ALL enemy pawn advancement possibilities
        const enemyPawnChar = enemyColor === 'w' ? 'P' : 'p';
        const pawnDirection = enemyColor === 'w' ? 1 : -1;
        const promotionRank = enemyColor === 'w' ? 8 : 1;
        
        // Collect all enemy pawns
        const enemyPawns = [];
        for (const [sq, piece] of afterMove) {
            if (piece === enemyPawnChar) {
                enemyPawns.push(sq);
            }
        }
        
        // For each enemy pawn, calculate if it can promote through a sequence
        for (const pawnSq of enemyPawns) {
            const pawnFile = pawnSq.charCodeAt(0) - 'a'.charCodeAt(0);
            const pawnRank = parseInt(pawnSq[1]);
            const distanceToPromotion = Math.abs(promotionRank - pawnRank);
            
            // Check immediate advancement
            const nextSquare = String.fromCharCode(pawnFile + 'a'.charCodeAt(0)) + (pawnRank + pawnDirection);
            if (!afterMove.get(nextSquare)) {
                // Pawn can advance!
                if (distanceToPromotion <= 2) {
                    score += CONFIG.v40PromoterOnSecondPenalty;
                    debugLog(\"[V40.21_CHAIN]\", `☠️☠️☠️ CRITICAL: Enemy pawn ${pawnSq} 1-2 moves from promotion!`);
                } else if (distanceToPromotion <= 4) {
                    score += CONFIG.v40AdvancedPasserPenalty;
                    debugLog(\"[V40.21_CHAIN]\", `☠️☠️ Enemy pawn ${pawnSq} ${distanceToPromotion} moves from promotion!`);
                }
            }
            
            // Check diagonal captures that could advance the pawn toward promotion
            for (const df of [-1, 1]) {
                const captureFile = pawnFile + df;
                if (captureFile < 0 || captureFile > 7) continue;
                
                const captureSq = String.fromCharCode(captureFile + 'a'.charCodeAt(0)) + (pawnRank + pawnDirection);
                const targetPiece = afterMove.get(captureSq);
                
                // Can capture our piece?
                if (targetPiece) {
                    const targetIsWhite = targetPiece === targetPiece.toUpperCase();
                    if (targetIsWhite === isWhite) {
                        // Enemy pawn can capture our piece!
                        const newDistance = Math.abs(promotionRank - (pawnRank + pawnDirection));
                        
                        // Check if this capture creates a passed pawn
                        const afterCapture = new Map(afterMove);
                        afterCapture.delete(pawnSq);
                        afterCapture.set(captureSq, enemyPawnChar);
                        
                        if (isPassedPawnV40_21(captureSq, afterCapture, enemyColor)) {
                            score += CONFIG.v40PawnCaptureCreatesPassedPenalty;
                            debugLog(\"[V40.21_CHAIN]\", `☠️☠️☠️ ${pawnSq}x${captureSq} creates PASSED PAWN!`);
                            
                            // If this capture leads to eventual promotion in chain...
                            const canPromoteFromCapture = calculatePromotionChainV40_21(
                                captureSq, afterCapture, enemyColor, CONFIG.v40PawnChainDepth
                            );
                            
                            if (canPromoteFromCapture.canPromote) {
                                score += CONFIG.v40PawnPromotionSequencePenalty;
                                debugLog(\"[V40.21_CHAIN]\", `☠️☠️☠️☠️ PAWN PROMOTION SEQUENCE: ${canPromoteFromCapture.sequence.join('-')}!`);
                            }
                        }
                    }
                }
            }
        }
        
        // CRITICAL: Does our move BLOCK a promotion path?
        if (movingPiece.toLowerCase() !== 'p') {
            const toFile = toSquare.charCodeAt(0) - 'a'.charCodeAt(0);
            const toRank = parseInt(toSquare[1]);
            
            // Check if we're blocking an enemy pawn's path
            for (const pawnSq of enemyPawns) {
                const pawnFile = pawnSq.charCodeAt(0) - 'a'.charCodeAt(0);
                const pawnRank = parseInt(pawnSq[1]);
                
                // Same file and in front of the pawn?
                if (pawnFile === toFile) {
                    const isInFront = enemyColor === 'w' ? 
                        (toRank > pawnRank && toRank <= promotionRank) :
                        (toRank < pawnRank && toRank >= promotionRank);
                    
                    if (isInFront) {
                        score += CONFIG.v40BlockadeBonus;
                        debugLog(\"[V40.21_CHAIN]\", `✅ ${move} BLOCKADES enemy pawn on ${pawnSq}!`);
                    }
                }
            }
        }
        
    } catch (e) {
        debugLog(\"[V40.21_CHAIN]\", `Error: ${e.message}`);
    }
    
    return score;
}

/**
 * v40.21 Helper: Calculate if a pawn can promote through a sequence of moves
 */
function calculatePromotionChainV40_21(startSquare, board, color, maxDepth) {
    const isWhite = color === 'w';
    const direction = isWhite ? 1 : -1;
    const promotionRank = isWhite ? 8 : 1;
    const pawnChar = isWhite ? 'P' : 'p';
    const enemyColor = isWhite ? 'b' : 'w';
    
    const sequence = [];
    let currentBoard = new Map(board);
    let currentSquare = startSquare;
    
    for (let depth = 0; depth < maxDepth; depth++) {
        const file = currentSquare.charCodeAt(0) - 'a'.charCodeAt(0);
        const rank = parseInt(currentSquare[1]);
        
        // Already promoted?
        if (rank === promotionRank) {
            return { canPromote: true, sequence };
        }
        
        // Try straight advance first
        const nextRank = rank + direction;
        const advanceSquare = String.fromCharCode(file + 'a'.charCodeAt(0)) + nextRank;
        
        if (!currentBoard.get(advanceSquare)) {
            // Can advance!
            sequence.push(`${currentSquare}-${advanceSquare}`);
            currentBoard.delete(currentSquare);
            currentBoard.set(advanceSquare, pawnChar);
            currentSquare = advanceSquare;
            
            if (nextRank === promotionRank) {
                return { canPromote: true, sequence };
            }
            continue;
        }
        
        // Try diagonal captures
        for (const df of [-1, 1]) {
            const captureFile = file + df;
            if (captureFile < 0 || captureFile > 7) continue;
            
            const captureSq = String.fromCharCode(captureFile + 'a'.charCodeAt(0)) + nextRank;
            const targetPiece = currentBoard.get(captureSq);
            
            if (targetPiece) {
                const targetIsWhite = targetPiece === targetPiece.toUpperCase();
                // Can capture enemy piece?
                if ((isWhite && !targetIsWhite) || (!isWhite && targetIsWhite)) {
                    sequence.push(`${currentSquare}x${captureSq}`);
                    currentBoard.delete(currentSquare);
                    currentBoard.set(captureSq, pawnChar);
                    currentSquare = captureSq;
                    
                    if (nextRank === promotionRank) {
                        return { canPromote: true, sequence };
                    }
                    break;
                }
            }
        }
        
        // Can't advance - blocked
        if (currentSquare === (depth === 0 ? startSquare : currentSquare)) {
            break;
        }
    }
    
    return { canPromote: false, sequence };
}

/**
 * v40.21 Helper: Check if pawn is passed
 */
function isPassedPawnV40_21(square, board, color) {
    const file = square.charCodeAt(0) - 'a'.charCodeAt(0);
    const rank = parseInt(square[1]);
    const isWhite = color === 'w';
    const enemyPawnChar = isWhite ? 'p' : 'P';
    const direction = isWhite ? 1 : -1;
    const promotionRank = isWhite ? 8 : 1;
    
    // Check all ranks in front of the pawn for enemy pawns
    const adjacentFiles = [file - 1, file, file + 1].filter(f => f >= 0 && f <= 7);
    
    for (let r = rank + direction; isWhite ? r <= promotionRank : r >= promotionRank; r += direction) {
        for (const f of adjacentFiles) {
            const checkSq = String.fromCharCode(f + 'a'.charCodeAt(0)) + r;
            if (board.get(checkSq) === enemyPawnChar) {
                return false;
            }
        }
    }
    
    return true;
}

/**
 * v40.21 FORCING LINE DETECTION: Calculate ALL forcing sequences
 * Forcing = checks, captures, threats that must be answered
 */
function v40ForcingLineDetectionEval(fen, move, board, activeColor, moveNumber) {
    if (!CONFIG.v40DeepPawnChainEnabled) return 0;
    
    let score = 0;
    const isWhite = activeColor === 'w';
    const enemyColor = isWhite ? 'b' : 'w';
    
    try {
        const fromSquare = move.substring(0, 2);
        const toSquare = move.substring(2, 4);
        const movingPiece = board.get(fromSquare);
        
        if (!movingPiece) return 0;
        
        // Simulate our move
        const afterMove = new Map(board);
        afterMove.delete(fromSquare);
        afterMove.set(toSquare, movingPiece);
        
        // CHECK 1: Does our move give a forcing check?
        const enemyKing = findKing(afterMove, enemyColor);
        if (enemyKing && isSquareAttackedByColor(afterMove, enemyKing, activeColor)) {
            score += CONFIG.v40ForcingCheckBonus;
            debugLog(\"[V40.21_FORCE]\", `✅ ${move} gives FORCING CHECK!`);
        }
        
        // CHECK 2: After our move, what forcing sequences does opponent have?
        const opponentForcingDepth = calculateOpponentForcingDepthV40_21(afterMove, enemyColor, 4);
        
        if (opponentForcingDepth.hasForcingSequence) {
            score += CONFIG.v40AllowForcingSequencePenalty * opponentForcingDepth.severity;
            debugLog(\"[V40.21_FORCE]\", `☠️ After ${move}, opponent has forcing sequence: ${opponentForcingDepth.description}`);
        }
        
        // CHECK 3: Does our move create a forcing threat?
        const createsThreat = moveCreatesThreatV40_21(move, board, afterMove, activeColor);
        if (createsThreat.hasThreat) {
            score += CONFIG.v40ForcingThreatBonus;
            debugLog(\"[V40.21_FORCE]\", `✅ ${move} creates threat: ${createsThreat.description}`);
        }
        
    } catch (e) {
        debugLog(\"[V40.21_FORCE]\", `Error: ${e.message}`);
    }
    
    return score;
}

/**
 * v40.21 Helper: Calculate opponent's forcing sequence depth
 */
function calculateOpponentForcingDepthV40_21(board, color, maxDepth) {
    const isWhite = color === 'w';
    const enemyColor = isWhite ? 'b' : 'w';
    const ourKing = findKing(board, enemyColor);
    
    let hasForcingSequence = false;
    let severity = 0;
    let description = '';
    
    // Find immediate forcing moves for opponent
    
    // 1. Check for pawn promotions
    const pawnChar = isWhite ? 'P' : 'p';
    const promotionRank = isWhite ? 7 : 2;
    
    for (const [sq, piece] of board) {
        if (piece !== pawnChar) continue;
        
        const rank = parseInt(sq[1]);
        if (rank === promotionRank) {
            const promoSquare = sq[0] + (isWhite ? '8' : '1');
            if (!board.get(promoSquare)) {
                hasForcingSequence = true;
                severity = 2.0;
                description = `Pawn on ${sq} promotes next move!`;
                return { hasForcingSequence, severity, description };
            }
        }
    }
    
    // 2. Check for checks on our king
    if (ourKing) {
        for (const [sq, piece] of board) {
            if (!piece) continue;
            const pieceIsWhite = piece === piece.toUpperCase();
            if (pieceIsWhite !== isWhite) continue;
            
            // Can this piece deliver check?
            const pieceType = piece.toLowerCase();
            if (['q', 'r', 'b', 'n'].includes(pieceType)) {
                // Simplified: check if piece can reach king
                if (canPieceAttackSquareV40_21(sq, ourKing, pieceType, board)) {
                    hasForcingSequence = true;
                    severity = 1.5;
                    description = `${pieceType.toUpperCase()} on ${sq} threatens check`;
                }
            }
        }
    }
    
    // 3. Check for piece captures
    for (const [sq, piece] of board) {
        if (!piece) continue;
        const pieceIsWhite = piece === piece.toUpperCase();
        if (pieceIsWhite === isWhite) continue; // Our piece
        
        const pieceType = piece.toLowerCase();
        if (pieceType === 'k') continue;
        
        // Is this piece attacked by opponent?
        if (isSquareAttackedByColor(board, sq, color)) {
            if (!isSquareDefendedByColor(board, sq, enemyColor)) {
                hasForcingSequence = true;
                severity = Math.max(severity, 1.0);
                description = description || `${pieceType.toUpperCase()} on ${sq} is hanging`;
            }
        }
    }
    
    return { hasForcingSequence, severity, description };
}

/**
 * v40.21 Helper: Check if piece can attack a square
 */
function canPieceAttackSquareV40_21(fromSq, toSq, pieceType, board) {
    const fromFile = fromSq.charCodeAt(0) - 'a'.charCodeAt(0);
    const fromRank = parseInt(fromSq[1]);
    const toFile = toSq.charCodeAt(0) - 'a'.charCodeAt(0);
    const toRank = parseInt(toSq[1]);
    
    const fileDiff = Math.abs(toFile - fromFile);
    const rankDiff = Math.abs(toRank - fromRank);
    
    switch (pieceType) {
        case 'q':
            // Queen: straight or diagonal
            if (fileDiff === 0 || rankDiff === 0 || fileDiff === rankDiff) {
                return isPathClearV40_21(fromSq, toSq, board);
            }
            break;
        case 'r':
            // Rook: straight lines
            if (fileDiff === 0 || rankDiff === 0) {
                return isPathClearV40_21(fromSq, toSq, board);
            }
            break;
        case 'b':
            // Bishop: diagonals
            if (fileDiff === rankDiff && fileDiff > 0) {
                return isPathClearV40_21(fromSq, toSq, board);
            }
            break;
        case 'n':
            // Knight: L-shape
            if ((fileDiff === 2 && rankDiff === 1) || (fileDiff === 1 && rankDiff === 2)) {
                return true;
            }
            break;
    }
    
    return false;
}

/**
 * v40.21 Helper: Check if path is clear between two squares
 */
function isPathClearV40_21(fromSq, toSq, board) {
    const fromFile = fromSq.charCodeAt(0) - 'a'.charCodeAt(0);
    const fromRank = parseInt(fromSq[1]);
    const toFile = toSq.charCodeAt(0) - 'a'.charCodeAt(0);
    const toRank = parseInt(toSq[1]);
    
    const fileDir = toFile > fromFile ? 1 : (toFile < fromFile ? -1 : 0);
    const rankDir = toRank > fromRank ? 1 : (toRank < fromRank ? -1 : 0);
    
    let f = fromFile + fileDir;
    let r = fromRank + rankDir;
    
    while (f !== toFile || r !== toRank) {
        const sq = String.fromCharCode(f + 'a'.charCodeAt(0)) + r;
        if (board.get(sq)) {
            return false;
        }
        f += fileDir;
        r += rankDir;
    }
    
    return true;
}

/**
 * v40.21 Helper: Does our move create a threat?
 */
function moveCreatesThreatV40_21(move, beforeBoard, afterBoard, activeColor) {
    const toSquare = move.substring(2, 4);
    const enemyColor = activeColor === 'w' ? 'b' : 'w';
    
    // Find enemy pieces now attacked by us that weren't before
    for (const [sq, piece] of afterBoard) {
        if (!piece) continue;
        const pieceIsWhite = piece === piece.toUpperCase();
        if ((pieceIsWhite && activeColor === 'w') || (!pieceIsWhite && activeColor === 'b')) {
            continue; // Our piece
        }
        
        const pieceType = piece.toLowerCase();
        if (pieceType === 'k') continue;
        
        const wasAttacked = isSquareAttackedByColor(beforeBoard, sq, activeColor);
        const isNowAttacked = isSquareAttackedByColor(afterBoard, sq, activeColor);
        
        if (!wasAttacked && isNowAttacked) {
            const pieceValue = getPieceValueSimple(pieceType);
            return {
                hasThreat: true,
                description: `New attack on ${pieceType.toUpperCase()} on ${sq}`,
                value: pieceValue
            };
        }
    }
    
    return { hasThreat: false, description: '', value: 0 };
}

/**
 * v40.21 QUIET MOVE DANGER DETECTION: Innocent-looking moves that lose
 */
function v40QuietMoveDangerEval(fen, move, board, activeColor, moveNumber) {
    if (!CONFIG.v40QuietMoveEnabled) return 0;
    
    let score = 0;
    const isWhite = activeColor === 'w';
    const enemyColor = isWhite ? 'b' : 'w';
    
    try {
        const fromSquare = move.substring(0, 2);
        const toSquare = move.substring(2, 4);
        const movingPiece = board.get(fromSquare);
        
        if (!movingPiece) return 0;
        
        // Is this a quiet move (not a capture or check)?
        const capturedPiece = board.get(toSquare);
        
        // Simulate our move
        const afterMove = new Map(board);
        afterMove.delete(fromSquare);
        afterMove.set(toSquare, movingPiece);
        
        const enemyKing = findKing(afterMove, enemyColor);
        const givesCheck = enemyKing && isSquareAttackedByColor(afterMove, enemyKing, activeColor);
        
        // If no capture and no check, this is a quiet move
        if (!capturedPiece && !givesCheck) {
            // Check if we have pieces that NEED defense right now
            const ourHangingPieces = [];
            for (const [sq, piece] of afterMove) {
                if (!piece) continue;
                const pieceIsWhite = piece === piece.toUpperCase();
                if (pieceIsWhite !== isWhite) continue;
                
                const pieceType = piece.toLowerCase();
                if (pieceType === 'k') continue;
                
                if (isSquareAttackedByColor(afterMove, sq, enemyColor)) {
                    if (!isSquareDefendedByColor(afterMove, sq, activeColor)) {
                        ourHangingPieces.push({ square: sq, piece, value: getPieceValueSimple(pieceType) });
                    }
                }
            }
            
            if (ourHangingPieces.length > 0) {
                const worstHanging = ourHangingPieces.reduce((a, b) => a.value > b.value ? a : b);
                score += CONFIG.v40QuietMoveNoDefensePenalty * (worstHanging.value / 9);
                debugLog(\"[V40.21_QUIET]\", `⚠️ ${move} is quiet but ${worstHanging.piece} on ${worstHanging.square} is hanging!`);
            }
            
            // Check if this quiet move allows opponent tactics
            const opponentTactics = calculateOpponentForcingDepthV40_21(afterMove, enemyColor, 3);
            if (opponentTactics.hasForcingSequence && opponentTactics.severity > 1.0) {
                score += CONFIG.v40QuietMoveAllowsTacticPenalty;
                debugLog(\"[V40.21_QUIET]\", `☠️ ${move} (quiet) allows opponent tactic: ${opponentTactics.description}`);
            }
        }
        
    } catch (e) {
        debugLog(\"[V40.21_QUIET]\", `Error: ${e.message}`);
    }
    
    return score;
}

// ═══════════════════════════════════════════════════════════════════════════════

/**
 * v40.9 Helper: Find all attacked pieces for a color
 */"
Observation: Edit was successful.