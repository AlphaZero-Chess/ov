
Action: file_editor view /app/Lichess Bot-AlphaZero-Pure.user.js
Observation: /app/Lichess Bot-AlphaZero-Pure.user.js:
16620|                    if (!isSquareDefendedByColor(afterMove, toSquare, activeColor)) {
16621|                        score += CONFIG.v40PawnTakesBishopPenalty;
16622|                        debugLog("[V40.20_SAFE]", `☠️ ${move} puts ${movingPiece} where pawn can take it!`);
16623|                    }
16624|                }
16625|            }
16626|        }
16627|        
16628|    } catch (e) {
16629|        debugLog("[V40.20_SAFE]", `Error: ${e.message}`);
16630|    }
16631|    
16632|    return score;
16633|}
16634|
16635|// ═══════════════════════════════════════════════════════════════════════════════
16636|
16637|/**
16638| * v40.9 Helper: Find all attacked pieces for a color
16639| */
16640|function findAttackedPiecesV40_9(board, color) {
16641|    const attacked = [];
16642|    const isWhite = color === 'w';
16643|    const enemyColor = isWhite ? 'b' : 'w';
16644|    
16645|    for (const [square, piece] of board) {
16646|        if (!piece) continue;
16647|        const pieceIsWhite = piece === piece.toUpperCase();
16648|        if (pieceIsWhite !== isWhite) continue;
16649|        
16650|        const pieceType = piece.toLowerCase();
16651|        if (pieceType === 'k') continue;  // King attacks handled separately
16652|        
16653|        // Check if this square is attacked by enemy
16654|        if (isSquareAttackedByColor(board, square, enemyColor)) {
16655|            // Check if it's adequately defended
16656|            const isDefended = isSquareDefendedByColor(board, square, color);
16657|            
16658|            // If attacked by something of lower value, still need to consider
16659|            const attackers = findAttackersOfSquare(board, square, enemyColor);
16660|            const lowestAttackerValue = Math.min(...attackers.map(a => getPieceValueSimple(a.piece.toLowerCase())));
16661|            const ourPieceValue = getPieceValueSimple(pieceType);
16662|            
16663|            // Consider it under attack if:
16664|            // 1. Not defended at all, or
16665|            // 2. Attacker is of lower value than our piece
16666|            if (!isDefended || lowestAttackerValue < ourPieceValue) {
16667|                attacked.push({
16668|                    square,
16669|                    piece,
16670|                    value: ourPieceValue,
16671|                    lowestAttackerValue
16672|                });
16673|            }
16674|        }
16675|    }
16676|    
16677|    // Sort by piece value (highest first - queen, then rook, etc.)
16678|    attacked.sort((a, b) => b.value - a.value);
16679|    
16680|    return attacked;
16681|}
16682|
16683|/**
16684| * v40.9 Helper: Find all hanging pieces (attacked and not defended)
16685| */
16686|function findHangingPiecesV40_9(board, color) {
16687|    const hanging = [];
16688|    const isWhite = color === 'w';
16689|    const enemyColor = isWhite ? 'b' : 'w';
16690|    
16691|    for (const [square, piece] of board) {
16692|        if (!piece) continue;
16693|        const pieceIsWhite = piece === piece.toUpperCase();
16694|        if (pieceIsWhite !== isWhite) continue;
16695|        
16696|        const pieceType = piece.toLowerCase();
16697|        if (pieceType === 'k') continue;
16698|        
16699|        const isAttacked = isSquareAttackedByColor(board, square, enemyColor);
16700|        const isDefended = isSquareDefendedByColor(board, square, color);
