Now let me add the v40.8 functions before the evaluateGoalAlignment function:
Action: file_editor str_replace /app/Lichess Bot-AlphaZero-Pure.user.js --old-str "/**
 * v40: Evaluate goal alignment with strategic plan
 * True AlphaZero evaluates moves based on how well they fit the plan
 */
function evaluateGoalAlignment(move, plan) {" --new-str "// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// v40.8 TRANSCENDENT: ANTI-PASSIVITY & EXCHANGE QUALITY SUPREME FUNCTIONS
// From King's Pawn Game loss: d3 passive, Qc1 passive, Nxd5 bad exchange
// The bot must play ACTIVELY and make QUALITY exchanges only
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/**
 * v40.8 TRANSCENDENT: OPENING AGGRESSION EVALUATION
 * CRITICAL: Prefer d4/e4 over passive d3/e3 moves
 * Prevents: d3 when d4 is possible, passive openings that cede center
 */
function v40OpeningAggressionEval(fen, move, board, activeColor, moveNumber) {
    if (!CONFIG.v40OpeningAggressionEnabled) return 0;
    if (moveNumber > 12) return 0;  // Only in opening
    
    let score = 0;
    const isWhite = activeColor === 'w';
    
    try {
        const fromSquare = move.substring(0, 2);
        const toSquare = move.substring(2, 4);
        const movingPiece = board.get(fromSquare);
        
        if (!movingPiece) return 0;
        
        const pieceType = movingPiece.toLowerCase();
        
        // CHECK 1: Pawn moves - prefer aggressive center pushes
        if (pieceType === 'p') {
            // Check for passive pawn moves (d3, e3 when d4, e4 possible)
            const passivePawnMoves = isWhite ? 
                { 'd3': 'd4', 'e3': 'e4', 'c3': 'c4' } : 
                { 'd6': 'd5', 'e6': 'e5', 'c6': 'c5' };
            
            if (passivePawnMoves[toSquare]) {
                // Check if the aggressive move is possible
                const aggressiveSquare = passivePawnMoves[toSquare];
                const aggressiveFromSquare = isWhite ? 
                    aggressiveSquare[0] + '2' : 
                    aggressiveSquare[0] + '7';
                
                const pawnOnStart = board.get(aggressiveFromSquare);
                const aggressiveSquareBlocked = board.has(aggressiveSquare);
                
                // If aggressive move was possible but we chose passive
                if (pawnOnStart && !aggressiveSquareBlocked && fromSquare === aggressiveFromSquare) {
                    score += CONFIG.v40PassivePawnPenalty || -25000;
                    debugLog(\"[V40.8_AGGRO]\", `ğŸš¨ğŸš¨ PASSIVE PAWN MOVE ${toSquare} when ${aggressiveSquare} possible!`);
                }
            }
            
            // BONUS for aggressive center pawn advances
            const aggressiveCenterSquares = isWhite ? ['d4', 'e4'] : ['d5', 'e5'];
            if (aggressiveCenterSquares.includes(toSquare)) {
                score += CONFIG.v40CenterPawnAdvanceBonus || 15000;
                debugLog(\"[V40.8_AGGRO]\", `âœ… AGGRESSIVE CENTER PAWN TO ${toSquare}!`);
            }
        }
        
        // CHECK 2: By move 5, we should have center presence
        if (moveNumber >= 5) {
            const hasCenterPawn = hasCenterPawnPresence(board, activeColor);
            if (!hasCenterPawn) {
                score += CONFIG.v40CenterPawnAbsenceEarlyPenalty || -25000;
                debugLog(\"[V40.8_AGGRO]\", `ğŸš¨ NO CENTER PAWN PRESENCE BY MOVE ${moveNumber}!`);
            }
        }
        
    } catch (e) {
        debugLog(\"[V40.8_AGGRO]\", `Error: ${e.message}`);
    }
    
    return score;
}

/**
 * v40.8 TRANSCENDENT: EXCHANGE QUALITY EVALUATION
 * CRITICAL: Don't trade pieces that help opponent (like Nxd5 bringing queen to center)
 * Prevents: Bad exchanges that centralize enemy pieces
 */
function v40ExchangeQualityEval(fen, move, board, activeColor) {
    if (!CONFIG.v40ExchangeQualityEnabled) return 0;
    
    let score = 0;
    const enemyColor = activeColor === 'w' ? 'b' : 'w';
    
    try {
        const fromSquare = move.substring(0, 2);
        const toSquare = move.substring(2, 4);
        const movingPiece = board.get(fromSquare);
        const capturedPiece = board.get(toSquare);
        
        if (!movingPiece || !capturedPiece) return 0; // Not a capture
        
        const capturedIsEnemy = (capturedPiece === capturedPiece.toUpperCase()) !== (activeColor === 'w');
        if (!capturedIsEnemy) return 0;
        
        const movingType = movingPiece.toLowerCase();
        const capturedType = capturedPiece.toLowerCase();
        
        // CHECK 1: Are we trading a piece that will bring enemy piece to good square?
        // Simulate the position after our capture
        const simBoard = new Map(board);
        simBoard.delete(fromSquare);
        simBoard.set(toSquare, movingPiece);
        
        // Check if enemy can recapture
        const canRecapture = canEnemyRecaptureOn(simBoard, toSquare, enemyColor);
        
        if (canRecapture) {
            // What piece will recapture?
            const recapturePiece = findRecapturePiece(simBoard, toSquare, enemyColor);
            
            if (recapturePiece) {
                const recaptureType = recapturePiece.piece.toLowerCase();
                
                // If QUEEN will recapture to center, BAD!
                if (recaptureType === 'q') {
                    const toFile = toSquare.charCodeAt(0) - 'a'.charCodeAt(0);
                    const toRank = parseInt(toSquare[1]) - 1;
                    
                    // Is target square central?
                    const isCentral = (toFile >= 2 && toFile <= 5) && (toRank >= 2 && toRank <= 5);
                    
                    if (isCentral) {
                        score += CONFIG.v40QueenCentralizationPenalty || -20000;
                        debugLog(\"[V40.8_EXCHANGE]\", `ğŸš¨ğŸš¨ EXCHANGE CENTRALIZES ENEMY QUEEN ON ${toSquare}!`);
                    }
                }
                
                // If we're trading from good square to let enemy take good square
                const ourPieceWasActive = isPieceActive(fromSquare, board, activeColor);
                const recaptureSquareIsGood = isGoodSquare(toSquare, enemyColor);
                
                if (ourPieceWasActive && recaptureSquareIsGood) {
                    score += CONFIG.v40BadExchangePenalty || -30000;
                    debugLog(\"[V40.8_EXCHANGE]\", `ğŸš¨ BAD EXCHANGE: Our active piece enables enemy activation!`);
                }
            }
        }
        
        // BONUS: Trading inactive piece for active enemy piece
        const ourPieceWasInactive = !isPieceActive(fromSquare, board, activeColor);
        const capturedWasActive = isPieceActive(toSquare, board, enemyColor);
        
        if (ourPieceWasInactive && capturedWasActive) {
            score += CONFIG.v40GoodExchangeBonus || 10000;
            debugLog(\"[V40.8_EXCHANGE]\", `âœ… GOOD EXCHANGE: Traded inactive for active!`);
        }
        
    } catch (e) {
        debugLog(\"[V40.8_EXCHANGE]\", `Error: ${e.message}`);
    }
    
    return score;
}

/**
 * v40.8 TRANSCENDENT: ACTIVE PIECE REQUIREMENT
 * CRITICAL: All pieces must be active, idle pieces are penalized heavily
 */
function v40ActivePieceRequirementEval(fen, move, board, activeColor, moveNumber) {
    if (!CONFIG.v40ActivePieceRequirementEnabled) return 0;
    if (moveNumber < 8) return 0;  // Give time to develop
    
    let score = 0;
    
    try {
        // Simulate our move
        const simBoard = new Map(board);
        const fromSquare = move.substring(0, 2);
        const toSquare = move.substring(2, 4);
        const movingPiece = board.get(fromSquare);
        
        if (movingPiece) {
            simBoard.delete(fromSquare);
            simBoard.set(toSquare, movingPiece);
        }
        
        // Count active pieces after move
        const activePieces = countActivePiecesV40_8(simBoard, activeColor);
        const totalPieces = countTotalPieces(simBoard, activeColor);
        
        // Penalty for idle pieces
        const idlePieces = totalPieces - activePieces;
        if (idlePieces > 0) {
            score += idlePieces * (CONFIG.v40IdlePieceHeavyPenalty || -15000);
            debugLog(\"[V40.8_ACTIVE]\", `ğŸš¨ ${idlePieces} IDLE PIECES!`);
        }
        
        // Bonus if all pieces active
        if (activePieces >= (CONFIG.v40MinimumActivePieces || 5)) {
            score += CONFIG.v40AllPiecesActiveBonu || 12000;
            debugLog(\"[V40.8_ACTIVE]\", `âœ… All pieces active!`);
        }
        
        // Does this move activate an idle piece?
        const wasIdle = !isPieceActive(fromSquare, board, activeColor);
        const nowActive = isPieceActive(toSquare, simBoard, activeColor);
        
        if (wasIdle && nowActive) {
            score += 8000;
            debugLog(\"[V40.8_ACTIVE]\", `âœ… ACTIVATED idle piece!`);
        }
        
    } catch (e) {
        debugLog(\"[V40.8_ACTIVE]\", `Error: ${e.message}`);
    }
    
    return score;
}

/**
 * v40.8 TRANSCENDENT: COUNTERPLAY GENERATION
 * CRITICAL: When under attack, must create counterplay, not just defend
 */
function v40CounterplayGenerationEval(fen, move, board, activeColor, moveNumber) {
    if (!CONFIG.v40CounterplayGenerationEnabled) return 0;
    
    let score = 0;
    const enemyColor = activeColor === 'w' ? 'b' : 'w';
    
    try {
        // Are we under pressure?
        const underPressure = isPositionUnderPressure(board, activeColor);
        
        if (!underPressure) return 0;  // No pressure, no need for counterplay
        
        // Simulate our move
        const simBoard = new Map(board);
        const fromSquare = move.substring(0, 2);
        const toSquare = move.substring(2, 4);
        const movingPiece = board.get(fromSquare);
        
        if (movingPiece) {
            simBoard.delete(fromSquare);
            simBoard.set(toSquare, movingPiece);
        }
        
        // Does our move create counterplay?
        const createsCounterplay = doesMoveCreateCounterplay(move, simBoard, activeColor);
        const isPureDefense = isMoveDefensiveOnly(move, board, activeColor);
        
        if (createsCounterplay) {
            score += CONFIG.v40CounterplayBonus || 8000;
            debugLog(\"[V40.8_COUNTER]\", `âœ… COUNTERPLAY CREATED!`);
        } else if (isPureDefense) {
            score += CONFIG.v40DefenseOnlyPenalty || -12000;
            debugLog(\"[V40.8_COUNTER]\", `âš ï¸ PURE DEFENSE - no counterplay`);
        } else {
            score += CONFIG.v40NoCounterplayPenalty || -18000;
            debugLog(\"[V40.8_COUNTER]\", `ğŸš¨ UNDER PRESSURE WITH NO COUNTERPLAY!`);
        }
        
    } catch (e) {
        debugLog(\"[V40.8_COUNTER]\", `Error: ${e.message}`);
    }
    
    return score;
}

/**
 * v40.8 TRANSCENDENT: CENTRAL CONTROL SUPREME
 * CRITICAL: Center control is absolutely paramount
 */
function v40CentralControlSupremeEval(fen, move, board, activeColor, moveNumber) {
    if (!CONFIG.v40CentralControlSupremeEnabled) return 0;
    
    let score = 0;
    
    try {
        // Simulate our move
        const simBoard = new Map(board);
        const fromSquare = move.substring(0, 2);
        const toSquare = move.substring(2, 4);
        const movingPiece = board.get(fromSquare);
        
        if (movingPiece) {
            simBoard.delete(fromSquare);
            simBoard.set(toSquare, movingPiece);
        }
        
        // Calculate center control after move
        const centerControl = calculateCenterControlV40_8(simBoard, activeColor);
        const enemyCenterControl = calculateCenterControlV40_8(simBoard, activeColor === 'w' ? 'b' : 'w');
        
        // Dominance bonus
        if (centerControl > enemyCenterControl + 2) {
            score += CONFIG.v40CenterDominanceBonus || 15000;
            debugLog(\"[V40.8_CENTER]\", `âœ… CENTER DOMINANCE! ${centerControl} vs ${enemyCenterControl}`);
        }
        
        // Penalty for no control
        if (centerControl < 2 && moveNumber > 6) {
            score += CONFIG.v40NoCenterControlPenalty || -20000;
            debugLog(\"[V40.8_CENTER]\", `ğŸš¨ NO CENTER CONTROL!`);
        }
        
        // Bonus for moves that increase center control
        const preMoveControl = calculateCenterControlV40_8(board, activeColor);
        if (centerControl > preMoveControl) {
            score += (centerControl - preMoveControl) * 5000;
            debugLog(\"[V40.8_CENTER]\", `âœ… IMPROVED CENTER CONTROL by ${centerControl - preMoveControl}`);
        }
        
    } catch (e) {
        debugLog(\"[V40.8_CENTER]\", `Error: ${e.message}`);
    }
    
    return score;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// v40.8 TRANSCENDENT: HELPER FUNCTIONS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/**
 * v40.8 Helper: Check if we have center pawn presence
 */
function hasCenterPawnPresence(board, color) {
    const isWhite = color === 'w';
    const centerSquares = ['d4', 'd5', 'e4', 'e5'];
    const extendedCenter = ['c4', 'c5', 'f4', 'f5'];
    
    for (const sq of centerSquares) {
        const piece = board.get(sq);
        if (piece && piece.toLowerCase() === 'p') {
            const pieceIsWhite = piece === piece.toUpperCase();
            if (pieceIsWhite === isWhite) return true;
        }
    }
    
    // Check extended center
    for (const sq of extendedCenter) {
        const piece = board.get(sq);
        if (piece && piece.toLowerCase() === 'p') {
            const pieceIsWhite = piece === piece.toUpperCase();
            if (pieceIsWhite === isWhite) return true;
        }
    }
    
    return false;
}

/**
 * v40.8 Helper: Check if enemy can recapture on square
 */
function canEnemyRecaptureOn(board, square, enemyColor) {
    return isSquareAttackedByColor(board, square, enemyColor);
}

/**
 * v40.8 Helper: Find which piece will recapture
 */
function findRecapturePiece(board, square, color) {
    const isWhite = color === 'w';
    const file = square.charCodeAt(0) - 'a'.charCodeAt(0);
    const rank = parseInt(square[1]) - 1;
    
    let lowestValuePiece = null;
    let lowestValue = Infinity;
    
    for (const [sq, piece] of board) {
        if (!piece) continue;
        const pieceIsWhite = piece === piece.toUpperCase();
        if (pieceIsWhite !== isWhite) continue;
        
        const pieceType = piece.toLowerCase();
        const pFile = sq.charCodeAt(0) - 'a'.charCodeAt(0);
        const pRank = parseInt(sq[1]) - 1;
        
        if (canPieceAttackSquareV40(pieceType, pFile, pRank, file, rank, board, color)) {
            const value = getPieceValueSimple(pieceType);
            if (value < lowestValue) {
                lowestValue = value;
                lowestValuePiece = { square: sq, piece: piece };
            }
        }
    }
    
    return lowestValuePiece;
}

/**
 * v40.8 Helper: Check if piece is on an active square
 */
function isPieceActive(square, board, color) {
    const piece = board.get(square);
    if (!piece) return false;
    
    const file = square.charCodeAt(0) - 'a'.charCodeAt(0);
    const rank = parseInt(square[1]) - 1;
    const pieceType = piece.toLowerCase();
    const isWhite = color === 'w';
    
    // Knights: active if on central/good outpost squares
    if (pieceType === 'n') {
        const goodSquares = ['c3', 'c6', 'f3', 'f6', 'd4', 'd5', 'e4', 'e5', 'c4', 'c5', 'f4', 'f5'];
        return goodSquares.includes(square);
    }
    
    // Bishops: active if not on starting square and has diagonal mobility
    if (pieceType === 'b') {
        const startSquares = isWhite ? ['c1', 'f1'] : ['c8', 'f8'];
        if (startSquares.includes(square)) return false;
        return countDiagonalMobility(square, board) >= 3;
    }
    
    // Rooks: active if on open file or 7th rank
    if (pieceType === 'r') {
        const startSquares = isWhite ? ['a1', 'h1'] : ['a8', 'h8'];
        if (startSquares.includes(square)) return false;
        const isOnOpenFile = isOpenFile(square[0], board);
        const isOn7th = isWhite ? (rank === 6) : (rank === 1);
        return isOnOpenFile || isOn7th;
    }
    
    // Queen: active if not on starting square and not blocked
    if (pieceType === 'q') {
        const startSquare = isWhite ? 'd1' : 'd8';
        if (square === startSquare) return false;
        return true;
    }
    
    return true;
}

/**
 * v40.8 Helper: Check if square is good for enemy
 */
function isGoodSquare(square, color) {
    const file = square.charCodeAt(0) - 'a'.charCodeAt(0);
    const rank = parseInt(square[1]) - 1;
    const isWhite = color === 'w';
    
    // Central squares are good
    if (file >= 2 && file <= 5 && rank >= 2 && rank <= 5) return true;
    
    // 7th rank is good
    if ((isWhite && rank === 6) || (!isWhite && rank === 1)) return true;
    
    return false;
}

/**
 * v40.8 Helper: Count active pieces
 */
function countActivePiecesV40_8(board, color) {
    let count = 0;
    const isWhite = color === 'w';
    
    for (const [square, piece] of board) {
        if (!piece) continue;
        const pieceIsWhite = piece === piece.toUpperCase();
        if (pieceIsWhite !== isWhite) continue;
        
        const pieceType = piece.toLowerCase();
        if (pieceType === 'k' || pieceType === 'p') continue;  // Don't count king/pawns
        
        if (isPieceActive(square, board, color)) {
            count++;
        }
    }
    
    return count;
}

/**
 * v40.8 Helper: Count total pieces (excluding king and pawns)
 */
function countTotalPieces(board, color) {
    let count = 0;
    const isWhite = color === 'w';
    
    for (const [square, piece] of board) {
        if (!piece) continue;
        const pieceIsWhite = piece === piece.toUpperCase();
        if (pieceIsWhite !== isWhite) continue;
        
        const pieceType = piece.toLowerCase();
        if (pieceType === 'k' || pieceType === 'p') continue;
        count++;
    }
    
    return count;
}

/**
 * v40.8 Helper: Is position under pressure?
 */
function isPositionUnderPressure(board, color) {
    const enemyColor = color === 'w' ? 'b' : 'w';
    const isWhite = color === 'w';
    
    // Find our king
    let kingSquare = null;
    for (const [sq, piece] of board) {
        if (piece && piece.toLowerCase() === 'k') {
            const pieceIsWhite = piece === piece.toUpperCase();
            if (pieceIsWhite === isWhite) {
                kingSquare = sq;
                break;
            }
        }
    }
    
    if (!kingSquare) return false;
    
    // Check if king is attacked or nearby squares attacked
    const kingFile = kingSquare.charCodeAt(0) - 'a'.charCodeAt(0);
    const kingRank = parseInt(kingSquare[1]) - 1;
    
    let attackedSquaresNearKing = 0;
    
    for (let df = -1; df <= 1; df++) {
        for (let dr = -1; dr <= 1; dr++) {
            const f = kingFile + df;
            const r = kingRank + dr;
            if (f >= 0 && f <= 7 && r >= 0 && r <= 7) {
                const sq = String.fromCharCode(f + 97) + (r + 1);
                if (isSquareAttackedByColor(board, sq, enemyColor)) {
                    attackedSquaresNearKing++;
                }
            }
        }
    }
    
    return attackedSquaresNearKing >= 3;  // King area is under pressure
}

/**
 * v40.8 Helper: Does move create counterplay?
 */
function doesMoveCreateCounterplay(move, board, color) {
    const toSquare = move.substring(2, 4);
    const enemyColor = color === 'w' ? 'b' : 'w';
    
    // Check if move attacks enemy pieces
    const movingPiece = board.get(toSquare);
    if (!movingPiece) return false;
    
    const pieceType = movingPiece.toLowerCase();
    const file = toSquare.charCodeAt(0) - 'a'.charCodeAt(0);
    const rank = parseInt(toSquare[1]) - 1;
    
    // Check if we're attacking enemy pieces
    for (const [sq, piece] of board) {
        if (!piece) continue;
        const pieceIsWhite = piece === piece.toUpperCase();
        const pieceIsEnemy = (pieceIsWhite) !== (color === 'w');
        if (!pieceIsEnemy) continue;
        
        const targetFile = sq.charCodeAt(0) - 'a'.charCodeAt(0);
        const targetRank = parseInt(sq[1]) - 1;
        
        if (canPieceAttackSquareV40(pieceType, file, rank, targetFile, targetRank, board, color)) {
            const targetValue = getPieceValueSimple(piece.toLowerCase());
            if (targetValue >= 300) {  // Attacking valuable piece
                return true;
            }
        }
    }
    
    return false;
}

/**
 * v40.8 Helper: Is move purely defensive?
 */
function isMoveDefensiveOnly(move, board, color) {
    const fromSquare = move.substring(0, 2);
    const toSquare = move.substring(2, 4);
    const movingPiece = board.get(fromSquare);
    
    if (!movingPiece) return false;
    
    const isWhite = color === 'w';
    const pieceType = movingPiece.toLowerCase();
    
    // Check if piece was attacked and moved away
    const wasAttacked = isSquareAttackedByColor(board, fromSquare, isWhite ? 'b' : 'w');
    
    // Check if move doesn't create any threats
    const simBoard = new Map(board);
    simBoard.delete(fromSquare);
    simBoard.set(toSquare, movingPiece);
    
    const createsThreats = doesMoveCreateCounterplay(move, simBoard, color);
    
    return wasAttacked && !createsThreats;
}

/**
 * v40.8 Helper: Calculate center control score
 */
function calculateCenterControlV40_8(board, color) {
    let control = 0;
    const isWhite = color === 'w';
    const centerSquares = ['d4', 'd5', 'e4', 'e5'];
    const extendedCenter = ['c3', 'c4', 'c5', 'c6', 'd3', 'd6', 'e3', 'e6', 'f3', 'f4', 'f5', 'f6'];
    
    // Pure center squares worth more
    for (const sq of centerSquares) {
        const piece = board.get(sq);
        if (piece) {
            const pieceIsWhite = piece === piece.toUpperCase();
            if (pieceIsWhite === isWhite) {
                control += 2;
            }
        }
        
        // Also count attacks on center
        if (isSquareAttackedByColor(board, sq, color)) {
            control += 1;
        }
    }
    
    // Extended center
    for (const sq of extendedCenter) {
        const piece = board.get(sq);
        if (piece) {
            const pieceIsWhite = piece === piece.toUpperCase();
            if (pieceIsWhite === isWhite) {
                control += 1;
            }
        }
    }
    
    return control;
}

/**
 * v40.8 Helper: Count diagonal mobility for bishop
 */
function countDiagonalMobility(square, board) {
    const file = square.charCodeAt(0) - 'a'.charCodeAt(0);
    const rank = parseInt(square[1]) - 1;
    let mobility = 0;
    
    const directions = [[1, 1], [1, -1], [-1, 1], [-1, -1]];
    
    for (const [df, dr] of directions) {
        let f = file + df;
        let r = rank + dr;
        
        while (f >= 0 && f <= 7 && r >= 0 && r <= 7) {
            const sq = String.fromCharCode(f + 97) + (r + 1);
            if (board.get(sq)) break;  // Blocked
            mobility++;
            f += df;
            r += dr;
        }
    }
    
    return mobility;
}

/**
 * v40: Evaluate goal alignment with strategic plan
 * True AlphaZero evaluates moves based on how well they fit the plan
 */
function evaluateGoalAlignment(move, plan) {"
Observation: Edit was successful.