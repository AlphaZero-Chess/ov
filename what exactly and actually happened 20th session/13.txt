Now let me add the v40.10 GODLIKE evaluation functions after line 10152:
Action: file_editor str_replace /app/Lichess Bot-AlphaZero-Pure.user.js --old-str "    return score;
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// v40.9 OMNISCIENT: HELPER FUNCTIONS
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê" --new-str "    return score;
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// v40.10 GODLIKE: ABSOLUTE OPENING ENFORCEMENT
// From latest loss: Bot STILL played d3 instead of d4!
// This is THE FINAL fix - d3 when d4 is possible = ABSOLUTE DEATH PENALTY
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

/**
 * v40.10 GODLIKE: ABSOLUTE D4>D3 ENFORCEMENT
 * CRITICAL: This function ensures bot NEVER plays d3 when d4 is possible
 * The penalty is so severe that no other evaluation can override it
 */
function v40AbsoluteOpeningEnforcementEval(fen, move, board, activeColor, moveNumber) {
    if (!CONFIG.v40AbsoluteOpeningEnforcementEnabled) return 0;
    if (moveNumber > 15) return 0;  // Opening only
    
    let score = 0;
    const isWhite = activeColor === 'w';
    
    try {
        const fromSquare = move.substring(0, 2);
        const toSquare = move.substring(2, 4);
        const movingPiece = board.get(fromSquare);
        
        if (!movingPiece) return 0;
        
        const pieceType = movingPiece.toLowerCase();
        
        // ABSOLUTE RULE: If pawn move to d3/e3 (for white) or d6/e6 (for black)
        if (pieceType === 'p') {
            if (isWhite) {
                // CHECK: Is this d2-d3 when d2-d4 is possible?
                if (fromSquare === 'd2' && toSquare === 'd3') {
                    // Is d4 blocked or is there a reason to not play d4?
                    const d4Blocked = board.has('d4');
                    const d4Attacked = isSquareAttackedByColor(board, 'd4', 'b');
                    
                    if (!d4Blocked) {
                        // d4 is NOT blocked - playing d3 is ABSOLUTE DEATH
                        score += CONFIG.v40D3WhenD4PossiblePenalty || -1000000;
                        debugLog(\"[V40.10_GODLIKE]\", `‚ò†Ô∏è‚ò†Ô∏è‚ò†Ô∏è ABSOLUTE DEATH PENALTY: d3 when d4 is possible! (-1000000)`);
                        debugLog(\"[V40.10_GODLIKE]\", `   NEVER play d3 when d4 is available!`);
                    }
                }
                
                // CHECK: Is this e2-e3 when e2-e4 is possible?
                if (fromSquare === 'e2' && toSquare === 'e3') {
                    const e4Blocked = board.has('e4');
                    
                    if (!e4Blocked) {
                        score += CONFIG.v40E3WhenE4PossiblePenalty || -1000000;
                        debugLog(\"[V40.10_GODLIKE]\", `‚ò†Ô∏è‚ò†Ô∏è‚ò†Ô∏è ABSOLUTE DEATH PENALTY: e3 when e4 is possible! (-1000000)`);
                    }
                }
                
                // BONUS: Playing d4 or e4 gets MASSIVE bonus
                if (toSquare === 'd4' && fromSquare === 'd2') {
                    score += CONFIG.v40D4BonusMultiplier || 100000;
                    debugLog(\"[V40.10_GODLIKE]\", `‚úÖ‚úÖ‚úÖ EXCELLENT: d4 central pawn advance! (+100000)`);
                }
                
                if (toSquare === 'e4' && fromSquare === 'e2') {
                    score += CONFIG.v40E4BonusMultiplier || 100000;
                    debugLog(\"[V40.10_GODLIKE]\", `‚úÖ‚úÖ‚úÖ EXCELLENT: e4 central pawn advance! (+100000)`);
                }
                
            } else {
                // Black side
                if (fromSquare === 'd7' && toSquare === 'd6') {
                    const d5Blocked = board.has('d5');
                    
                    if (!d5Blocked) {
                        score += CONFIG.v40D3WhenD4PossiblePenalty || -1000000;
                        debugLog(\"[V40.10_GODLIKE]\", `‚ò†Ô∏è‚ò†Ô∏è‚ò†Ô∏è ABSOLUTE DEATH PENALTY: d6 when d5 is possible! (-1000000)`);
                    }
                }
                
                if (fromSquare === 'e7' && toSquare === 'e6') {
                    const e5Blocked = board.has('e5');
                    
                    if (!e5Blocked && !board.has('e4')) {
                        // Only penalty if e4 is not controlled by white pawn
                        score += CONFIG.v40E3WhenE4PossiblePenalty / 2 || -500000;
                        debugLog(\"[V40.10_GODLIKE]\", `‚ö†Ô∏è PENALTY: e6 when e5 might be possible`);
                    }
                }
                
                if (toSquare === 'd5' && fromSquare === 'd7') {
                    score += CONFIG.v40D4BonusMultiplier || 100000;
                    debugLog(\"[V40.10_GODLIKE]\", `‚úÖ‚úÖ‚úÖ EXCELLENT: d5 central pawn advance! (+100000)`);
                }
                
                if (toSquare === 'e5' && fromSquare === 'e7') {
                    score += CONFIG.v40E4BonusMultiplier || 100000;
                    debugLog(\"[V40.10_GODLIKE]\", `‚úÖ‚úÖ‚úÖ EXCELLENT: e5 central pawn advance! (+100000)`);
                }
            }
        }
        
    } catch (e) {
        debugLog(\"[V40.10_GODLIKE]\", `Error: ${e.message}`);
    }
    
    return score;
}

/**
 * v40.10 GODLIKE: GREEK GIFT SACRIFICE DEFENSE
 * Detects and defends against Bxh2+/Bxh7+ sacrifice patterns
 * Classic attack: Bishop sacs on h2/h7, followed by Ng5+ and Qh5 (or Qh4)
 */
function v40GreekGiftDefenseEval(fen, move, board, activeColor, moveNumber) {
    if (!CONFIG.v40GreekGiftDefenseEnabled) return 0;
    if (moveNumber < 8) return 0;  // Greek Gift usually happens after development
    
    let score = 0;
    const isWhite = activeColor === 'w';
    
    try {
        const toSquare = move.substring(2, 4);
        const fromSquare = move.substring(0, 2);
        
        // Find our king and castling status
        const kingSquare = findKingSquare(board, activeColor);
        const hasCastledKingside = isWhite ? 
            (kingSquare === 'g1' || kingSquare === 'h1') : 
            (kingSquare === 'g8' || kingSquare === 'h8');
        
        if (!hasCastledKingside) return 0;  // Greek Gift only works against castled king
        
        // Critical squares for Greek Gift
        const sacrificeSquare = isWhite ? 'h2' : 'h7';  // h-pawn square
        const gSquare = isWhite ? 'g2' : 'g7';          // g-pawn square
        const fSquare = isWhite ? 'f2' : 'f7';          // f-pawn square
        
        // Check if enemy bishop can reach the sacrifice square
        const enemyColor = isWhite ? 'b' : 'w';
        const enemyBishops = findPiecesOfType(board, 'b', enemyColor);
        
        for (const bishopSquare of enemyBishops) {
            // Check if bishop is on a diagonal that can reach h2/h7
            if (canBishopReach(bishopSquare, sacrificeSquare)) {
                // Check if the sacrifice square is vulnerable
                const hPawn = board.get(sacrificeSquare);
                
                if (hPawn && hPawn.toLowerCase() === 'p') {
                    // There's a pawn on h2/h7 - check if it's defended enough
                    const defenderCount = countDefendersOfSquare(board, sacrificeSquare, activeColor);
                    const attackerCount = countAttackersOfSquare(board, sacrificeSquare, enemyColor);
                    
                    // Check if enemy knight can follow up with Ng5/Ng4
                    const enemyKnights = findPiecesOfType(board, 'n', enemyColor);
                    const knightFollowUp = isWhite ? 'g5' : 'g4';
                    let canKnightFollowUp = false;
                    
                    for (const knightSquare of enemyKnights) {
                        if (canKnightReach(knightSquare, knightFollowUp)) {
                            canKnightFollowUp = true;
                            break;
                        }
                    }
                    
                    // Check if enemy queen can join attack
                    const enemyQueen = findPiecesOfType(board, 'q', enemyColor);
                    const hasQueenSupport = enemyQueen.length > 0;
                    
                    // If all conditions for Greek Gift exist
                    if (attackerCount >= defenderCount && canKnightFollowUp && hasQueenSupport) {
                        // GREEK GIFT IS POSSIBLE! Huge penalty if we don't address it
                        
                        // Check if our move defends against it
                        const movingPiece = board.get(fromSquare);
                        const isDefensiveMove = 
                            toSquare === sacrificeSquare ||  // Moving to defend h2/h7
                            toSquare === gSquare ||          // Defending g2/g7
                            (movingPiece && movingPiece.toLowerCase() === 'n' && toSquare === (isWhite ? 'f3' : 'f6')) ||  // Knight to f3/f6
                            (movingPiece && movingPiece.toLowerCase() === 'r' && toSquare === (isWhite ? 'e1' : 'e8'));   // Rook to e-file
                        
                        if (isDefensiveMove) {
                            score += CONFIG.v40GreekGiftPreventionBonus || 200000;
                            debugLog(\"[V40.10_GREEK]\", `‚úÖ Move ${move} helps defend against Greek Gift!`);
                        } else {
                            // Move doesn't address Greek Gift threat
                            score += CONFIG.v40GreekGiftThreatPenalty || -500000;
                            debugLog(\"[V40.10_GREEK]\", `üö®üö®üö® GREEK GIFT THREAT! Move ${move} doesn't defend h2/h7!`);
                        }
                    }
                }
            }
        }
        
    } catch (e) {
        debugLog(\"[V40.10_GREEK]\", `Error: ${e.message}`);
    }
    
    return score;
}

/**
 * v40.10 GODLIKE: KING HUNT DETECTION
 * Detects when our king is being actively hunted by enemy pieces
 * Signs: Multiple pieces aiming at king, checks possible, no safe squares
 */
function v40KingHuntDetectionEval(fen, move, board, activeColor, moveNumber) {
    if (!CONFIG.v40KingHuntDetectionEnabled) return 0;
    
    let score = 0;
    const isWhite = activeColor === 'w';
    const enemyColor = isWhite ? 'b' : 'w';
    
    try {
        const kingSquare = findKingSquare(board, activeColor);
        if (!kingSquare) return 0;
        
        const kingFile = kingSquare.charCodeAt(0);
        const kingRank = parseInt(kingSquare[1]);
        
        // Count attackers near the king
        let attackersNearKing = 0;
        let checksAvailable = 0;
        
        // Check each enemy piece
        for (const [square, piece] of board) {
            if (!piece) continue;
            
            const pieceColor = piece === piece.toUpperCase() ? 'w' : 'b';
            if (pieceColor !== enemyColor) continue;
            
            const pieceType = piece.toLowerCase();
            const sqFile = square.charCodeAt(0);
            const sqRank = parseInt(square[1]);
            
            // Distance to king
            const fileDist = Math.abs(sqFile - kingFile);
            const rankDist = Math.abs(sqRank - kingRank);
            const maxDist = Math.max(fileDist, rankDist);
            
            // Count attackers within 3 squares of king
            if (maxDist <= 3) {
                if (pieceType === 'q') attackersNearKing += 3;
                else if (pieceType === 'r') attackersNearKing += 2;
                else if (pieceType === 'b' || pieceType === 'n') attackersNearKing += 1;
            }
            
            // Check if piece can give check
            if (canPieceAttackSquare(board, square, kingSquare, piece)) {
                checksAvailable++;
            }
        }
        
        // King is being hunted if many attackers near and checks available
        const isBeingHunted = attackersNearKing >= 4 || (attackersNearKing >= 2 && checksAvailable >= 2);
        
        if (isBeingHunted) {
            // Simulate our move
            const fromSquare = move.substring(0, 2);
            const toSquare = move.substring(2, 4);
            const movingPiece = board.get(fromSquare);
            
            // Check if move helps defend king
            const simBoard = new Map(board);
            simBoard.delete(fromSquare);
            if (movingPiece) simBoard.set(toSquare, movingPiece);
            
            // Count defenders around king after move
            const kingFile2 = toSquare === kingSquare ? toSquare.charCodeAt(0) : kingSquare.charCodeAt(0);
            const kingRank2 = toSquare === kingSquare ? parseInt(toSquare[1]) : kingRank;
            
            let defendersAfterMove = 0;
            for (const [sq, pc] of simBoard) {
                if (!pc) continue;
                const pcColor = pc === pc.toUpperCase() ? 'w' : 'b';
                if (pcColor !== activeColor) continue;
                
                const sqF = sq.charCodeAt(0);
                const sqR = parseInt(sq[1]);
                const maxD = Math.max(Math.abs(sqF - kingFile2), Math.abs(sqR - kingRank2));
                
                if (maxD <= 2 && pc.toLowerCase() !== 'k') {
                    defendersAfterMove++;
                }
            }
            
            // If move is king moving to more dangerous square
            if (movingPiece && movingPiece.toLowerCase() === 'k') {
                const toFile = toSquare.charCodeAt(0);
                const toRank = parseInt(toSquare[1]);
                
                // Check if king is going to more exposed position
                const attackersAtNewSquare = countAttackersOfSquare(simBoard, toSquare, enemyColor);
                
                if (attackersAtNewSquare > 0) {
                    score += (CONFIG.v40KingHuntPenalty || -400000) * attackersAtNewSquare;
                    debugLog(\"[V40.10_HUNT]\", `üö®üö® KING WALKING INTO DANGER! ${move} leads to ${attackersAtNewSquare} attackers!`);
                }
            }
            
            // If move brings defenders to king
            if (defendersAfterMove > 0 && !isSquareAttackedByColor(simBoard, toSquare, enemyColor)) {
                score += CONFIG.v40KingEscapeBonus || 300000;
                debugLog(\"[V40.10_HUNT]\", `‚úÖ Move ${move} brings defenders to king!`);
            } else if (attackersNearKing >= 4) {
                // King hunt in progress and we're not defending
                score += CONFIG.v40KingHuntPenalty || -400000;
                debugLog(\"[V40.10_HUNT]\", `üö®üö®üö® KING HUNT IN PROGRESS! Move ${move} doesn't help!`);
            }
        }
        
    } catch (e) {
        debugLog(\"[V40.10_HUNT]\", `Error: ${e.message}`);
    }
    
    return score;
}

/**
 * v40.10 GODLIKE: CRITICAL EXCHANGE EVALUATION
 * Prevents exchanges that help opponent (like Nxd5 bringing queen to center)
 * This addresses the Nxd5 Qxd5 disaster from recent games
 */
function v40CriticalExchangeEval(fen, move, board, activeColor, moveNumber) {
    if (!CONFIG.v40CriticalExchangeEnabled) return 0;
    
    let score = 0;
    const isWhite = activeColor === 'w';
    const enemyColor = isWhite ? 'b' : 'w';
    
    try {
        const fromSquare = move.substring(0, 2);
        const toSquare = move.substring(2, 4);
        const movingPiece = board.get(fromSquare);
        const capturedPiece = board.get(toSquare);
        
        if (!movingPiece || !capturedPiece) return 0;  // Not a capture
        
        const movingType = movingPiece.toLowerCase();
        const capturedType = capturedPiece.toLowerCase();
        
        // Check if this capture can be recaptured
        const simBoard = new Map(board);
        simBoard.delete(fromSquare);
        simBoard.set(toSquare, movingPiece);
        
        const canEnemyRecapture = isSquareAttackedByColor(simBoard, toSquare, enemyColor);
        
        if (canEnemyRecapture) {
            // Find who can recapture
            for (const [sq, pc] of board) {
                if (!pc) continue;
                const pcColor = pc === pc.toUpperCase() ? 'w' : 'b';
                if (pcColor !== enemyColor) continue;
                
                // Check if this piece can capture on toSquare
                if (canPieceAttackSquare(board, sq, toSquare, pc)) {
                    const recapturingType = pc.toLowerCase();
                    
                    // CRITICAL: If queen would recapture
                    if (recapturingType === 'q') {
                        // Check if queen ends up in a good square
                        const centralSquares = ['d4', 'd5', 'e4', 'e5'];
                        const goodSquares = ['c4', 'c5', 'f4', 'f5', 'd3', 'd6', 'e3', 'e6'];
                        
                        if (centralSquares.includes(toSquare)) {
                            // This exchange puts enemy queen in CENTER - BAD!
                            score += CONFIG.v40ExchangeCentralizeEnemyPenalty || -150000;
                            debugLog(\"[V40.10_EXCH]\", `üö®üö® BAD EXCHANGE: ${move} brings enemy QUEEN to center ${toSquare}!`);
                        } else if (goodSquares.includes(toSquare)) {
                            score += (CONFIG.v40ExchangeCentralizeEnemyPenalty || -150000) / 2;
                            debugLog(\"[V40.10_EXCH]\", `‚ö†Ô∏è QUESTIONABLE: ${move} brings enemy queen to good square ${toSquare}`);
                        }
                    }
                    
                    // CRITICAL: If knight/bishop would recapture to central outpost
                    if ((recapturingType === 'n' || recapturingType === 'b') && 
                        ['d4', 'd5', 'e4', 'e5', 'c5', 'c4', 'f5', 'f4'].includes(toSquare)) {
                        score += (CONFIG.v40ExchangeCentralizeEnemyPenalty || -150000) / 3;
                        debugLog(\"[V40.10_EXCH]\", `‚ö†Ô∏è Exchange ${move} brings enemy ${recapturingType} to central outpost`);
                    }
                    
                    break;  // Only check first recapturer
                }
            }
        }
        
        // BONUS for exchanges that decentralize enemy pieces (forcing them to bad squares)
        if (capturedType !== 'p' && !canEnemyRecapture) {
            // Clean capture - good!
            score += CONFIG.v40GoodExchangeBonus || 80000;
            debugLog(\"[V40.10_EXCH]\", `‚úÖ Clean capture ${move} - enemy cannot recapture!`);
        }
        
    } catch (e) {
        debugLog(\"[V40.10_EXCH]\", `Error: ${e.message}`);
    }
    
    return score;
}

/**
 * v40.10 GODLIKE: MATING ATTACK AWARENESS
 * Detects when enemy is building a mating attack and prioritizes defense
 */
function v40MatingAttackAwarenessEval(fen, move, board, activeColor, moveNumber) {
    if (!CONFIG.v40MatingAttackAwarenessEnabled) return 0;
    if (moveNumber < 10) return 0;  // Mating attacks rarely happen early
    
    let score = 0;
    const isWhite = activeColor === 'w';
    const enemyColor = isWhite ? 'b' : 'w';
    
    try {
        const kingSquare = findKingSquare(board, activeColor);
        if (!kingSquare) return 0;
        
        // Check mating attack indicators
        let matingAttackScore = 0;
        
        // 1. Enemy queen and another piece pointing at king's zone
        const enemyQueen = findPiecesOfType(board, 'q', enemyColor);
        const kingZone = getKingZoneSquares(kingSquare);
        
        if (enemyQueen.length > 0) {
            for (const qSquare of enemyQueen) {
                let queenThreatsKingZone = 0;
                for (const zoneSquare of kingZone) {
                    if (canQueenAttackSquare(board, qSquare, zoneSquare)) {
                        queenThreatsKingZone++;
                    }
                }
                if (queenThreatsKingZone >= 2) {
                    matingAttackScore += 3;
                }
            }
        }
        
        // 2. Enemy rook(s) on open file towards king
        const enemyRooks = findPiecesOfType(board, 'r', enemyColor);
        const kingFile = kingSquare[0];
        
        for (const rSquare of enemyRooks) {
            if (rSquare[0] === kingFile || 
                String.fromCharCode(kingFile.charCodeAt(0) - 1) === rSquare[0] ||
                String.fromCharCode(kingFile.charCodeAt(0) + 1) === rSquare[0]) {
                matingAttackScore += 2;
            }
        }
        
        // 3. Enemy bishop on dangerous diagonal
        const enemyBishops = findPiecesOfType(board, 'b', enemyColor);
        for (const bSquare of enemyBishops) {
            for (const zoneSquare of kingZone) {
                if (canBishopReach(bSquare, zoneSquare)) {
                    matingAttackScore += 1;
                }
            }
        }
        
        // 4. Enemy knight near king
        const enemyKnights = findPiecesOfType(board, 'n', enemyColor);
        for (const nSquare of enemyKnights) {
            const fileDist = Math.abs(nSquare.charCodeAt(0) - kingSquare.charCodeAt(0));
            const rankDist = Math.abs(parseInt(nSquare[1]) - parseInt(kingSquare[1]));
            if (fileDist <= 2 && rankDist <= 2) {
                matingAttackScore += 2;
            }
        }
        
        // If mating attack is building
        if (matingAttackScore >= 5) {
            const fromSquare = move.substring(0, 2);
            const toSquare = move.substring(2, 4);
            const movingPiece = board.get(fromSquare);
            
            // Check if move helps defend
            let isDefensiveMove = false;
            
            // King move to safer square
            if (movingPiece && movingPiece.toLowerCase() === 'k') {
                const simBoard = new Map(board);
                simBoard.delete(fromSquare);
                simBoard.set(toSquare, movingPiece);
                
                const newAttackers = countAttackersOfSquare(simBoard, toSquare, enemyColor);
                const oldAttackers = countAttackersOfSquare(board, kingSquare, enemyColor);
                
                if (newAttackers < oldAttackers) {
                    isDefensiveMove = true;
                    score += CONFIG.v40MatingDefenseBonus || 400000;
                    debugLog(\"[V40.10_MATE]\", `‚úÖ King moves to safer square: ${move}`);
                }
            }
            
            // Piece blocks attack or creates escape
            if (movingPiece && kingZone.includes(toSquare)) {
                isDefensiveMove = true;
                score += (CONFIG.v40MatingDefenseBonus || 400000) / 2;
                debugLog(\"[V40.10_MATE]\", `‚úÖ Defensive move ${move} helps king zone`);
            }
            
            if (!isDefensiveMove) {
                score += CONFIG.v40MatingAttackPenalty || -600000;
                debugLog(\"[V40.10_MATE]\", `üö®üö®üö® MATING ATTACK BUILDING! Move ${move} doesn't defend! Score: ${matingAttackScore}`);
            }
        }
        
    } catch (e) {
        debugLog(\"[V40.10_MATE]\", `Error: ${e.message}`);
    }
    
    return score;
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// v40.10 GODLIKE: HELPER FUNCTIONS
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

/**
 * v40.10 Helper: Check if bishop can reach a target square (diagonal check)
 */
function canBishopReach(from, to) {
    const fromFile = from.charCodeAt(0);
    const fromRank = parseInt(from[1]);
    const toFile = to.charCodeAt(0);
    const toRank = parseInt(to[1]);
    
    const fileDiff = Math.abs(toFile - fromFile);
    const rankDiff = Math.abs(toRank - fromRank);
    
    // Bishop moves diagonally - file diff must equal rank diff
    return fileDiff === rankDiff && fileDiff > 0;
}

/**
 * v40.10 Helper: Check if knight can reach a target square
 */
function canKnightReach(from, to) {
    const fromFile = from.charCodeAt(0);
    const fromRank = parseInt(from[1]);
    const toFile = to.charCodeAt(0);
    const toRank = parseInt(to[1]);
    
    const fileDiff = Math.abs(toFile - fromFile);
    const rankDiff = Math.abs(toRank - fromRank);
    
    // Knight moves in L-shape: (1,2) or (2,1)
    return (fileDiff === 1 && rankDiff === 2) || (fileDiff === 2 && rankDiff === 1);
}

/**
 * v40.10 Helper: Find all pieces of a specific type and color
 */
function findPiecesOfType(board, pieceType, color) {
    const pieces = [];
    
    for (const [square, piece] of board) {
        if (!piece) continue;
        
        const pieceColor = piece === piece.toUpperCase() ? 'w' : 'b';
        if (pieceColor !== color) continue;
        
        if (piece.toLowerCase() === pieceType) {
            pieces.push(square);
        }
    }
    
    return pieces;
}

/**
 * v40.10 Helper: Count defenders of a square
 */
function countDefendersOfSquare(board, targetSquare, defenderColor) {
    let count = 0;
    
    for (const [square, piece] of board) {
        if (!piece || square === targetSquare) continue;
        
        const pieceColor = piece === piece.toUpperCase() ? 'w' : 'b';
        if (pieceColor !== defenderColor) continue;
        
        if (canPieceAttackSquare(board, square, targetSquare, piece)) {
            count++;
        }
    }
    
    return count;
}

/**
 * v40.10 Helper: Count attackers of a square
 */
function countAttackersOfSquare(board, targetSquare, attackerColor) {
    let count = 0;
    
    for (const [square, piece] of board) {
        if (!piece || square === targetSquare) continue;
        
        const pieceColor = piece === piece.toUpperCase() ? 'w' : 'b';
        if (pieceColor !== attackerColor) continue;
        
        if (canPieceAttackSquare(board, square, targetSquare, piece)) {
            count++;
        }
    }
    
    return count;
}

/**
 * v40.10 Helper: Check if a piece can attack a target square
 */
function canPieceAttackSquare(board, fromSquare, targetSquare, piece) {
    if (!piece) return false;
    
    const pieceType = piece.toLowerCase();
    const fromFile = fromSquare.charCodeAt(0);
    const fromRank = parseInt(fromSquare[1]);
    const toFile = targetSquare.charCodeAt(0);
    const toRank = parseInt(targetSquare[1]);
    
    const fileDiff = toFile - fromFile;
    const rankDiff = toRank - fromRank;
    const absFileDiff = Math.abs(fileDiff);
    const absRankDiff = Math.abs(rankDiff);
    
    switch (pieceType) {
        case 'p':
            // Pawns attack diagonally
            const direction = piece === piece.toUpperCase() ? 1 : -1;  // White goes up, black down
            return absFileDiff === 1 && rankDiff === direction;
            
        case 'n':
            return (absFileDiff === 1 && absRankDiff === 2) || (absFileDiff === 2 && absRankDiff === 1);
            
        case 'b':
            if (absFileDiff !== absRankDiff || absFileDiff === 0) return false;
            return !isPathBlocked(board, fromSquare, targetSquare, 'diagonal');
            
        case 'r':
            if (fileDiff !== 0 && rankDiff !== 0) return false;
            if (absFileDiff === 0 && absRankDiff === 0) return false;
            return !isPathBlocked(board, fromSquare, targetSquare, fileDiff === 0 ? 'vertical' : 'horizontal');
            
        case 'q':
            if (absFileDiff === absRankDiff && absFileDiff > 0) {
                return !isPathBlocked(board, fromSquare, targetSquare, 'diagonal');
            }
            if ((fileDiff === 0 || rankDiff === 0) && (absFileDiff > 0 || absRankDiff > 0)) {
                return !isPathBlocked(board, fromSquare, targetSquare, fileDiff === 0 ? 'vertical' : 'horizontal');
            }
            return false;
            
        case 'k':
            return absFileDiff <= 1 && absRankDiff <= 1 && (absFileDiff > 0 || absRankDiff > 0);
            
        default:
            return false;
    }
}

/**
 * v40.10 Helper: Check if path is blocked between two squares
 */
function isPathBlocked(board, from, to, direction) {
    const fromFile = from.charCodeAt(0);
    const fromRank = parseInt(from[1]);
    const toFile = to.charCodeAt(0);
    const toRank = parseInt(to[1]);
    
    const fileStep = toFile > fromFile ? 1 : (toFile < fromFile ? -1 : 0);
    const rankStep = toRank > fromRank ? 1 : (toRank < fromRank ? -1 : 0);
    
    let currentFile = fromFile + fileStep;
    let currentRank = fromRank + rankStep;
    
    while (currentFile !== toFile || currentRank !== toRank) {
        const square = String.fromCharCode(currentFile) + currentRank;
        if (board.has(square)) {
            return true;  // Path is blocked
        }
        currentFile += fileStep;
        currentRank += rankStep;
    }
    
    return false;
}

/**
 * v40.10 Helper: Get king zone squares (3x3 around king + extended)
 */
function getKingZoneSquares(kingSquare) {
    const zones = [];
    const kingFile = kingSquare.charCodeAt(0);
    const kingRank = parseInt(kingSquare[1]);
    
    for (let f = -2; f <= 2; f++) {
        for (let r = -2; r <= 2; r++) {
            const newFile = kingFile + f;
            const newRank = kingRank + r;
            
            if (newFile >= 97 && newFile <= 104 && newRank >= 1 && newRank <= 8) {
                zones.push(String.fromCharCode(newFile) + newRank);
            }
        }
    }
    
    return zones;
}

/**
 * v40.10 Helper: Check if queen can attack a square
 */
function canQueenAttackSquare(board, queenSquare, targetSquare) {
    const qFile = queenSquare.charCodeAt(0);
    const qRank = parseInt(queenSquare[1]);
    const tFile = targetSquare.charCodeAt(0);
    const tRank = parseInt(targetSquare[1]);
    
    const fileDiff = Math.abs(tFile - qFile);
    const rankDiff = Math.abs(tRank - qRank);
    
    // Queen can move like rook or bishop
    if (fileDiff === rankDiff && fileDiff > 0) {
        return !isPathBlocked(board, queenSquare, targetSquare, 'diagonal');
    }
    
    if ((qFile === tFile || qRank === tRank) && (fileDiff > 0 || rankDiff > 0)) {
        const direction = qFile === tFile ? 'vertical' : 'horizontal';
        return !isPathBlocked(board, queenSquare, targetSquare, direction);
    }
    
    return false;
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
Observation: Edit was successful.