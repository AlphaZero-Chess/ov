Let me find where to add the v40.33 functions. I'll add them after line 25031:
Action: file_editor view /app/Lichess Bot-AlphaZero-Pure.user.js
Observation: /app/Lichess Bot-AlphaZero-Pure.user.js:
25031| * v40.30: Find queen square for a color
25032| */
25033|function findQueenSquare(board, color) {
25034|    const isWhite = color === 'w';
25035|    for (const [square, piece] of board) {
25036|        if (!piece) continue;
25037|        if (piece.toLowerCase() === 'q') {
25038|            const pieceIsWhite = piece === piece.toUpperCase();
25039|            if (pieceIsWhite === isWhite) {
25040|                return square;
25041|            }
25042|        }
25043|    }
25044|    return null;
25045|}
25046|
25047|// ═══════════════════════════════════════════════════════════════════════════════
25048|function findAttackedPiecesV40_9(board, color) {
25049|    const attacked = [];
25050|    const isWhite = color === 'w';
25051|    const enemyColor = isWhite ? 'b' : 'w';
25052|    
25053|    for (const [square, piece] of board) {
25054|        if (!piece) continue;
25055|        const pieceIsWhite = piece === piece.toUpperCase();
25056|        if (pieceIsWhite !== isWhite) continue;
25057|        
25058|        const pieceType = piece.toLowerCase();
25059|        if (pieceType === 'k') continue;  // King attacks handled separately
25060|        
25061|        // Check if this square is attacked by enemy
25062|        if (isSquareAttackedByColor(board, square, enemyColor)) {
25063|            // Check if it's adequately defended
25064|            const isDefended = isSquareDefendedByColor(board, square, color);
25065|            
25066|            // If attacked by something of lower value, still need to consider
25067|            const attackers = findAttackersOfSquare(board, square, enemyColor);
25068|            const lowestAttackerValue = Math.min(...attackers.map(a => getPieceValueSimple(a.piece.toLowerCase())));
25069|            const ourPieceValue = getPieceValueSimple(pieceType);
25070|            
25071|            // Consider it under attack if:
25072|            // 1. Not defended at all, or
25073|            // 2. Attacker is of lower value than our piece
25074|            if (!isDefended || lowestAttackerValue < ourPieceValue) {
25075|                attacked.push({
25076|                    square,
25077|                    piece,
25078|                    value: ourPieceValue,
25079|                    lowestAttackerValue
25080|                });
25081|            }
25082|        }
25083|    }
25084|    
25085|    // Sort by piece value (highest first - queen, then rook, etc.)
25086|    attacked.sort((a, b) => b.value - a.value);
25087|    
25088|    return attacked;
25089|}
25090|
25091|/**
25092| * v40.9 Helper: Find all hanging pieces (attacked and not defended)
25093| */
25094|function findHangingPiecesV40_9(board, color) {
25095|    const hanging = [];
25096|    const isWhite = color === 'w';
25097|    const enemyColor = isWhite ? 'b' : 'w';
25098|    
25099|    for (const [square, piece] of board) {
25100|        if (!piece) continue;
