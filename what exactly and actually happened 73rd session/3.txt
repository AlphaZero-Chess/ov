Now let me check the `v40GenerateCaptureMove` function to ensure it's properly generating the knight capture:
Action: file_editor view /app/Lichess Bot-AlphaZero-Pure.user.js
Observation: /app/Lichess Bot-AlphaZero-Pure.user.js:
28857|function canPieceCapture(board, targetSquare, activeColor) {
28858|    const isWhite = activeColor === 'w';
28859|    
28860|    for (const [square, piece] of board) {
28861|        if (!piece) continue;
28862|        const pieceIsWhite = piece === piece.toUpperCase();
28863|        if (pieceIsWhite !== isWhite) continue;
28864|        
28865|        const pieceType = piece.toLowerCase();
28866|        
28867|        // Check if this piece can capture the target
28868|        if (canPieceMove(board, square, targetSquare, pieceType, pieceIsWhite)) {
28869|            return true;
28870|        }
28871|    }
28872|    
28873|    return false;
28874|}
28875|
28876|/**
28877| * v40.49 CRITICAL: Generate a capture move for a target square
28878| * This is used when Stockfish doesn't suggest the capture move but we MUST capture!
28879| * Returns the best capture move in UCI format (e.g., "f3d4")
28880| */
28881|function v40GenerateCaptureMove(board, targetSquare, activeColor) {
28882|    const isWhite = activeColor === 'w';
28883|    const captureMoves = [];
28884|    
28885|    // Priority order: Q > R > B > N > P (lower value pieces preferred for captures)
28886|    // Actually for equal exchanges, we want to capture with LOWEST value piece
28887|    const piecePriority = { 'p': 1, 'n': 2, 'b': 3, 'r': 4, 'q': 5, 'k': 6 };
28888|    
28889|    for (const [square, piece] of board) {
28890|        if (!piece) continue;
28891|        const pieceIsWhite = piece === piece.toUpperCase();
28892|        if (pieceIsWhite !== isWhite) continue;
28893|        
28894|        const pieceType = piece.toLowerCase();
28895|        
28896|        // Check if this piece can capture the target
28897|        if (canPieceMove(board, square, targetSquare, pieceType, pieceIsWhite)) {
28898|            captureMoves.push({
28899|                from: square,
28900|                to: targetSquare,
28901|                move: square + targetSquare,
28902|                pieceType: pieceType,
28903|                priority: piecePriority[pieceType] || 10
28904|            });
28905|        }
28906|    }
28907|    
28908|    if (captureMoves.length === 0) {
28909|        return null;
28910|    }
28911|    
28912|    // Sort by priority (prefer capturing with lower-value pieces)
28913|    captureMoves.sort((a, b) => a.priority - b.priority);
28914|    
28915|    // Return the best capture move (lowest value piece)
28916|    return captureMoves[0].move;
28917|}
28918|
28919|/**
28920| * v40.44 Helper: Check if piece can legally move from -> to
28921| */
28922|function canPieceMove(board, from, to, pieceType, isWhite) {
28923|    const fromFile = from.charCodeAt(0) - 'a'.charCodeAt(0);
28924|    const fromRank = parseInt(from.charAt(1)) - 1;
28925|    const toFile = to.charCodeAt(0) - 'a'.charCodeAt(0);
28926|    const toRank = parseInt(to.charAt(1)) - 1;
28927|    
28928|    const fileDiff = Math.abs(toFile - fromFile);
28929|    const rankDiff = Math.abs(toRank - fromRank);
28930|    
28931|    switch (pieceType) {
28932|        case 'n':  // Knight
28933|            return (fileDiff === 2 && rankDiff === 1) || (fileDiff === 1 && rankDiff === 2);
28934|            
28935|        case 'b':  // Bishop
28936|            if (fileDiff !== rankDiff) return false;
28937|            return !isPathBlockedDiagonal(board, from, to);
28938|            
28939|        case 'r':  // Rook
28940|            if (fileDiff !== 0 && rankDiff !== 0) return false;
28941|            return !isPathBlockedStraight(board, from, to);
28942|            
28943|        case 'q':  // Queen
28944|            if (fileDiff === rankDiff) return !isPathBlockedDiagonal(board, from, to);
28945|            if (fileDiff === 0 || rankDiff === 0) return !isPathBlockedStraight(board, from, to);
28946|            return false;
28947|            
28948|        case 'p':  // Pawn
28949|            const pawnDir = isWhite ? 1 : -1;
28950|            // Pawn capture: diagonal, one square
