
Action: file_editor view /app/Lichess Bot-AlphaZero-Pure.user.js
Observation: /app/Lichess Bot-AlphaZero-Pure.user.js:
27726|function v40MandatoryRecaptureEval(fen, move, board, activeColor, moveNumber) {
27727|    if (!CONFIG.v40MandatoryRecaptureEnabled) return 0;
27728|    
27729|    let score = 0;
27730|    const isWhite = activeColor === 'w';
27731|    const fromSquare = move.substring(0, 2);
27732|    const toSquare = move.substring(2, 4);
27733|    
27734|    // Find all our pieces currently attacked by enemy pawns
27735|    const piecesUnderPawnThreat = [];
27736|    
27737|    for (const [square, piece] of board) {
27738|        if (!piece) continue;
27739|        const pieceIsWhite = piece === piece.toUpperCase();
27740|        if (pieceIsWhite !== isWhite) continue;  // Only our pieces
27741|        
27742|        const pieceType = piece.toLowerCase();
27743|        if (pieceType === 'p' || pieceType === 'k') continue;  // Skip pawns and king
27744|        
27745|        const pieceValue = getPieceValueSimple(pieceType);
27746|        if (pieceValue < 300) continue;  // Only valuable pieces
27747|        
27748|        // Check if this piece is attacked by enemy pawn
27749|        const file = square.charCodeAt(0) - 'a'.charCodeAt(0);
27750|        const rank = parseInt(square.charAt(1));
27751|        
27752|        // CRITICAL FIX v40.43: Enemy pawn attack positions (pawns attack diagonally)
27753|        // Black pawns attack from higher ranks (rank+1 for white pieces)
27754|        const enemyPawnRank = isWhite ? rank + 1 : rank - 1;
27755|        
27756|        const attackingPawns = [];
27757|        // Left diagonal
27758|        if (file > 0 && enemyPawnRank >= 1 && enemyPawnRank <= 8) {
27759|            const leftSquare = String.fromCharCode('a'.charCodeAt(0) + file - 1) + enemyPawnRank;
27760|            const leftPiece = board.get(leftSquare);
27761|            if (leftPiece && leftPiece.toLowerCase() === 'p') {
27762|                const pawnIsWhite = leftPiece === leftPiece.toUpperCase();
27763|                if (pawnIsWhite !== isWhite) {
27764|                    attackingPawns.push(leftSquare);
27765|                }
27766|            }
27767|        }
27768|        // Right diagonal
27769|        if (file < 7 && enemyPawnRank >= 1 && enemyPawnRank <= 8) {
27770|            const rightSquare = String.fromCharCode('a'.charCodeAt(0) + file + 1) + enemyPawnRank;
27771|            const rightPiece = board.get(rightSquare);
27772|            if (rightPiece && rightPiece.toLowerCase() === 'p') {
27773|                const pawnIsWhite = rightPiece === rightPiece.toUpperCase();
27774|                if (pawnIsWhite !== isWhite) {
27775|                    attackingPawns.push(rightSquare);
27776|                }
27777|            }
27778|        }
27779|        
27780|        if (attackingPawns.length > 0) {
27781|            piecesUnderPawnThreat.push({
27782|                square,
27783|                piece,
27784|                pieceType,
27785|                pieceValue,
27786|                attackingPawns
27787|            });
27788|        }
27789|    }
27790|    
27791|    if (piecesUnderPawnThreat.length === 0) return 0;
27792|    
27793|    // Check if our move addresses ANY of the pawn threats
27794|    let threatAddressed = false;
27795|    
27796|    for (const threatened of piecesUnderPawnThreat) {
27797|        // Option 1: Are we moving the threatened piece?
27798|        if (fromSquare === threatened.square) {
27799|            // Good! We're moving the threatened piece
27800|            // But make sure we're not moving it to another attacked square!
27801|            const testBoard = simulateMove(board, move);
27802|            if (testBoard) {
27803|                const stillUnderPawnAttack = checkPawnAttackOnSquare(testBoard, toSquare, isWhite);
27804|                if (!stillUnderPawnAttack) {
27805|                    debugLog("[V40.40_RECAP]", `✅ Moving ${threatened.pieceType} from ${threatened.square} to safety`);
27806|                    threatAddressed = true;
27807|                }
27808|            }
27809|            continue;
27810|        }
27811|        
27812|        // Option 2: Are we capturing the attacking pawn?
27813|        for (const attackingPawn of threatened.attackingPawns) {
27814|            if (toSquare === attackingPawn) {
27815|                debugLog("[V40.40_RECAP]", `✅ Capturing attacking pawn on ${attackingPawn}`);
27816|                threatAddressed = true;
27817|                break;
27818|            }
27819|        }
27820|        
27821|        // Option 3: Are we blocking the attack? (rare with pawns but check)
27822|        // Pawns attack diagonally so blocking is usually not possible
27823|    }
27824|    
27825|    // If we have pieces under pawn threat and we're NOT addressing it - DEATH PENALTY!
27826|    if (!threatAddressed) {
27827|        const highestValue = Math.max(...piecesUnderPawnThreat.map(t => t.pieceValue));
27828|        debugLog("[V40.40_RECAP]", `☠️☠️☠️ MANDATORY RECAPTURE VIOLATION! Move ${move} IGNORES pawn threat!`);
27829|        debugLog("[V40.40_RECAP]", `Threatened pieces: ${piecesUnderPawnThreat.map(t => t.pieceType + '@' + t.square).join(', ')}`);
27830|        
27831|        // Scale penalty by piece value
27832|        const penalty = (CONFIG.v40MandatoryRecapturePenalty || -500000000000000) * (highestValue / 300);
27833|        score += penalty;
27834|    }
27835|    
27836|    return score;
27837|}
27838|
27839|/**
27840| * v40.40: PAWN NEAR PIECE DANGER
27841| * Detect when enemy pawn is ONE MOVE away from attacking our valuable piece
27842| * Example: After d5, if d5 pawn can advance to d4 attacking Nc3 - DANGER!
27843| */
27844|function v40PawnNearPieceDangerEval(fen, move, board, activeColor, moveNumber) {
27845|    if (!CONFIG.v40PawnNearPieceDangerEnabled) return 0;
27846|    
27847|    let score = 0;
27848|    const isWhite = activeColor === 'w';
27849|    
27850|    // Simulate our move
