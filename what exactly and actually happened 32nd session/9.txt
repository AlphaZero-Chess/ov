
Action: file_editor view /app/Lichess Bot-AlphaZero-Pure.user.js
Observation: /app/Lichess Bot-AlphaZero-Pure.user.js:
17180|            // Check if this quiet move allows opponent tactics
17181|            const opponentTactics = calculateOpponentForcingDepthV40_21(afterMove, enemyColor, 3);
17182|            if (opponentTactics.hasForcingSequence && opponentTactics.severity > 1.0) {
17183|                score += CONFIG.v40QuietMoveAllowsTacticPenalty;
17184|                debugLog("[V40.21_QUIET]", `☠️ ${move} (quiet) allows opponent tactic: ${opponentTactics.description}`);
17185|            }
17186|        }
17187|        
17188|    } catch (e) {
17189|        debugLog("[V40.21_QUIET]", `Error: ${e.message}`);
17190|    }
17191|    
17192|    return score;
17193|}
17194|
17195|// ═══════════════════════════════════════════════════════════════════════════════
17196|
17197|/**
17198| * v40.9 Helper: Find all attacked pieces for a color
17199| */
17200|function findAttackedPiecesV40_9(board, color) {
17201|    const attacked = [];
17202|    const isWhite = color === 'w';
17203|    const enemyColor = isWhite ? 'b' : 'w';
17204|    
17205|    for (const [square, piece] of board) {
17206|        if (!piece) continue;
17207|        const pieceIsWhite = piece === piece.toUpperCase();
17208|        if (pieceIsWhite !== isWhite) continue;
17209|        
17210|        const pieceType = piece.toLowerCase();
17211|        if (pieceType === 'k') continue;  // King attacks handled separately
17212|        
17213|        // Check if this square is attacked by enemy
17214|        if (isSquareAttackedByColor(board, square, enemyColor)) {
17215|            // Check if it's adequately defended
17216|            const isDefended = isSquareDefendedByColor(board, square, color);
17217|            
17218|            // If attacked by something of lower value, still need to consider
17219|            const attackers = findAttackersOfSquare(board, square, enemyColor);
17220|            const lowestAttackerValue = Math.min(...attackers.map(a => getPieceValueSimple(a.piece.toLowerCase())));
17221|            const ourPieceValue = getPieceValueSimple(pieceType);
17222|            
17223|            // Consider it under attack if:
17224|            // 1. Not defended at all, or
17225|            // 2. Attacker is of lower value than our piece
17226|            if (!isDefended || lowestAttackerValue < ourPieceValue) {
17227|                attacked.push({
17228|                    square,
17229|                    piece,
17230|                    value: ourPieceValue,
17231|                    lowestAttackerValue
17232|                });
17233|            }
17234|        }
17235|    }
17236|    
17237|    // Sort by piece value (highest first - queen, then rook, etc.)
17238|    attacked.sort((a, b) => b.value - a.value);
17239|    
17240|    return attacked;
