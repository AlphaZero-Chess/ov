The functions are there. Let me check line 18700 area for the actual problem:
Action: file_editor view /app/Lichess Bot-AlphaZero-Pure.user.js
Observation: /app/Lichess Bot-AlphaZero-Pure.user.js:
18700|    
18701|    // Pawn shield intact?
18702|    if (isPawnShieldIntactV40_23(board, kingSquare, color)) {
18703|        strength += 0.4;
18704|    }
18705|    
18706|    // Light squares not weak?
18707|    if (!isLightSquareWeakV40_23(board, kingSquare, color)) {
18708|        strength += 0.2;
18709|    }
18710|    
18711|    // No enemy pieces nearby?
18712|    const enemyColor = color === 'w' ? 'b' : 'w';
18713|    if (!isFortressBreachedV40_23(board, kingSquare, enemyColor)) {
18714|        strength += 0.4;
18715|    }
18716|    
18717|    return Math.min(strength, 1.0);
18718|}
18719|
18720|// ═══════════════════════════════════════════════════════════════════════════════
18721|    const attacked = [];
18722|    const isWhite = color === 'w';
18723|    const enemyColor = isWhite ? 'b' : 'w';
18724|    
18725|    for (const [square, piece] of board) {
18726|        if (!piece) continue;
18727|        const pieceIsWhite = piece === piece.toUpperCase();
18728|        if (pieceIsWhite !== isWhite) continue;
18729|        
18730|        const pieceType = piece.toLowerCase();
18731|        if (pieceType === 'k') continue;  // King attacks handled separately
18732|        
18733|        // Check if this square is attacked by enemy
18734|        if (isSquareAttackedByColor(board, square, enemyColor)) {
18735|            // Check if it's adequately defended
18736|            const isDefended = isSquareDefendedByColor(board, square, color);
18737|            
18738|            // If attacked by something of lower value, still need to consider
18739|            const attackers = findAttackersOfSquare(board, square, enemyColor);
18740|            const lowestAttackerValue = Math.min(...attackers.map(a => getPieceValueSimple(a.piece.toLowerCase())));
18741|            const ourPieceValue = getPieceValueSimple(pieceType);
18742|            
18743|            // Consider it under attack if:
18744|            // 1. Not defended at all, or
18745|            // 2. Attacker is of lower value than our piece
18746|            if (!isDefended || lowestAttackerValue < ourPieceValue) {
18747|                attacked.push({
18748|                    square,
18749|                    piece,
18750|                    value: ourPieceValue,
18751|                    lowestAttackerValue
18752|                });
18753|            }
18754|        }
18755|    }
18756|    
18757|    // Sort by piece value (highest first - queen, then rook, etc.)
18758|    attacked.sort((a, b) => b.value - a.value);
18759|    
18760|    return attacked;
18761|}
18762|
18763|/**
18764| * v40.9 Helper: Find all hanging pieces (attacked and not defended)
18765| */
18766|function findHangingPiecesV40_9(board, color) {
18767|    const hanging = [];
18768|    const isWhite = color === 'w';
18769|    const enemyColor = isWhite ? 'b' : 'w';
18770|    
