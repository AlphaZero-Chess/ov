I found the issue! There's orphan code starting at line 30956 - it looks like part of a function body without a function declaration. This is the leftover from when the v40.52 functions were inserted. Let me fix this by removing the orphan code:
Action: file_editor str_replace /app/Lichess Bot-AlphaZero-Pure.user.js --old-str "    return score;
}

    const attacked = [];
    const isWhite = color === 'w';
    const enemyColor = isWhite ? 'b' : 'w';
    
    for (const [square, piece] of board) {
        if (!piece) continue;
        const pieceIsWhite = piece === piece.toUpperCase();
        if (pieceIsWhite !== isWhite) continue;
        
        const pieceType = piece.toLowerCase();
        if (pieceType === 'k') continue;  // King attacks handled separately
        
        // Check if this square is attacked by enemy
        if (isSquareAttackedByColor(board, square, enemyColor)) {
            // Check if it's adequately defended
            const isDefended = isSquareDefendedByColor(board, square, color);
            
            // If attacked by something of lower value, still need to consider
            const attackers = findAttackersOfSquare(board, square, enemyColor);
            const lowestAttackerValue = Math.min(...attackers.map(a => getPieceValueSimple(a.piece.toLowerCase())));
            const ourPieceValue = getPieceValueSimple(pieceType);
            
            // Consider it under attack if:
            // 1. Not defended at all, or
            // 2. Attacker is of lower value than our piece
            if (!isDefended || lowestAttackerValue < ourPieceValue) {
                attacked.push({
                    square,
                    piece,
                    value: ourPieceValue,
                    lowestAttackerValue
                });
            }
        }
    }
    
    // Sort by piece value (highest first - queen, then rook, etc.)
    attacked.sort((a, b) => b.value - a.value);
    
    return attacked;
}

/**
 * v40.9 Helper: Find all hanging pieces (attacked and not defended)
 */
function findHangingPiecesV40_9(board, color) {" --new-str "    return score;
}

// ═══════════════════════════════════════════════════════════════════════════════
// v40.9 HELPER FUNCTIONS
// ═══════════════════════════════════════════════════════════════════════════════

/**
 * v40.9 Helper: Find all attacked pieces
 */
function findAttackedPiecesV40_9(board, color) {
    const attacked = [];
    const isWhite = color === 'w';
    const enemyColor = isWhite ? 'b' : 'w';
    
    for (const [square, piece] of board) {
        if (!piece) continue;
        const pieceIsWhite = piece === piece.toUpperCase();
        if (pieceIsWhite !== isWhite) continue;
        
        const pieceType = piece.toLowerCase();
        if (pieceType === 'k') continue;  // King attacks handled separately
        
        // Check if this square is attacked by enemy
        if (isSquareAttackedByColor(board, square, enemyColor)) {
            // Check if it's adequately defended
            const isDefended = isSquareDefendedByColor(board, square, color);
            
            // If attacked by something of lower value, still need to consider
            const attackers = findAttackersOfSquare(board, square, enemyColor);
            if (attackers.length === 0) continue;
            
            const lowestAttackerValue = Math.min(...attackers.map(a => getPieceValueSimple(a.piece.toLowerCase())));
            const ourPieceValue = getPieceValueSimple(pieceType);
            
            // Consider it under attack if:
            // 1. Not defended at all, or
            // 2. Attacker is of lower value than our piece
            if (!isDefended || lowestAttackerValue < ourPieceValue) {
                attacked.push({
                    square,
                    piece,
                    value: ourPieceValue,
                    lowestAttackerValue
                });
            }
        }
    }
    
    // Sort by piece value (highest first - queen, then rook, etc.)
    attacked.sort((a, b) => b.value - a.value);
    
    return attacked;
}

/**
 * v40.9 Helper: Find all hanging pieces (attacked and not defended)
 */
function findHangingPiecesV40_9(board, color) {"
Observation: Edit was successful.