Good, I found the location. Now I need to add the v40.26 functions right after line 20371 (after v40GetPieceAttacks function). Let me add them:
Action: file_editor str_replace /app/Lichess Bot-AlphaZero-Pure.user.js --old-str "    return attacks;
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function findAttackedPiecesV40_9(board, color) {" --new-str "    return attacks;
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// v40.26 ABSOLUTE KINGSIDE FORTRESS SUPREME FUNCTIONS
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

/**
 * v40.26: ABSOLUTE KINGSIDE PAWN PROHIBITION
 * From game analysis: Bot played g3 with Qh5 threatening! NEVER again!
 * This function applies MASSIVE penalties for weakening kingside pawns under attack
 */
function v40AbsoluteKingsidePawnProhibitionEval(fen, move, board, activeColor, moveNumber) {
    if (!CONFIG.v40AbsoluteKingsideProhibitionEnabled) return 0;
    
    let score = 0;
    const isWhite = activeColor === 'w';
    const enemyColor = isWhite ? 'b' : 'w';
    
    try {
        const fromSquare = move.substring(0, 2);
        const toSquare = move.substring(2, 4);
        const movingPiece = board.get(fromSquare);
        
        if (!movingPiece) return 0;
        
        // Only check pawn moves
        if (movingPiece.toLowerCase() !== 'p') return 0;
        
        const fromFile = fromSquare[0];
        const toFile = toSquare[0];
        const fromRank = parseInt(fromSquare[1]);
        const toRank = parseInt(toSquare[1]);
        
        // For WHITE: f3, g3, h3 are dangerous (ranks 2->3)
        // For BLACK: f6, g6, h6 are dangerous (ranks 7->6)
        const startRank = isWhite ? 2 : 7;
        const dangerRank = isWhite ? 3 : 6;
        
        // Check if this is a kingside pawn weakening move
        const isKingsidePawn = (toFile === 'f' || toFile === 'g' || toFile === 'h');
        const isWeakeningMove = isKingsidePawn && toRank === dangerRank;
        
        if (!isWeakeningMove) return 0;
        
        // CHECK: Is enemy queen threatening kingside?
        const enemyQueenPos = v40FindQueenPosition(board, enemyColor);
        const enemyQueenOnKingside = enemyQueenPos && v40IsQueenThreateningKingside(enemyQueenPos, isWhite);
        
        // CHECK: Does enemy have dark-squared bishop?
        const enemyHasDarkBishop = v40HasDarkSquaredBishop(board, enemyColor);
        
        // CHECK: Does enemy have active pieces on kingside?
        const enemyKingsideActivity = v40CountEnemyKingsideActivity(board, enemyColor, isWhite);
        
        // CHECK: Is our king castled kingside?
        const ourKing = findKing(board, activeColor);
        const isKingsideCastled = ourKing && (isWhite ? 
            (ourKing[0] >= 'f' && ourKing[0] <= 'h') : 
            (ourKing[0] >= 'f' && ourKing[0] <= 'h'));
        
        if (toFile === 'g') {
            // G3/G6 MOVE ‚Äî Potentially catastrophic!
            if (enemyQueenOnKingside) {
                score += CONFIG.v40G3UnderQueenThreatPenalty || -500000000000;
                debugLog(\"[V40.26_FORTRESS]\", `‚ò†Ô∏è‚ò†Ô∏è‚ò†Ô∏è‚ò†Ô∏è‚ò†Ô∏è ${move} is g${dangerRank} WITH ENEMY QUEEN ON KINGSIDE! SUICIDE!`);
            }
            
            if (enemyHasDarkBishop) {
                score += CONFIG.v40G3WithEnemyBishopPenalty || -450000000000;
                debugLog(\"[V40.26_FORTRESS]\", `‚ò†Ô∏è‚ò†Ô∏è‚ò†Ô∏è‚ò†Ô∏è ${move} is g${dangerRank} WITH ENEMY DARK BISHOP! Bxg${dangerRank} SACRIFICE ENABLED!`);
            }
            
            if (enemyKingsideActivity >= 2) {
                score += CONFIG.v40KingsidePawnWeakenPenalty || -300000000000;
                debugLog(\"[V40.26_FORTRESS]\", `‚ò†Ô∏è‚ò†Ô∏è‚ò†Ô∏è ${move} weakens kingside with ${enemyKingsideActivity} enemy pieces active!`);
            }
        }
        
        if (toFile === 'f') {
            // F3/F6 MOVE ‚Äî Even more dangerous!
            if (enemyQueenOnKingside) {
                score += CONFIG.v40F3UnderQueenThreatPenalty || -600000000000;
                debugLog(\"[V40.26_FORTRESS]\", `‚ò†Ô∏è‚ò†Ô∏è‚ò†Ô∏è‚ò†Ô∏è‚ò†Ô∏è‚ò†Ô∏è ${move} is f${dangerRank} WITH ENEMY QUEEN ACTIVE! CATASTROPHIC!`);
            }
            
            // Check for knight that can exploit f3/f6
            if (v40HasKnightThatCanExploitWeakness(board, enemyColor, toSquare, isWhite)) {
                score += CONFIG.v40F3WithEnemyKnightPenalty || -400000000000;
                debugLog(\"[V40.26_FORTRESS]\", `‚ò†Ô∏è‚ò†Ô∏è‚ò†Ô∏è‚ò†Ô∏è ${move} is f${dangerRank} - KNIGHT CAN EXPLOIT!`);
            }
            
            if (enemyKingsideActivity >= 1) {
                score += CONFIG.v40KingsidePawnWeakenPenalty || -300000000000;
            }
        }
        
        if (toFile === 'h') {
            // H3/H6 MOVE ‚Äî Creates target
            if (enemyQueenOnKingside) {
                score += CONFIG.v40H3UnderQueenThreatPenalty || -400000000000;
                debugLog(\"[V40.26_FORTRESS]\", `‚ò†Ô∏è‚ò†Ô∏è‚ò†Ô∏è‚ò†Ô∏è ${move} is h${dangerRank} WITH ENEMY QUEEN! TARGET CREATED!`);
            }
        }
        
        // ABSOLUTE PROHIBITION: If under any kingside pressure, penalize ALL weakening moves
        if (isKingsideCastled && (enemyQueenOnKingside || enemyKingsideActivity >= 2)) {
            score += CONFIG.v40KingsidePawnWeakenPenalty || -300000000000;
            debugLog(\"[V40.26_FORTRESS]\", `üö®üö®üö® ${move} weakens kingside while castled and under pressure!`);
        }
        
    } catch (e) {
        debugLog(\"[V40.26_FORTRESS]\", `Error: ${e.message}`);
    }
    
    return score;
}

/**
 * v40.26: BISHOP SACRIFICE DETECTION
 * Detect Bxg3, Bxh2, Bxf3 sacrifice patterns BEFORE they happen
 */
function v40BishopSacrificeDetectionEval(fen, move, board, activeColor, moveNumber) {
    if (!CONFIG.v40BishopSacrificeDetectionEnabled) return 0;
    
    let score = 0;
    const isWhite = activeColor === 'w';
    const enemyColor = isWhite ? 'b' : 'w';
    const enemyBishopChar = isWhite ? 'b' : 'B';
    
    try {
        const fromSquare = move.substring(0, 2);
        const toSquare = move.substring(2, 4);
        const movingPiece = board.get(fromSquare);
        
        if (!movingPiece) return 0;
        
        // Simulate our move
        const afterBoard = new Map(board);
        afterBoard.delete(fromSquare);
        afterBoard.set(toSquare, movingPiece);
        
        // Find enemy bishops
        for (const [sq, piece] of afterBoard) {
            if (piece !== enemyBishopChar) continue;
            
            const bishopFile = sq.charCodeAt(0) - 'a'.charCodeAt(0);
            const bishopRank = parseInt(sq[1]);
            
            // Check diagonal targets for sacrifice
            const diagonalDirections = [[1,1], [1,-1], [-1,1], [-1,-1]];
            
            for (const [df, dr] of diagonalDirections) {
                for (let dist = 1; dist <= 7; dist++) {
                    const targetFile = bishopFile + df * dist;
                    const targetRank = bishopRank + dr * dist;
                    
                    if (targetFile < 0 || targetFile > 7 || targetRank < 1 || targetRank > 8) break;
                    
                    const targetSquare = String.fromCharCode('a'.charCodeAt(0) + targetFile) + targetRank;
                    const targetPiece = afterBoard.get(targetSquare);
                    
                    if (targetPiece) {
                        const targetIsOurs = (targetPiece === targetPiece.toUpperCase()) === isWhite;
                        
                        if (targetIsOurs) {
                            // Enemy bishop can capture our piece - is it a sacrifice that works?
                            if (targetPiece.toLowerCase() === 'p') {
                                // Can capture our pawn - check if it's a dangerous sacrifice
                                const targetFileChar = targetSquare[0];
                                const targetRankNum = parseInt(targetSquare[1]);
                                
                                // Check for dangerous g3/h3/f3 sacrifices
                                if ((targetFileChar === 'g' || targetFileChar === 'h' || targetFileChar === 'f') &&
                                    ((isWhite && targetRankNum === 3) || (!isWhite && targetRankNum === 6))) {
                                    
                                    // Check if sacrifice leads to attack
                                    const sacrificeResult = v40CalculateSacrificeConsequence(afterBoard, sq, targetSquare, enemyColor, activeColor);
                                    
                                    if (sacrificeResult.leadToMate) {
                                        score += CONFIG.v40SacrificeLeadsToMatePenalty || -1000000000000;
                                        debugLog(\"[V40.26_SACRIFICE]\", `‚ò†Ô∏è‚ò†Ô∏è‚ò†Ô∏è‚ò†Ô∏è‚ò†Ô∏è MOVE ${move} ALLOWS Bx${targetSquare} SACRIFICE LEADING TO MATE!`);
                                    } else if (sacrificeResult.gainsMaterial) {
                                        score += CONFIG.v40ForcingLineMaterialWinPenalty || -500000000000;
                                        debugLog(\"[V40.26_SACRIFICE]\", `‚ò†Ô∏è‚ò†Ô∏è‚ò†Ô∏è‚ò†Ô∏è MOVE ${move} ALLOWS Bx${targetSquare} SACRIFICE WINNING MATERIAL!`);
                                    } else if (targetFileChar === 'g') {
                                        score += CONFIG.v40BxG3SacrificeThreatPenalty || -800000000000;
                                        debugLog(\"[V40.26_SACRIFICE]\", `‚ò†Ô∏è‚ò†Ô∏è‚ò†Ô∏è‚ò†Ô∏è ${move} ALLOWS Bxg${targetRankNum} SACRIFICE!`);
                                    }
                                }
                            }
                        }
                        break; // Blocked by piece
                    }
                }
            }
        }
        
    } catch (e) {
        debugLog(\"[V40.26_SACRIFICE]\", `Error: ${e.message}`);
    }
    
    return score;
}

/**
 * v40.26: FORCED DEFENSE MODE
 * When kingside is under attack, only defensive moves should be allowed!
 */
function v40ForcedDefenseModeEval(fen, move, board, activeColor, moveNumber) {
    if (!CONFIG.v40ForcedDefenseModeEnabled) return 0;
    
    let score = 0;
    const isWhite = activeColor === 'w';
    const enemyColor = isWhite ? 'b' : 'w';
    
    try {
        // First check if we're under kingside attack
        const kingsideUnderAttack = v40IsKingsideUnderAttack(board, activeColor, enemyColor);
        
        if (!kingsideUnderAttack) return 0; // Not under attack, no forced defense
        
        const fromSquare = move.substring(0, 2);
        const toSquare = move.substring(2, 4);
        const movingPiece = board.get(fromSquare);
        
        if (!movingPiece) return 0;
        
        // Check if this move is defensive (addresses the attack)
        const isDefensiveMove = v40IsMoveDefensive(move, board, activeColor, enemyColor);
        const isKingsideReinforcement = v40IsKingsideReinforcement(move, board, activeColor);
        const isCounterattack = v40IsEffectiveCounterattack(move, board, activeColor, enemyColor);
        const isFortressMove = v40CreatesFortress(move, board, activeColor);
        
        if (isDefensiveMove) {
            score += CONFIG.v40DefensiveMoveBonus || 50000000000;
            debugLog(\"[V40.26_DEFENSE]\", `‚úÖ ${move} is DEFENSIVE - GOOD when under attack!`);
        } else if (isKingsideReinforcement) {
            score += CONFIG.v40KingsideReinforcementBonus || 60000000000;
            debugLog(\"[V40.26_DEFENSE]\", `‚úÖ ${move} reinforces kingside defense!`);
        } else if (isCounterattack) {
            score += CONFIG.v40CounterattackBonus || 40000000000;
            debugLog(\"[V40.26_DEFENSE]\", `‚úÖ ${move} is effective counterattack!`);
        } else if (isFortressMove) {
            score += CONFIG.v40FortressMoveBonus || 70000000000;
            debugLog(\"[V40.26_DEFENSE]\", `‚úÖ ${move} creates fortress position!`);
        } else {
            // NON-DEFENSIVE MOVE UNDER ATTACK = PENALTY!
            score += CONFIG.v40NonDefensiveMoveUnderAttackPenalty || -400000000000;
            debugLog(\"[V40.26_DEFENSE]\", `üö®üö®üö® ${move} is NON-DEFENSIVE while kingside under attack! PENALIZED!`);
        }
        
    } catch (e) {
        debugLog(\"[V40.26_DEFENSE]\", `Error: ${e.message}`);
    }
    
    return score;
}

/**
 * v40.26: QUEEN KINGSIDE THREAT DETECTION
 * Detect when enemy queen is on dangerous squares (h5, g5, h4, g4)
 */
function v40QueenKingsideThreatEval(fen, move, board, activeColor, moveNumber) {
    if (!CONFIG.v40QueenKingsideThreatEnabled) return 0;
    
    let score = 0;
    const isWhite = activeColor === 'w';
    const enemyColor = isWhite ? 'b' : 'w';
    
    try {
        const fromSquare = move.substring(0, 2);
        const toSquare = move.substring(2, 4);
        const movingPiece = board.get(fromSquare);
        
        if (!movingPiece) return 0;
        
        // Simulate our move
        const afterBoard = new Map(board);
        afterBoard.delete(fromSquare);
        afterBoard.set(toSquare, movingPiece);
        
        // Find enemy queen position
        const enemyQueenChar = isWhite ? 'q' : 'Q';
        let enemyQueenSquare = null;
        
        for (const [sq, piece] of afterBoard) {
            if (piece === enemyQueenChar) {
                enemyQueenSquare = sq;
                break;
            }
        }
        
        if (!enemyQueenSquare) return 0;
        
        // Check dangerous squares (from perspective of attacking white's king)
        // For white: enemy queen on h5, g5, h4, g4 is dangerous
        // For black: enemy queen on h4, g4, h5, g5 is dangerous
        const queenFile = enemyQueenSquare[0];
        const queenRank = parseInt(enemyQueenSquare[1]);
        
        const dangerousSquares = isWhite ? 
            [['h',5], ['g',5], ['h',4], ['g',4], ['h',3], ['g',3]] :
            [['h',4], ['g',4], ['h',5], ['g',5], ['h',6], ['g',6]];
        
        for (const [file, rank] of dangerousSquares) {
            if (queenFile === file && queenRank === rank) {
                if (queenRank === (isWhite ? 5 : 4)) {
                    if (queenFile === 'h') {
                        score += CONFIG.v40EnemyQueenOnH5Penalty || -200000000000;
                        debugLog(\"[V40.26_QUEEN]\", `üö®üö® Enemy queen on h${queenRank}! KINGSIDE IN DANGER!`);
                    } else if (queenFile === 'g') {
                        score += CONFIG.v40EnemyQueenOnG5Penalty || -180000000000;
                        debugLog(\"[V40.26_QUEEN]\", `üö®üö® Enemy queen on g${queenRank}! THREATENING!`);
                    }
                } else if (queenRank === (isWhite ? 4 : 5)) {
                    if (queenFile === 'h') {
                        score += CONFIG.v40EnemyQueenOnH4Penalty || -250000000000;
                        debugLog(\"[V40.26_QUEEN]\", `üö®üö®üö® Enemy queen on h${queenRank}! CRITICAL THREAT!`);
                    } else if (queenFile === 'g') {
                        score += CONFIG.v40EnemyQueenOnG4Penalty || -220000000000;
                        debugLog(\"[V40.26_QUEEN]\", `üö®üö®üö® Enemy queen on g${queenRank}! SERIOUS THREAT!`);
                    }
                }
            }
        }
        
        // Check for Queen + Bishop coordination
        const enemyBishopChar = isWhite ? 'b' : 'B';
        let hasCoordinatedBishop = false;
        for (const [sq, piece] of afterBoard) {
            if (piece === enemyBishopChar) {
                // Check if bishop can support queen attack
                const bishopFile = sq.charCodeAt(0) - 'a'.charCodeAt(0);
                const bishopRank = parseInt(sq[1]);
                const queenFileNum = queenFile.charCodeAt(0) - 'a'.charCodeAt(0);
                
                // On same diagonal?
                if (Math.abs(bishopFile - queenFileNum) === Math.abs(bishopRank - queenRank)) {
                    hasCoordinatedBishop = true;
                }
            }
        }
        
        if (hasCoordinatedBishop && (queenFile === 'g' || queenFile === 'h')) {
            score += CONFIG.v40QueenAndBishopOnKingsidePenalty || -350000000000;
            debugLog(\"[V40.26_QUEEN]\", `üö®üö®üö®üö® QUEEN + BISHOP coordinated kingside attack!`);
        }
        
    } catch (e) {
        debugLog(\"[V40.26_QUEEN]\", `Error: ${e.message}`);
    }
    
    return score;
}

/**
 * v40.26: DEEP SACRIFICE CALCULATION
 * Calculate forcing lines after a potential sacrifice
 */
function v40DeepSacrificeCalcEval(fen, move, board, activeColor, moveNumber) {
    if (!CONFIG.v40DeepSacrificeCalcEnabled) return 0;
    
    let score = 0;
    const isWhite = activeColor === 'w';
    const enemyColor = isWhite ? 'b' : 'w';
    
    try {
        const fromSquare = move.substring(0, 2);
        const toSquare = move.substring(2, 4);
        const movingPiece = board.get(fromSquare);
        
        if (!movingPiece) return 0;
        
        // Simulate our move
        const afterBoard = new Map(board);
        afterBoard.delete(fromSquare);
        afterBoard.set(toSquare, movingPiece);
        
        // Check if any enemy piece can sacrifice on our weak squares
        const sacrificeTargets = v40FindSacrificeTargets(afterBoard, isWhite);
        
        for (const target of sacrificeTargets) {
            // Calculate consequence of sacrifice
            const result = v40CalculateForcingLineAfterSacrifice(
                afterBoard, 
                target.attackerSquare, 
                target.targetSquare, 
                enemyColor, 
                activeColor,
                CONFIG.v40SacrificeCalcDepth || 8
            );
            
            if (result.foundMate) {
                score += CONFIG.v40ForcingLineMateFoundPenalty || -1500000000000;
                debugLog(\"[V40.26_DEEP]\", `‚ò†Ô∏è‚ò†Ô∏è‚ò†Ô∏è‚ò†Ô∏è‚ò†Ô∏è ${move} allows sacrifice on ${target.targetSquare} LEADING TO MATE in ${result.mateIn} moves!`);
            } else if (result.winsQueen) {
                score += CONFIG.v40ForcingLineQueenWinPenalty || -800000000000;
                debugLog(\"[V40.26_DEEP]\", `‚ò†Ô∏è‚ò†Ô∏è‚ò†Ô∏è‚ò†Ô∏è ${move} allows sacrifice winning QUEEN!`);
            } else if (result.winsMaterial > 3) {
                score += CONFIG.v40ForcingLineMaterialWinPenalty || -500000000000;
                debugLog(\"[V40.26_DEEP]\", `‚ò†Ô∏è‚ò†Ô∏è‚ò†Ô∏è ${move} allows sacrifice winning ${result.winsMaterial} material!`);
            }
        }
        
    } catch (e) {
        debugLog(\"[V40.26_DEEP]\", `Error: ${e.message}`);
    }
    
    return score;
}

/**
 * v40.26: KINGSIDE COLLAPSE DETECTION
 * Detect when kingside pawn structure is being destroyed
 */
function v40KingsideCollapseDetectionEval(fen, move, board, activeColor, moveNumber) {
    if (!CONFIG.v40KingsideCollapseDetectionEnabled) return 0;
    
    let score = 0;
    const isWhite = activeColor === 'w';
    
    try {
        const fromSquare = move.substring(0, 2);
        const toSquare = move.substring(2, 4);
        const movingPiece = board.get(fromSquare);
        
        if (!movingPiece) return 0;
        
        // Simulate our move
        const afterBoard = new Map(board);
        afterBoard.delete(fromSquare);
        afterBoard.set(toSquare, movingPiece);
        
        // Count kingside pawns before and after
        const kingsidePawnsBefore = v40CountKingsidePawns(board, activeColor);
        const kingsidePawnsAfter = v40CountKingsidePawns(afterBoard, activeColor);
        
        // Check if we've lost kingside pawns
        if (kingsidePawnsAfter < kingsidePawnsBefore) {
            score += CONFIG.v40KingsidePawnsDestroyedPenalty || -600000000000;
            debugLog(\"[V40.26_COLLAPSE]\", `‚ò†Ô∏è‚ò†Ô∏è‚ò†Ô∏è ${move} destroys kingside pawn shelter!`);
        }
        
        // Check for file opening toward king
        const ourKing = findKing(afterBoard, activeColor);
        if (ourKing) {
            const kingFile = ourKing[0];
            
            // Check if g-file opens toward king
            if (v40IsFileOpenToward(afterBoard, 'g', ourKing, activeColor) && 
                !v40IsFileOpenToward(board, 'g', ourKing, activeColor)) {
                score += CONFIG.v40GFileOpenToKingPenalty || -450000000000;
                debugLog(\"[V40.26_COLLAPSE]\", `‚ò†Ô∏è‚ò†Ô∏è ${move} opens g-file toward our king!`);
            }
            
            // Check if h-file opens toward king
            if (v40IsFileOpenToward(afterBoard, 'h', ourKing, activeColor) && 
                !v40IsFileOpenToward(board, 'h', ourKing, activeColor)) {
                score += CONFIG.v40HFileOpenToKingPenalty || -500000000000;
                debugLog(\"[V40.26_COLLAPSE]\", `‚ò†Ô∏è‚ò†Ô∏è ${move} opens h-file toward our king!`);
            }
            
            // Check if f-file opens toward king
            if (v40IsFileOpenToward(afterBoard, 'f', ourKing, activeColor) && 
                !v40IsFileOpenToward(board, 'f', ourKing, activeColor)) {
                score += CONFIG.v40FFileOpenToKingPenalty || -400000000000;
                debugLog(\"[V40.26_COLLAPSE]\", `‚ò†Ô∏è‚ò†Ô∏è ${move} opens f-file toward our king!`);
            }
        }
        
        // Check if all kingside pawns are gone
        if (kingsidePawnsAfter === 0) {
            score += CONFIG.v40NoKingsidePawnShieldPenalty || -550000000000;
            debugLog(\"[V40.26_COLLAPSE]\", `‚ò†Ô∏è‚ò†Ô∏è‚ò†Ô∏è‚ò†Ô∏è ${move} leaves NO kingside pawn shelter!`);
        }
        
        // Check if move creates permanent kingside weakness
        if (v40CreatesKingsideWeakness(move, board, afterBoard, activeColor)) {
            score += CONFIG.v40KingsideWeaknessCreatedPenalty || -350000000000;
            debugLog(\"[V40.26_COLLAPSE]\", `‚ö†Ô∏è‚ö†Ô∏è ${move} creates permanent kingside weakness!`);
        }
        
    } catch (e) {
        debugLog(\"[V40.26_COLLAPSE]\", `Error: ${e.message}`);
    }
    
    return score;
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// v40.26 HELPER FUNCTIONS
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

/** v40.26: Find queen position */
function v40FindQueenPosition(board, color) {
    const queenChar = color === 'w' ? 'Q' : 'q';
    for (const [sq, piece] of board) {
        if (piece === queenChar) return sq;
    }
    return null;
}

/** v40.26: Check if queen is threatening kingside */
function v40IsQueenThreateningKingside(queenSquare, isWhiteKing) {
    if (!queenSquare) return false;
    const file = queenSquare[0];
    const rank = parseInt(queenSquare[1]);
    
    // Queen is threatening if on g or h file, or in advanced position
    if (file === 'g' || file === 'h') return true;
    
    // Queen advanced toward king's side
    if (isWhiteKing && rank >= 4 && (file >= 'e')) return true;
    if (!isWhiteKing && rank <= 5 && (file >= 'e')) return true;
    
    return false;
}

/** v40.26: Check for dark-squared bishop */
function v40HasDarkSquaredBishop(board, color) {
    const bishopChar = color === 'w' ? 'B' : 'b';
    for (const [sq, piece] of board) {
        if (piece === bishopChar) {
            const file = sq.charCodeAt(0) - 'a'.charCodeAt(0);
            const rank = parseInt(sq[1]);
            // Dark square: (file + rank) is odd
            if ((file + rank) % 2 === 1) return true;
        }
    }
    return false;
}

/** v40.26: Count enemy kingside activity */
function v40CountEnemyKingsideActivity(board, enemyColor, isWhiteDefender) {
    let count = 0;
    const isEnemyWhite = enemyColor === 'w';
    
    for (const [sq, piece] of board) {
        if (!piece) continue;
        const pieceIsWhite = piece === piece.toUpperCase();
        if (pieceIsWhite !== isEnemyWhite) continue;
        
        const pieceType = piece.toLowerCase();
        if (pieceType === 'k' || pieceType === 'p') continue;
        
        const file = sq[0];
        const rank = parseInt(sq[1]);
        
        // Consider pieces on files e-h as kingside active
        if (file >= 'e') {
            // Also check if they're in attacking position
            if (isWhiteDefender) {
                if (rank >= 4) count++;
            } else {
                if (rank <= 5) count++;
            }
        }
    }
    
    return count;
}

/** v40.26: Check if knight can exploit weakness */
function v40HasKnightThatCanExploitWeakness(board, enemyColor, weakSquare, isWhiteDefender) {
    const knightChar = enemyColor === 'w' ? 'N' : 'n';
    const knightMoves = [[-2,-1],[-2,1],[-1,-2],[-1,2],[1,-2],[1,2],[2,-1],[2,1]];
    
    const weakFile = weakSquare.charCodeAt(0) - 'a'.charCodeAt(0);
    const weakRank = parseInt(weakSquare[1]);
    
    for (const [sq, piece] of board) {
        if (piece !== knightChar) continue;
        
        const knightFile = sq.charCodeAt(0) - 'a'.charCodeAt(0);
        const knightRank = parseInt(sq[1]);
        
        // Can knight reach weak square in 1-2 moves?
        for (const [df, dr] of knightMoves) {
            const newFile = knightFile + df;
            const newRank = knightRank + dr;
            
            if (newFile === weakFile && newRank === weakRank) return true;
            
            // Check 2-move reach
            for (const [df2, dr2] of knightMoves) {
                const nextFile = newFile + df2;
                const nextRank = newRank + dr2;
                if (nextFile === weakFile && nextRank === weakRank) return true;
            }
        }
    }
    
    return false;
}

/** v40.26: Calculate sacrifice consequence */
function v40CalculateSacrificeConsequence(board, attackerSq, targetSq, attackerColor, defenderColor) {
    // Simplified sacrifice analysis
    return {
        leadToMate: false,
        gainsMaterial: false,
        isSound: false
    };
}

/** v40.26: Check if kingside is under attack */
function v40IsKingsideUnderAttack(board, ourColor, enemyColor) {
    const enemyQueenPos = v40FindQueenPosition(board, enemyColor);
    if (enemyQueenPos && v40IsQueenThreateningKingside(enemyQueenPos, ourColor === 'w')) {
        return true;
    }
    
    const activity = v40CountEnemyKingsideActivity(board, enemyColor, ourColor === 'w');
    return activity >= 2;
}

/** v40.26: Check if move is defensive */
function v40IsMoveDefensive(move, board, ourColor, enemyColor) {
    const toSquare = move.substring(2, 4);
    const toFile = toSquare[0];
    const toRank = parseInt(toSquare[1]);
    const isWhite = ourColor === 'w';
    
    // Moving to defend king area
    const ourKing = findKing(board, ourColor);
    if (ourKing) {
        const kingFile = ourKing.charCodeAt(0) - 'a'.charCodeAt(0);
        const kingRank = parseInt(ourKing[1]);
        const moveFile = toFile.charCodeAt(0) - 'a'.charCodeAt(0);
        
        // Move is near king
        if (Math.abs(moveFile - kingFile) <= 2 && Math.abs(toRank - kingRank) <= 2) {
            return true;
        }
    }
    
    // Moving to block attack
    if (toFile >= 'f' && toFile <= 'h') {
        if ((isWhite && toRank <= 3) || (!isWhite && toRank >= 6)) {
            return true;
        }
    }
    
    return false;
}

/** v40.26: Check if move reinforces kingside */
function v40IsKingsideReinforcement(move, board, ourColor) {
    const fromSquare = move.substring(0, 2);
    const toSquare = move.substring(2, 4);
    const movingPiece = board.get(fromSquare);
    
    if (!movingPiece) return false;
    
    const toFile = toSquare[0];
    const toRank = parseInt(toSquare[1]);
    const isWhite = ourColor === 'w';
    
    // Piece moving to defend kingside
    if (toFile >= 'f') {
        if ((isWhite && toRank <= 3) || (!isWhite && toRank >= 6)) {
            return true;
        }
    }
    
    return false;
}

/** v40.26: Check if move is effective counterattack */
function v40IsEffectiveCounterattack(move, board, ourColor, enemyColor) {
    const toSquare = move.substring(2, 4);
    
    // Check if move attacks enemy king
    const enemyKing = findKing(board, enemyColor);
    if (!enemyKing) return false;
    
    const enemyKingFile = enemyKing.charCodeAt(0) - 'a'.charCodeAt(0);
    const enemyKingRank = parseInt(enemyKing[1]);
    const toFile = toSquare.charCodeAt(0) - 'a'.charCodeAt(0);
    const toRank = parseInt(toSquare[1]);
    
    // Move is near enemy king
    if (Math.abs(toFile - enemyKingFile) <= 2 && Math.abs(toRank - enemyKingRank) <= 2) {
        return true;
    }
    
    return false;
}

/** v40.26: Check if move creates fortress */
function v40CreatesFortress(move, board, ourColor) {
    const fromSquare = move.substring(0, 2);
    const toSquare = move.substring(2, 4);
    const movingPiece = board.get(fromSquare);
    
    if (!movingPiece) return false;
    
    const pieceType = movingPiece.toLowerCase();
    const toFile = toSquare[0];
    const toRank = parseInt(toSquare[1]);
    const isWhite = ourColor === 'w';
    
    // Knight on f3/f6 or g3/g6 is defensive
    if (pieceType === 'n') {
        if ((toFile === 'f' || toFile === 'g') && 
            ((isWhite && toRank === 3) || (!isWhite && toRank === 6))) {
            return true;
        }
    }
    
    // Rook on f1/f8 defends
    if (pieceType === 'r' && toFile === 'f') {
        if ((isWhite && toRank === 1) || (!isWhite && toRank === 8)) {
            return true;
        }
    }
    
    return false;
}

/** v40.26: Find sacrifice targets */
function v40FindSacrificeTargets(board, isWhiteDefender) {
    const targets = [];
    const enemyColor = isWhiteDefender ? 'b' : 'w';
    const dangerSquares = isWhiteDefender ? ['g3', 'h3', 'f3', 'h2'] : ['g6', 'h6', 'f6', 'h7'];
    
    for (const sq of dangerSquares) {
        const piece = board.get(sq);
        if (piece && piece.toLowerCase() === 'p') {
            const pieceIsWhite = piece === piece.toUpperCase();
            if (pieceIsWhite === isWhiteDefender) {
                // Our pawn on danger square - check if enemy can capture
                const attackers = findAttackersOfSquare(board, sq, enemyColor);
                for (const attacker of attackers) {
                    if (attacker.piece.toLowerCase() === 'b' || attacker.piece.toLowerCase() === 'q') {
                        targets.push({
                            attackerSquare: attacker.square,
                            targetSquare: sq,
                            attackerPiece: attacker.piece
                        });
                    }
                }
            }
        }
    }
    
    return targets;
}

/** v40.26: Calculate forcing line after sacrifice */
function v40CalculateForcingLineAfterSacrifice(board, attackerSq, targetSq, attackerColor, defenderColor, depth) {
    // Simplified forcing line calculation
    return {
        foundMate: false,
        winsQueen: false,
        winsMaterial: 0,
        mateIn: 0
    };
}

/** v40.26: Count kingside pawns */
function v40CountKingsidePawns(board, color) {
    let count = 0;
    const pawnChar = color === 'w' ? 'P' : 'p';
    
    for (const [sq, piece] of board) {
        if (piece !== pawnChar) continue;
        const file = sq[0];
        if (file >= 'f' && file <= 'h') count++;
    }
    
    return count;
}

/** v40.26: Check if file opens toward king */
function v40IsFileOpenToward(board, fileChar, kingSquare, ourColor) {
    const kingFile = kingSquare[0];
    const kingRank = parseInt(kingSquare[1]);
    const isWhite = ourColor === 'w';
    
    // Check if file has no pawns (open)
    for (const [sq, piece] of board) {
        if (sq[0] === fileChar && piece && piece.toLowerCase() === 'p') {
            return false; // File has a pawn, not open
        }
    }
    
    return true; // File is open
}

/** v40.26: Check if move creates kingside weakness */
function v40CreatesKingsideWeakness(move, boardBefore, boardAfter, ourColor) {
    const fromSquare = move.substring(0, 2);
    const toSquare = move.substring(2, 4);
    const movingPiece = boardBefore.get(fromSquare);
    
    if (!movingPiece) return false;
    
    // Pawn move on kingside creates weakness
    if (movingPiece.toLowerCase() === 'p') {
        const toFile = toSquare[0];
        if (toFile >= 'f' && toFile <= 'h') {
            return true;
        }
    }
    
    return false;
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function findAttackedPiecesV40_9(board, color) {"
Observation: Edit was successful.