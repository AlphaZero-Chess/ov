Now let me add the v40.13 ULTIMATE TACTICAL SUPREME functions after the v40.12 helper:
Action: file_editor str_replace /app/Lichess Bot-AlphaZero-Pure.user.js --old-str "    return false;
}

// ═══════════════════════════════════════════════════════════════════════════════

/**
 * v40.9 Helper: Find all attacked pieces for a color
 */" --new-str "    return false;
}

// ═══════════════════════════════════════════════════════════════════════════════
// v40.13 ULTIMATE TACTICAL SUPREME: ZERO BLUNDER TACTICAL SYSTEM
// From latest game analysis: Bot played Bd3 allowing exd3, losing pawn immediately
// Then queen infiltrated and ate everything (Qxd4, Qxe4, Qxg2, Qxh1, Qxh2)
// These functions ensure ABSOLUTE ZERO simple tactical oversights
// ═══════════════════════════════════════════════════════════════════════════════

/**
 * v40.13 ULTIMATE TACTICAL: IMMEDIATE MATERIAL LOSS DETECTION
 * Before ANY move, calculate if it immediately loses material
 * This is THE MOST CRITICAL function - prevents basic blunders like Bd3 allowing exd3
 */
function v40ImmediateMaterialLossEval(fen, move, board, activeColor, moveNumber) {
    if (!CONFIG.v40ImmediateCaptureDetectionEnabled) return 0;
    
    let score = 0;
    const isWhite = activeColor === 'w';
    const enemyColor = isWhite ? 'b' : 'w';
    
    try {
        const fromSquare = move.substring(0, 2);
        const toSquare = move.substring(2, 4);
        const movingPiece = board.get(fromSquare);
        
        if (!movingPiece) return 0;
        
        const movingPieceType = movingPiece.toLowerCase();
        const movingPieceValue = getPieceValueSimple(movingPieceType);
        
        // Simulate the move
        const simBoard = new Map(board);
        simBoard.delete(fromSquare);
        simBoard.set(toSquare, movingPiece);
        
        // CRITICAL CHECK 1: Is the destination square attacked by enemy?
        const isToSquareAttacked = isSquareAttackedByColor(simBoard, toSquare, enemyColor);
        
        if (isToSquareAttacked) {
            // Check if destination square is defended
            const isDefended = isSquareDefendedByColor(simBoard, toSquare, activeColor);
            
            if (!isDefended) {
                // ABSOLUTE DISASTER: Moving piece to undefended attacked square
                const penalty = movingPieceType === 'q' ? CONFIG.v40AllowQueenCapturePenalty :
                               movingPieceType === 'r' ? CONFIG.v40AllowRookCapturePenalty :
                               ['n', 'b'].includes(movingPieceType) ? CONFIG.v40AllowMinorPieceCapturePenalty :
                               CONFIG.v40AllowPawnCapturePenalty;
                
                score += penalty || -1500000;
                debugLog(\"[V40.13_TACTICAL]\", `☠️☠️☠️ BLUNDER: ${move} places ${movingPieceType.toUpperCase()} on UNDEFENDED ATTACKED square!`);
            } else {
                // Check if attackers are of lower value (bad trade)
                const attackers = findAttackersOfSquare(simBoard, toSquare, enemyColor);
                if (attackers.length > 0) {
                    const lowestAttackerValue = Math.min(...attackers.map(a => getPieceValueSimple(a.piece.toLowerCase())));
                    
                    if (lowestAttackerValue < movingPieceValue) {
                        // Bad trade: we're putting higher value piece where lower value can capture
                        const materialLoss = movingPieceValue - lowestAttackerValue;
                        score += -materialLoss * 50000;
                        debugLog(\"[V40.13_TACTICAL]\", `⚠️ BAD TRADE: ${movingPieceType.toUpperCase()} can be captured by lower value piece (-${materialLoss * 50000})`);
                    }
                }
            }
        }
        
        // CRITICAL CHECK 2: Does this move leave a piece hanging?
        // After we move, check if any of our pieces are now undefended and attacked
        for (const [sq, piece] of simBoard) {
            if (!piece) continue;
            const pieceIsWhite = piece === piece.toUpperCase();
            if (pieceIsWhite !== isWhite) continue;
            if (sq === toSquare) continue; // Already checked
            
            const pieceType = piece.toLowerCase();
            if (pieceType === 'k') continue;
            
            const wasDefended = isSquareDefendedByColor(board, sq, activeColor);
            const isNowDefended = isSquareDefendedByColor(simBoard, sq, activeColor);
            const isAttacked = isSquareAttackedByColor(simBoard, sq, enemyColor);
            
            // If piece was defended by the moving piece and is now hanging
            if (wasDefended && !isNowDefended && isAttacked) {
                const pieceValue = getPieceValueSimple(pieceType);
                score += CONFIG.v40HangPieceMovePenalty * (pieceValue / 1000) || -1500000;
                debugLog(\"[V40.13_TACTICAL]\", `☠️ DISASTER: Move ${move} leaves ${pieceType.toUpperCase()} on ${sq} HANGING!`);
            }
        }
        
        // CRITICAL CHECK 3: Does moving from this square allow enemy to capture something?
        // The piece we moved might have been blocking an attack
        const wasBlockingAttacks = checkIfPieceWasBlockingAttack(board, simBoard, fromSquare, activeColor, enemyColor);
        if (wasBlockingAttacks.loss > 0) {
            score += -wasBlockingAttacks.loss * 100000;
            debugLog(\"[V40.13_TACTICAL]\", `⚠️ DISCOVERED ATTACK: Moving from ${fromSquare} exposes ${wasBlockingAttacks.piece} to capture!`);
        }
        
    } catch (e) {
        debugLog(\"[V40.13_TACTICAL]\", `Error in ImmediateMaterialLoss: ${e.message}`);
    }
    
    return score;
}

/**
 * v40.13 ULTIMATE TACTICAL: CHECK IF PIECE WAS BLOCKING ATTACK
 * Helper to detect discovered attacks when we move a piece
 */
function checkIfPieceWasBlockingAttack(originalBoard, newBoard, movedFromSquare, ourColor, enemyColor) {
    const isWhite = ourColor === 'w';
    let maxLoss = { loss: 0, piece: null };
    
    try {
        // Check all our pieces to see if any are now exposed
        for (const [sq, piece] of newBoard) {
            if (!piece) continue;
            const pieceIsWhite = piece === piece.toUpperCase();
            if (pieceIsWhite !== isWhite) continue;
            
            const pieceType = piece.toLowerCase();
            if (pieceType === 'k') continue;
            
            // Was this piece safe before and now attacked?
            const wasAttackedBefore = isSquareAttackedByColor(originalBoard, sq, enemyColor);
            const isAttackedNow = isSquareAttackedByColor(newBoard, sq, enemyColor);
            
            if (!wasAttackedBefore && isAttackedNow) {
                const isDefended = isSquareDefendedByColor(newBoard, sq, ourColor);
                if (!isDefended) {
                    const value = getPieceValueSimple(pieceType);
                    if (value > maxLoss.loss) {
                        maxLoss = { loss: value, piece: pieceType.toUpperCase() };
                    }
                }
            }
        }
    } catch (e) {
        // Silent fail
    }
    
    return maxLoss;
}

/**
 * v40.13 ULTIMATE TACTICAL: CAPTURE CHAIN ANALYSIS
 * Calculate the result of a sequence of captures (A takes B, C takes A, D takes C, etc.)
 */
function v40CaptureChainAnalysisEval(fen, move, board, activeColor, moveNumber) {
    if (!CONFIG.v40RecaptureChainEnabled) return 0;
    
    let score = 0;
    const isWhite = activeColor === 'w';
    
    try {
        const fromSquare = move.substring(0, 2);
        const toSquare = move.substring(2, 4);
        const movingPiece = board.get(fromSquare);
        const capturedPiece = board.get(toSquare);
        
        // Only analyze captures
        if (!movingPiece || !capturedPiece) return 0;
        
        const movingType = movingPiece.toLowerCase();
        const capturedType = capturedPiece.toLowerCase();
        const movingValue = getPieceValueSimple(movingType);
        const capturedValue = getPieceValueSimple(capturedType);
        
        // Simulate the capture
        const simBoard = new Map(board);
        simBoard.delete(fromSquare);
        simBoard.set(toSquare, movingPiece);
        
        // Now calculate recapture chain
        let materialBalance = capturedValue; // Start with what we captured
        let currentSquare = toSquare;
        let currentValue = movingValue;
        let depth = 0;
        let isOurTurn = false; // After we capture, enemy moves
        
        const enemyColor = isWhite ? 'b' : 'w';
        
        while (depth < (CONFIG.v40BadTradeDetectionDepth || 3)) {
            const attackerColor = isOurTurn ? activeColor : enemyColor;
            const attackers = findAttackersOfSquare(simBoard, currentSquare, attackerColor);
            
            if (attackers.length === 0) break;
            
            // Find lowest value attacker
            const lowestAttacker = attackers.reduce((min, a) => 
                getPieceValueSimple(a.piece.toLowerCase()) < getPieceValueSimple(min.piece.toLowerCase()) ? a : min
            );
            
            const attackerValue = getPieceValueSimple(lowestAttacker.piece.toLowerCase());
            
            // Simulate recapture
            if (!isOurTurn) {
                // Enemy recaptures - we lose our piece
                materialBalance -= currentValue;
            } else {
                // We recapture - we gain their piece
                materialBalance += currentValue;
            }
            
            // Update for next iteration
            simBoard.delete(lowestAttacker.square);
            simBoard.set(currentSquare, lowestAttacker.piece);
            currentValue = attackerValue;
            isOurTurn = !isOurTurn;
            depth++;
        }
        
        // If material balance is negative, this is a bad capture chain
        if (materialBalance < 0) {
            score += CONFIG.v40CaptureChainLossPenalty * (Math.abs(materialBalance) / 100) || -500000;
            debugLog(\"[V40.13_CHAIN]\", `⚠️ BAD CAPTURE CHAIN: ${move} results in net loss of ${-materialBalance} centipawns`);
        } else if (materialBalance > capturedValue) {
            // We gain more than initially captured - good!
            score += materialBalance * 100;
            debugLog(\"[V40.13_CHAIN]\", `✅ GOOD CAPTURE CHAIN: ${move} gains ${materialBalance} centipawns`);
        }
        
    } catch (e) {
        debugLog(\"[V40.13_CHAIN]\", `Error: ${e.message}`);
    }
    
    return score;
}

/**
 * v40.13 ULTIMATE TACTICAL: QUEEN INFILTRATION ABSOLUTE PREVENTION
 * Don't allow enemy queen to reach squares where it can eat pieces freely
 */
function v40QueenInfiltrationAbsoluteEval(fen, move, board, activeColor, moveNumber) {
    if (!CONFIG.v40QueenInfiltrationAbsoluteEnabled) return 0;
    
    let score = 0;
    const isWhite = activeColor === 'w';
    const enemyColor = isWhite ? 'b' : 'w';
    const enemyQueenChar = isWhite ? 'q' : 'Q';
    
    try {
        // Find enemy queen
        let enemyQueenSquare = null;
        for (const [sq, piece] of board) {
            if (piece === enemyQueenChar) {
                enemyQueenSquare = sq;
                break;
            }
        }
        
        if (!enemyQueenSquare) return 0;
        
        // Simulate our move
        const fromSquare = move.substring(0, 2);
        const toSquare = move.substring(2, 4);
        const movingPiece = board.get(fromSquare);
        
        const simBoard = new Map(board);
        simBoard.delete(fromSquare);
        simBoard.set(toSquare, movingPiece);
        
        // Now check what the enemy queen can capture
        // Find all squares queen can move to
        const queenFile = enemyQueenSquare.charCodeAt(0) - 97;
        const queenRank = parseInt(enemyQueenSquare[1]);
        
        // Check all directions queen can move
        const directions = [
            [0, 1], [0, -1], [1, 0], [-1, 0], // Rook moves
            [1, 1], [1, -1], [-1, 1], [-1, -1] // Bishop moves
        ];
        
        for (const [df, dr] of directions) {
            for (let dist = 1; dist <= 7; dist++) {
                const targetFile = queenFile + df * dist;
                const targetRank = queenRank + dr * dist;
                
                if (targetFile < 0 || targetFile > 7 || targetRank < 1 || targetRank > 8) break;
                
                const targetSquare = String.fromCharCode(97 + targetFile) + targetRank;
                const targetPiece = simBoard.get(targetSquare);
                
                if (targetPiece) {
                    const targetIsWhite = targetPiece === targetPiece.toUpperCase();
                    
                    if (targetIsWhite === isWhite) {
                        // Our piece - queen might capture it
                        const targetType = targetPiece.toLowerCase();
                        
                        // Check if our piece is defended
                        const isDefended = isSquareDefendedByColor(simBoard, targetSquare, activeColor);
                        
                        if (!isDefended && targetType !== 'k') {
                            // FREE CAPTURE for enemy queen
                            const penalty = targetType === 'q' ? CONFIG.v40AllowQueenCapturePenalty :
                                           targetType === 'r' ? CONFIG.v40AllowQueenEatRookPenalty :
                                           ['n', 'b'].includes(targetType) ? CONFIG.v40AllowQueenEatMinorPiecePenalty :
                                           CONFIG.v40AllowQueenEatPawnPenalty;
                            
                            score += penalty || -800000;
                            debugLog(\"[V40.13_QINFILT]\", `☠️ QUEEN CAN EAT ${targetType.toUpperCase()} on ${targetSquare} for FREE after ${move}!`);
                        }
                    }
                    break; // Queen blocked by this piece
                }
            }
        }
        
        // Check if queen can reach back rank (very dangerous)
        const ourBackRank = isWhite ? '1' : '8';
        for (let file = 0; file < 8; file++) {
            const backRankSquare = String.fromCharCode(97 + file) + ourBackRank;
            if (canQueenReachSquare(simBoard, enemyQueenSquare, backRankSquare)) {
                const pieceOnSquare = simBoard.get(backRankSquare);
                if (!pieceOnSquare) {
                    // Empty back rank square queen can reach
                    score += CONFIG.v40AllowQueenReachBackRankPenalty / 10 || -80000;
                }
            }
        }
        
    } catch (e) {
        debugLog(\"[V40.13_QINFILT]\", `Error: ${e.message}`);
    }
    
    return score;
}

/**
 * v40.13 Helper: Check if queen can reach a target square
 */
function canQueenReachSquare(board, queenSquare, targetSquare) {
    const qFile = queenSquare.charCodeAt(0) - 97;
    const qRank = parseInt(queenSquare[1]);
    const tFile = targetSquare.charCodeAt(0) - 97;
    const tRank = parseInt(targetSquare[1]);
    
    const fileDiff = tFile - qFile;
    const rankDiff = tRank - qRank;
    
    // Must be on same file, rank, or diagonal
    if (fileDiff !== 0 && rankDiff !== 0 && Math.abs(fileDiff) !== Math.abs(rankDiff)) {
        return false;
    }
    
    // Check path is clear
    const fileStep = fileDiff === 0 ? 0 : fileDiff > 0 ? 1 : -1;
    const rankStep = rankDiff === 0 ? 0 : rankDiff > 0 ? 1 : -1;
    
    let currentFile = qFile + fileStep;
    let currentRank = qRank + rankStep;
    
    while (currentFile !== tFile || currentRank !== tRank) {
        const sq = String.fromCharCode(97 + currentFile) + currentRank;
        if (board.get(sq)) return false; // Blocked
        currentFile += fileStep;
        currentRank += rankStep;
    }
    
    return true;
}

/**
 * v40.13 ULTIMATE TACTICAL: PRE-MOVE SAFETY CHECK
 * Every single move must pass a comprehensive safety check
 */
function v40PreMoveSafetyCheckEval(fen, move, board, activeColor, moveNumber) {
    if (!CONFIG.v40PreMoveSafetyCheckEnabled) return 0;
    
    let score = 0;
    const isWhite = activeColor === 'w';
    const enemyColor = isWhite ? 'b' : 'w';
    
    try {
        const fromSquare = move.substring(0, 2);
        const toSquare = move.substring(2, 4);
        const movingPiece = board.get(fromSquare);
        
        if (!movingPiece) return 0;
        
        const movingType = movingPiece.toLowerCase();
        const movingValue = getPieceValueSimple(movingType);
        
        // Simulate the move
        const simBoard = new Map(board);
        simBoard.delete(fromSquare);
        const capturedPiece = simBoard.get(toSquare);
        simBoard.set(toSquare, movingPiece);
        
        const capturedValue = capturedPiece ? getPieceValueSimple(capturedPiece.toLowerCase()) : 0;
        
        // Count our material before and after enemy's best reply
        let ourMaterialBefore = 0;
        let enemyMaterialBefore = 0;
        
        for (const [sq, piece] of board) {
            if (!piece) continue;
            const pieceIsWhite = piece === piece.toUpperCase();
            const value = getPieceValueSimple(piece.toLowerCase());
            
            if (pieceIsWhite === isWhite) {
                ourMaterialBefore += value;
            } else {
                enemyMaterialBefore += value;
            }
        }
        
        // After our move
        let ourMaterialAfter = ourMaterialBefore + capturedValue; // We captured something
        let enemyMaterialAfter = enemyMaterialBefore - capturedValue;
        
        // Now find best enemy capture after our move
        let bestEnemyCapture = 0;
        for (const [sq, piece] of simBoard) {
            if (!piece) continue;
            const pieceIsWhite = piece === piece.toUpperCase();
            if (pieceIsWhite === isWhite) continue; // Our piece
            
            const pieceType = piece.toLowerCase();
            
            // Find squares this piece can capture
            const captureSquares = findPossibleCaptures(simBoard, sq, piece);
            
            for (const capSq of captureSquares) {
                const victimPiece = simBoard.get(capSq);
                if (victimPiece) {
                    const victimIsWhite = victimPiece === victimPiece.toUpperCase();
                    if (victimIsWhite === isWhite) {
                        // Enemy can capture our piece
                        const victimValue = getPieceValueSimple(victimPiece.toLowerCase());
                        const attackerValue = getPieceValueSimple(pieceType);
                        
                        // Is our piece defended?
                        const isDefended = isSquareDefendedByColor(simBoard, capSq, activeColor);
                        
                        let netGain = victimValue;
                        if (isDefended) {
                            netGain = victimValue - attackerValue;
                        }
                        
                        if (netGain > bestEnemyCapture) {
                            bestEnemyCapture = netGain;
                        }
                    }
                }
            }
        }
        
        // If enemy has a profitable capture, penalize
        if (bestEnemyCapture > 0) {
            const netExchange = capturedValue - bestEnemyCapture;
            if (netExchange < 0) {
                score += CONFIG.v40UnsafeMoveAbsolutePenalty * (Math.abs(netExchange) / 900) || -1500000;
                debugLog(\"[V40.13_SAFETY]\", `☠️ UNSAFE MOVE: ${move} allows enemy to gain ${bestEnemyCapture} - we only gain ${capturedValue}`);
            }
        }
        
    } catch (e) {
        debugLog(\"[V40.13_SAFETY]\", `Error: ${e.message}`);
    }
    
    return score;
}

/**
 * v40.13 Helper: Find all squares a piece can capture on
 */
function findPossibleCaptures(board, fromSquare, piece) {
    const captures = [];
    const pieceType = piece.toLowerCase();
    const isWhite = piece === piece.toUpperCase();
    
    const file = fromSquare.charCodeAt(0) - 97;
    const rank = parseInt(fromSquare[1]);
    
    try {
        if (pieceType === 'p') {
            // Pawn captures diagonally
            const captureRank = isWhite ? rank + 1 : rank - 1;
            if (captureRank >= 1 && captureRank <= 8) {
                if (file > 0) captures.push(String.fromCharCode(96 + file) + captureRank);
                if (file < 7) captures.push(String.fromCharCode(98 + file) + captureRank);
            }
        } else if (pieceType === 'n') {
            // Knight moves
            const knightMoves = [[-2,-1],[-2,1],[-1,-2],[-1,2],[1,-2],[1,2],[2,-1],[2,1]];
            for (const [df, dr] of knightMoves) {
                const newFile = file + df;
                const newRank = rank + dr;
                if (newFile >= 0 && newFile <= 7 && newRank >= 1 && newRank <= 8) {
                    captures.push(String.fromCharCode(97 + newFile) + newRank);
                }
            }
        } else if (pieceType === 'b' || pieceType === 'q') {
            // Diagonal moves
            const diagonals = [[1,1],[1,-1],[-1,1],[-1,-1]];
            for (const [df, dr] of diagonals) {
                for (let dist = 1; dist <= 7; dist++) {
                    const newFile = file + df * dist;
                    const newRank = rank + dr * dist;
                    if (newFile < 0 || newFile > 7 || newRank < 1 || newRank > 8) break;
                    const sq = String.fromCharCode(97 + newFile) + newRank;
                    captures.push(sq);
                    if (board.get(sq)) break; // Blocked
                }
            }
        }
        
        if (pieceType === 'r' || pieceType === 'q') {
            // Straight moves
            const straights = [[0,1],[0,-1],[1,0],[-1,0]];
            for (const [df, dr] of straights) {
                for (let dist = 1; dist <= 7; dist++) {
                    const newFile = file + df * dist;
                    const newRank = rank + dr * dist;
                    if (newFile < 0 || newFile > 7 || newRank < 1 || newRank > 8) break;
                    const sq = String.fromCharCode(97 + newFile) + newRank;
                    captures.push(sq);
                    if (board.get(sq)) break; // Blocked
                }
            }
        }
        
        if (pieceType === 'k') {
            // King moves (one square in any direction)
            for (let df = -1; df <= 1; df++) {
                for (let dr = -1; dr <= 1; dr++) {
                    if (df === 0 && dr === 0) continue;
                    const newFile = file + df;
                    const newRank = rank + dr;
                    if (newFile >= 0 && newFile <= 7 && newRank >= 1 && newRank <= 8) {
                        captures.push(String.fromCharCode(97 + newFile) + newRank);
                    }
                }
            }
        }
    } catch (e) {
        // Silent fail
    }
    
    return captures;
}

/**
 * v40.13 ULTIMATE TACTICAL: OPENING BLUNDER PREVENTION
 * Prevent common opening blunders like developing to attacked squares
 */
function v40OpeningBlunderPreventionEval(fen, move, board, activeColor, moveNumber) {
    if (!CONFIG.v40OpeningBlunderPreventionEnabled) return 0;
    if (moveNumber > 15) return 0; // Opening only
    
    let score = 0;
    const isWhite = activeColor === 'w';
    const enemyColor = isWhite ? 'b' : 'w';
    
    try {
        const fromSquare = move.substring(0, 2);
        const toSquare = move.substring(2, 4);
        const movingPiece = board.get(fromSquare);
        
        if (!movingPiece) return 0;
        
        const movingType = movingPiece.toLowerCase();
        
        // CHECK 1: Don't develop piece to attacked square in opening
        if (['n', 'b', 'q'].includes(movingType)) {
            const isToSquareAttacked = isSquareAttackedByColor(board, toSquare, enemyColor);
            
            if (isToSquareAttacked) {
                const isDefended = isSquareDefendedByColor(board, toSquare, activeColor);
                
                if (!isDefended) {
                    score += CONFIG.v40DevelopPieceToUnsafeSquarePenalty || -1000000;
                    debugLog(\"[V40.13_OPENING]\", `☠️ OPENING BLUNDER: Developing ${movingType.toUpperCase()} to undefended attacked square ${toSquare}!`);
                }
            }
        }
        
        // CHECK 2: Don't expose queen early (moves 1-10)
        if (movingType === 'q' && moveNumber <= 10) {
            // Queen moves in opening should be penalized unless absolutely necessary
            const fromFile = fromSquare.charCodeAt(0) - 97;
            const toFile = toSquare.charCodeAt(0) - 97;
            
            // Moving queen far from starting position
            if (Math.abs(toFile - (isWhite ? 3 : 3)) > 2) {
                score += CONFIG.v40ExposeQueenEarlyPenalty / 2 || -300000;
                debugLog(\"[V40.13_OPENING]\", `⚠️ EARLY QUEEN MOVE: Moving queen to ${toSquare} in opening`);
            }
        }
        
        // CHECK 3: Don't move same piece twice in opening without reason
        // This requires tracking move history which we don't have here
        // Instead, penalize moving pieces back to starting area
        if (['n', 'b'].includes(movingType) && moveNumber <= 8) {
            const startRank = isWhite ? '1' : '8';
            if (toSquare[1] === startRank) {
                score += CONFIG.v40MoveSamePieceTwicePenalty || -300000;
                debugLog(\"[V40.13_OPENING]\", `⚠️ Moving ${movingType.toUpperCase()} back to start rank in opening`);
            }
        }
        
    } catch (e) {
        debugLog(\"[V40.13_OPENING]\", `Error: ${e.message}`);
    }
    
    return score;
}

/**
 * v40.13 ULTIMATE TACTICAL: SIMPLE THREAT DETECTION
 * Detect simple 1-2 move threats that could win material
 */
function v40SimpleThreatDetectionEval(fen, move, board, activeColor, moveNumber) {
    if (!CONFIG.v40TacticalOversightZeroEnabled) return 0;
    
    let score = 0;
    const isWhite = activeColor === 'w';
    const enemyColor = isWhite ? 'b' : 'w';
    
    try {
        const fromSquare = move.substring(0, 2);
        const toSquare = move.substring(2, 4);
        const movingPiece = board.get(fromSquare);
        
        if (!movingPiece) return 0;
        
        // Simulate our move
        const simBoard = new Map(board);
        simBoard.delete(fromSquare);
        const capturedPiece = simBoard.get(toSquare);
        simBoard.set(toSquare, movingPiece);
        
        // After our move, what threats does enemy have?
        // Check for undefended pieces that enemy can now capture
        let threatScore = 0;
        
        for (const [sq, piece] of simBoard) {
            if (!piece) continue;
            const pieceIsWhite = piece === piece.toUpperCase();
            if (pieceIsWhite !== isWhite) continue; // Not our piece
            if (sq === toSquare) continue; // We just moved here
            
            const pieceType = piece.toLowerCase();
            if (pieceType === 'k') continue;
            
            // Is this piece under attack?
            const isAttacked = isSquareAttackedByColor(simBoard, sq, enemyColor);
            const isDefended = isSquareDefendedByColor(simBoard, sq, activeColor);
            
            if (isAttacked && !isDefended) {
                // HANGING PIECE after our move!
                const pieceValue = getPieceValueSimple(pieceType);
                threatScore += pieceValue;
                debugLog(\"[V40.13_THREAT]\", `⚠️ After ${move}, ${pieceType.toUpperCase()} on ${sq} is HANGING!`);
            }
        }
        
        if (threatScore > 0) {
            score += CONFIG.v40SimpleThreatMissPenalty * (threatScore / 900) || -1000000;
        }
        
        // Also check: Does our move CREATE a threat?
        // If we're moving to attack something valuable, that's good
        const movingType = movingPiece.toLowerCase();
        const attackedSquares = findPossibleCaptures(simBoard, toSquare, movingPiece);
        
        for (const attackSq of attackedSquares) {
            const targetPiece = simBoard.get(attackSq);
            if (targetPiece) {
                const targetIsWhite = targetPiece === targetPiece.toUpperCase();
                if (targetIsWhite !== isWhite) {
                    // We're attacking enemy piece
                    const targetType = targetPiece.toLowerCase();
                    const targetValue = getPieceValueSimple(targetType);
                    const movingValue = getPieceValueSimple(movingType);
                    
                    // Is it a good attack? (we attack higher value or undefended)
                    const isTargetDefended = isSquareDefendedByColor(simBoard, attackSq, enemyColor);
                    
                    if (!isTargetDefended || targetValue > movingValue) {
                        score += targetValue * 50; // Small bonus for creating threats
                    }
                }
            }
        }
        
    } catch (e) {
        debugLog(\"[V40.13_THREAT]\", `Error: ${e.message}`);
    }
    
    return score;
}

// ═══════════════════════════════════════════════════════════════════════════════

/**
 * v40.9 Helper: Find all attacked pieces for a color
 */"
Observation: Edit was successful.