There's a duplicate `v40ExchangeQualityEval` function (at line 10341 and 26193). Let me check the integration and view what's happening with this:
Action: file_editor view /app/Lichess Bot-AlphaZero-Pure.user.js
Observation: /app/Lichess Bot-AlphaZero-Pure.user.js:
26270|    return score;
26271|}
26272|
26273|/**
26274| * v40.36 Helper: Count developed pieces
26275| */
26276|function v40CountDevelopedPieces(board, isWhite) {
26277|    let count = 0;
26278|    
26279|    // Starting squares for pieces
26280|    const whiteStartingSquares = {
26281|        'b1': 'n', 'g1': 'n', 'c1': 'b', 'f1': 'b'
26282|    };
26283|    const blackStartingSquares = {
26284|        'b8': 'n', 'g8': 'n', 'c8': 'b', 'f8': 'b'
26285|    };
26286|    
26287|    const startingSquares = isWhite ? whiteStartingSquares : blackStartingSquares;
26288|    
26289|    // Count pieces that have moved from starting squares
26290|    for (const [startSq, pieceType] of Object.entries(startingSquares)) {
26291|        const piece = board.get(startSq);
26292|        const expectedPiece = isWhite ? pieceType.toUpperCase() : pieceType;
26293|        
26294|        // If the expected piece is NOT on its starting square, it's developed
26295|        if (!piece || piece !== expectedPiece) {
26296|            count++;
26297|        }
26298|    }
26299|    
26300|    // Also check if castled (king moved)
26301|    const kingStartSq = isWhite ? 'e1' : 'e8';
26302|    const kingPiece = board.get(kingStartSq);
26303|    const expectedKing = isWhite ? 'K' : 'k';
26304|    if (!kingPiece || kingPiece !== expectedKing) {
26305|        count++; // Castled or king moved
26306|    }
26307|    
26308|    return count;
26309|}
26310|
26311|// ═══════════════════════════════════════════════════════════════════════════════
26312|function findAttackedPiecesV40_9(board, color) {
26313|    const attacked = [];
26314|    const isWhite = color === 'w';
26315|    const enemyColor = isWhite ? 'b' : 'w';
26316|    
26317|    for (const [square, piece] of board) {
26318|        if (!piece) continue;
26319|        const pieceIsWhite = piece === piece.toUpperCase();
26320|        if (pieceIsWhite !== isWhite) continue;
26321|        
26322|        const pieceType = piece.toLowerCase();
26323|        if (pieceType === 'k') continue;  // King attacks handled separately
26324|        
26325|        // Check if this square is attacked by enemy
26326|        if (isSquareAttackedByColor(board, square, enemyColor)) {
26327|            // Check if it's adequately defended
26328|            const isDefended = isSquareDefendedByColor(board, square, color);
26329|            
26330|            // If attacked by something of lower value, still need to consider
26331|            const attackers = findAttackersOfSquare(board, square, enemyColor);
26332|            const lowestAttackerValue = Math.min(...attackers.map(a => getPieceValueSimple(a.piece.toLowerCase())));
26333|            const ourPieceValue = getPieceValueSimple(pieceType);
26334|            
26335|            // Consider it under attack if:
26336|            // 1. Not defended at all, or
26337|            // 2. Attacker is of lower value than our piece
26338|            if (!isDefended || lowestAttackerValue < ourPieceValue) {
26339|                attacked.push({
26340|                    square,
26341|                    piece,
26342|                    value: ourPieceValue,
26343|                    lowestAttackerValue
26344|                });
26345|            }
26346|        }
26347|    }
26348|    
26349|    // Sort by piece value (highest first - queen, then rook, etc.)
26350|    attacked.sort((a, b) => b.value - a.value);
